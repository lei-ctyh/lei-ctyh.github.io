<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker小册 | 知了</title><meta name="author" content="Zhang Lei"><meta name="copyright" content="Zhang Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker 简介是什么Docker 是一种开源的容器化平台，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是一种轻量级、独立、可执行的软件包，包含了运行一个应用所需的所有内容：代码、运行时环境、系统工具、系统库等。Docker 可以让开发者快速地构建、测试和部署应用程序，而无需担心跨环境的兼容性问题。 传统虚拟机和容器">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker小册">
<meta property="og:url" content="https://lei-ctyh.github.io/2024/12/09/archive/Docker%E5%B0%8F%E5%86%8C/index.html">
<meta property="og:site_name" content="知了">
<meta property="og:description" content="Docker 简介是什么Docker 是一种开源的容器化平台，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是一种轻量级、独立、可执行的软件包，包含了运行一个应用所需的所有内容：代码、运行时环境、系统工具、系统库等。Docker 可以让开发者快速地构建、测试和部署应用程序，而无需担心跨环境的兼容性问题。 传统虚拟机和容器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&cs=tinysrgb&w=800">
<meta property="article:published_time" content="2024-12-09T01:59:45.000Z">
<meta property="article:modified_time" content="2024-12-09T02:29:14.000Z">
<meta property="article:author" content="Zhang Lei">
<meta property="article:tag" content="数据&#x2F;activemq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&cs=tinysrgb&w=800"><link rel="shortcut icon" href="/images/icon/favicon-32x32.png"><link rel="canonical" href="https://lei-ctyh.github.io/2024/12/09/archive/Docker%E5%B0%8F%E5%86%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker小册',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://bing.img.run/uhd.php);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">知了</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker小册</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker小册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T01:59:45.000Z" title="发表于 2024-12-09 09:59:45">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-09T02:29:14.000Z" title="更新于 2024-12-09 10:29:14">2024-12-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Docker 是一种开源的容器化平台，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是一种轻量级、独立、可执行的软件包，包含了运行一个应用所需的所有内容：代码、运行时环境、系统工具、系统库等。Docker 可以让开发者快速地构建、测试和部署应用程序，而无需担心跨环境的兼容性问题。</p>
<h3 id="传统虚拟机和容器"><a href="#传统虚拟机和容器" class="headerlink" title="传统虚拟机和容器"></a>传统虚拟机和容器</h3><blockquote>
<p>传统虚拟机（virtual machine）：</p>
</blockquote>
<p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如 VirtualBox、VMware 等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p>
<p>缺点：资源占用多、冗余步骤多、启动慢</p>
<blockquote>
<p>Linux 容器（Linux Container，简称 LXC）：</p>
</blockquote>
<p>Linux 容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行</p>
<blockquote>
<p>差异对比：</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>大小</td>
<td>一般为 Mb</td>
<td>一般为 Gb</td>
</tr>
<tr>
<td>速度</td>
<td>接近原生</td>
<td>比较慢</td>
</tr>
<tr>
<td>系统支持数量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li>应用程序容器化： Docker 可以将应用程序及其依赖项打包到一个容器中，使其在任何环境中都能以相同的方式运行，从而简化部署和维护。</li>
<li>开发环境管理： Docker 可以用于创建和管理开发环境，确保团队中的所有成员都使用相同的开发环境，避免由于环境差异而导致的问题。</li>
<li>持续集成和持续部署（CI&#x2F;CD）： Docker 可以与 CI&#x2F;CD 工具集成，实现自动化构建、测试和部署流程，提高开发团队的效率。</li>
<li>微服务架构： Docker 可以帮助将应用程序拆分为多个微服务，每个微服务都运行在自己的容器中，从而实现更好的可伸缩性和灵活性。</li>
<li>快速部署和扩展： Docker 可以快速部署新的容器实例，并根据需求扩展容器数量，以满足应用程序的需求。</li>
<li>资源隔离和安全性： Docker 提供了一定程度的资源隔离，使得不同容器之间的应用程序能够相互独立运行，提高安全性。</li>
</ol>
<p>总的来说，Docker 是一个非常灵活和强大的工具，可以帮助开发者和运维团队简化应用程序的开发、部署和管理过程。</p>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><h3 id="三个基本概念"><a href="#三个基本概念" class="headerlink" title="三个基本概念"></a>三个基本概念</h3><ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：由某特定的 docker 镜像的所有迭代版本组成的镜像仓库。仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>对象</td>
</tr>
<tr>
<td>镜像</td>
<td>类</td>
</tr>
</tbody></table>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>Docker 使用客户端 - 服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 守护进程运行在主机上，然后通过 Socket 连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320095558960.png"></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><blockquote>
<p>这一块刚接触有点难以理解，先有个大概印象就可以，后续再回头补充</p>
</blockquote>
<ol>
<li><p>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p>
</li>
<li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p>
</li>
<li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p>
</li>
<li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p>
</li>
<li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p>
</li>
<li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p>
</li>
<li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p>
</li>
</ol>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320095829501.png"></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Docker 镜像 (Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td>Docker 容器 (Container)</td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td>Docker 客户端 (Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>Docker 主机 (Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td>Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br><br>Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br><br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。<br><br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过  &lt;仓库名&gt;:&lt;标签&gt;  的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以  latest  作为默认标签。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>关于 Docker 的安装，不同平台的安装方式不太一样，本文中以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">CentOS 系统安装</a> 为例，若是想在其他平台安装 Docker，可以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">官网安装教程</a>，或者 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">菜鸟安装教程</a></p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 (64-bit) 上，要求系统为 64 位、Linux 系统内核版本为 3.8 以上，这里选用 Centos7.x</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前linux系统的发行版本</span></span><br><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br><span class="line"><span class="comment"># uname命令用于打印当前系统相关信息（内核版本号、和操作系统类型等）。</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318212342461.png"></p>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="安装-Gcc-环境"><a href="#安装-Gcc-环境" class="headerlink" title="安装 Gcc 环境"></a>安装 Gcc 环境</h3><p>gcc 几乎是开发环境下的必装，我们在安装 centerOS 系统时，在软件选择界面有勾选安装 [[]] 开发工具选项，会自动带上 gcc 环境，如果不确定是否应安装了 gcc 环境，可参考我的另一篇文章 <a href="Redis%E5%B0%8F%E5%86%8C.md">Redis 小册</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<h3 id="配置-Yum-资源库"><a href="#配置-Yum-资源库" class="headerlink" title="配置 Yum 资源库"></a>配置 Yum 资源库</h3><blockquote>
<p>安装 <code>yum-config-manager</code>：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum-util提供yum-config-manager功能</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318221558649.png"></p>
<blockquote>
<p>配置 docker 的资源库地址：</p>
</blockquote>
<ol>
<li>官方地址：（比较慢，不推荐），如果配置的镜像地址是国外的，很容易出现在拉取镜像时链接超时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在yum资源库中添加docker资源库</span></span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>阿里云镜像地址：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318222200485.png"></p>
<p>阿里云官网提供了很多资源镜像，镜像地址：<code>https://mirrors.aliyun.com</code>，进入之后可以选择自己需要的资源进行配置</p>
<blockquote>
<p>创建缓存（可选）</p>
</blockquote>
<p>此处好像涉及 linux 的基础知识，执行了以下命令，后续下载会快一些。暂且在这留个坑吧！ TODO</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318222402380.png"></p>
<h3 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h3><blockquote>
<p>安装最新版本的 Docker 引擎、Docker 客户端：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line"><span class="built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要安装制定版本：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="comment"># sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line"><span class="built_in">sudo</span> yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223305552.png"></p>
<p>安装过程中会出现两次是否继续的选项，按照提示输入 <code>y</code>，然后点击 <code>Enter</code> 即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223517816.png"></p>
<p>安装完成的提示：</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223611540.png"></p>
<h3 id="启动-Docker-引擎"><a href="#启动-Docker-引擎" class="headerlink" title="启动 Docker 引擎"></a>启动 Docker 引擎</h3><p>如果没有启动 Docker 引擎，那么执行 <code>docker version</code> 查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker 引擎客户端）的版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h3 id="配置用户权限"><a href="#配置用户权限" class="headerlink" title="配置用户权限"></a>配置用户权限</h3><blockquote>
<p>案例演示（异常分析）：</p>
</blockquote>
<p>未启动 Docker 引擎的情况下查看 <code>docker version</code>，我们只能看到客户端的版本信息，然而启动 Docker 服务时，我们输入了一次用户密码，发现由于权限问题仍然没有启动 Docker 引擎。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318224158376.png"></p>
<p>解决方案如下：</p>
<ul>
<li>方案 ①：使用 sudo 获取管理员权限，运行 docker 命令。</li>
<li>方案 ②：docker 守护进程启动的时候，会默认赋予名字为 docker 的用户组读写 Unix socket 的权限，因此只要创建 docker 用户组，并将当前用户加入到 docker 用户组中，那么当前用户就有权限访问 Unix socket 了，进而也就可以执行 docker 相关命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加docker用户组</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment">#将登陆用户加入到docker用户组中  sudo gpasswd -a $USER docker</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a su docker</span><br><span class="line"><span class="comment">#更新用户组</span></span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>

<p>此处使用方案 ② 来解决问题，下图中可以看到 <code>docker version</code> 指令已经可以看到能给显示出 Docker 引擎的信息了。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318225940978.png"></p>
<h3 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h3><p>会安装就要会卸载，该部分就不做演示了，刚安装就卸载怪麻烦的，卸载 Docker 主要为以下几步：</p>
<blockquote>
<p>关闭服务：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>yum</code> 卸载 Docker 引擎：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除镜像、容器、卷、自定义配置等文件：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="运行-HelloWorld-测试"><a href="#运行-HelloWorld-测试" class="headerlink" title="运行 HelloWorld 测试"></a>运行 HelloWorld 测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318231133329.png"></p>
<h3 id="Docker-下载加速"><a href="#Docker-下载加速" class="headerlink" title="Docker 下载加速"></a>Docker 下载加速</h3><blockquote>
<p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，我们此处使用阿里云的镜像加速器，若考虑使用其他的云服务商家，可以参考以下链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker 镜像加速</a></p>
</blockquote>
<p>访问该网址：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务 (aliyun.com)</a>，登入阿里云，即可看到以下界面</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320012654699.png"></p>
<p>没啥好啰嗦的，按照文档来就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;&#123;此地址是上方复制的地址&#125;&quot;</span>]</span><br><span class="line">&#125; EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="启动类命令"><a href="#启动类命令" class="headerlink" title="启动类命令"></a>启动类命令</h3><blockquote>
<p>启动 docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止 Docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启 Docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看状态：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置开机自启：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例实操</p>
</blockquote>
<p>我们在停止 docker 发现给出了一个警告，警告的大概意思为虽然 docker 服务停掉了，但是他仍然可以被 <code>docker.socket</code> 服务唤醒。也就是说只要 <code>docker.socket</code> 只要没有停止，只要输入 docker 指令都会得到响应，不得不说很银杏</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320010659092.png"></p>
<h3 id="帮助类命令"><a href="#帮助类命令" class="headerlink" title="帮助类命令"></a>帮助类命令</h3><blockquote>
<p>查看 Docker 版本：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 Docker 概要信息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 Docker 总体帮助文档：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 docker 具体命令帮助文档：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker 具体命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="列出本地主机上的镜像"><a href="#列出本地主机上的镜像" class="headerlink" title="列出本地主机上的镜像"></a>列出本地主机上的镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326214342362.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>-a</code>：列出所有镜像（含历史镜像）</li>
<li><code>-q</code>：只显示镜像 ID</li>
<li><code>-f</code>：过滤</li>
</ul>
<p><strong>结果参数:</strong></p>
<ul>
<li><code>REPOSITORY</code>：表示镜像的仓库源</li>
<li><code>TAG</code>：镜像的标签（版本号）</li>
<li><code>IMAGE ID</code>：镜像 ID</li>
<li><code>CREATED</code>：镜像创建时间</li>
<li><code>SIZE</code>：镜像大小</li>
</ul>
<blockquote>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
</blockquote>
<h4 id="在远程仓库中搜索镜像"><a href="#在远程仓库中搜索镜像" class="headerlink" title="在远程仓库中搜索镜像"></a>在远程仓库中搜索镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326215407409.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>-f</code>：过滤</li>
<li><code>--limit 数量</code>：只展示前几项</li>
</ul>
<p><strong>结果参数：</strong></p>
<ul>
<li><code>NAME</code>:  镜像仓库源的名称</li>
<li><code>DESCRIPTION</code>:  镜像的描述</li>
<li><code>OFFICIAL</code>:  是否 docker 官方发布</li>
<li><code>stars</code>:  类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li><code>AUTOMATED</code>:  自动构建</li>
</ul>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称[:tag]</span><br></pre></td></tr></table></figure>

<p>不加 tag 时，默认下载最新的镜像（即 tag 为 <code>latest</code>）。镜像下有多少 tag 需要去 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub Container Image Library </a> 查询</p>
<blockquote>
<p>案例实操：</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326221107956.png"></p>
<h4 id="查看镜像-容器-数据卷所占的空间"><a href="#查看镜像-容器-数据卷所占的空间" class="headerlink" title="查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326222046176.png"></p>
<p><strong>结果参数：</strong></p>
<ul>
<li><code>Images</code>：总共有多少镜像</li>
<li><code>Containers</code>：运行了多少个实例</li>
<li>TODO 剩下两个待补充</li>
</ul>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>删除单个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名称/ID</span><br></pre></td></tr></table></figure>

<p>删除多个镜像，可以使用空格分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br></pre></td></tr></table></figure>

<p>删除全部镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi  -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>-f：强制删除所有镜像，包含运行中的。</li>
</ul>
<blockquote>
<p>案例实操：</p>
</blockquote>
<p>由于功能并不复杂，仅仅演示删除单个的即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326221010366.png"></p>
<h4 id="查询镜像版本号"><a href="#查询镜像版本号" class="headerlink" title="查询镜像版本号"></a>查询镜像版本号</h4><blockquote>
<p>登入 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a> 网站，搜索希望查找的镜像，需要一点点神秘力量</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221420629.png"></p>
<blockquote>
<p>点击查看详情</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221525871.png"></p>
<blockquote>
<p>点击查看版本号</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221628788.png"></p>
<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>仓库名、标签都是 <code>&lt;none&gt;</code> 的镜像，俗称虚悬镜像（dangling image）。docker 再进行构建失败的时候可能出现。</p>
<h3 id="容器命令-基础"><a href="#容器命令-基础" class="headerlink" title="容器命令 (基础)"></a>容器命令 (基础)</h3><blockquote>
<p>执行容器命令的前提是已经有了该容器的镜像。</p>
</blockquote>
<h4 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建 + 启动容器"></a>新建 + 启动容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [选项] IMAGE [命令] [参数...]</span><br></pre></td></tr></table></figure>

<p><strong>常用的参数：</strong></p>
<ul>
<li><code>--name</code>：为容器指定一个名称</li>
<li><code>-d</code>：后台运行容器并返回容器 ID，也即启动守护式容器</li>
<li><code>-i</code>：以交互模式（interactive）运行容器，通常与 <code>-t</code> 同时使用</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与 <code>-i</code> 同时使用。也即启动交互式容器（前台有伪终端，等待交互）</li>
<li><code>-e</code>：为容器添加环境变量</li>
<li><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口（不太常用）</li>
<li><code>-p</code>：指定端口映射（常用）</li>
</ul>
<p><strong><code>-p</code> 指定端口映射的几种不同形式：</strong></p>
<ul>
<li><code>-p hostPort:containerPort</code>：端口映射，例如 <code>-p 8080:80</code></li>
<li><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></li>
<li><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></li>
<li><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如 <code>-p 8080:80 -p 8888:3306</code></li>
</ul>
<h5 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h5><p>所谓启动交互式容器，简单点理解来说就是启动容器后，给你弹出一个输入指令的界面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -i 交互模式</span></span><br><span class="line"><span class="comment"># -t 分配一个伪输入终端tty</span></span><br><span class="line"><span class="comment"># ubuntu 镜像名称</span></span><br><span class="line"><span class="comment"># /bin/bash（或者bash） shell交互的接口, 此参数也可以不写，默认bash</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329222019959.png"></p>
<h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的后台运行模式。下面我们分别以守护式进程的方式启动 ubuntu 和 reids。我们可以发现 ubuntu 的启动其实是有问题的，没有启动起来, 具体的原因参考下文中的 <strong>Q&amp;A</strong>部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 代表容器以守护式方式启动</span></span><br><span class="line">docker run -d ubuntu</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329224244064.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 代表容器以守护式方式启动</span></span><br><span class="line"> docker run -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329230017821.png"></p>
<p><strong>Q&amp;A：</strong></p>
<blockquote>
<p><strong>Q：</strong> 我们以交互式容器的方式启动 ubuntu，系统明明响应了服务已启动，通过 <code>docker ps -a</code> 查看所有容器发现，启动的容器已经退出了，这是为什么呢???</p>
</blockquote>
<p><strong>A：</strong> Docker 容器后台运行,就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行 top，tail），就是会自动退出的。</p>
<p>上面那句话讲起来可能有点抽象，下图中是我们执行 <code>docker run -it ubuntu /bin/bash</code> 启动起来的 ubuntu 容器，我们通过 <code>ps -ef</code> 查看系统当前所有进程发现仅有两个进程再执行，一个是咱们的 bash 交互接口，一个是 ps 进程查询。也就是说，守护式启动 ubuntu 时，系统内根本就没有进程在执行，docker 就会认为系统无事可做，所以就退出了。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329225036381.png"></p>
<h4 id="列出当前容器"><a href="#列出当前容器" class="headerlink" title="列出当前容器"></a>列出当前容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326231447166.png"></p>
<p><strong>常用参数：</strong></p>
<ul>
<li><code>-a</code>：列出当前所有正在运行的容器 + 历史上运行过的容器</li>
<li><code>-l</code>：显示最近创建的容器</li>
<li><code>-n</code>：显示最近 n 个创建的容器</li>
<li><code>-q</code>：静默模式，只显示容器编号</li>
</ul>
<p><strong>结果解析：</strong></p>
<ul>
<li><code>CONTAINER ID</code>：运行容器的 ID</li>
<li><code>IMAGE</code>：使用的镜像</li>
<li><code>COMMAND</code>：执行的命令，<code>bash</code> 和 <code>/bin/bash</code> 居多，后面可能还会补充</li>
<li><code>CREATED</code>：创建时间</li>
<li><code>STATUS</code>：当前状态</li>
<li><code>PORTS</code>：映射端口 提供 <code>-P</code> 和 <code>-p</code> 指定</li>
<li><code>NAMES</code>：当前容器的名称，可以通过 <code>--name &#123;希望叫的名字&#125;</code> 来指定名称，不然就会随机分配。</li>
</ul>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>退出容器其实是指的退出交互式容器的交互界面，通常有以下两种退出方式：① 交互界面输入 <code>exit</code> 指令, 退出后容器会停止; ② 输入 <code>ctrl</code> + <code>P</code> + <code>Q</code> ，退出后容器不会停止。</p>
<blockquote>
<p>案例演示：</p>
</blockquote>
<p>首先查看所有容器，交代出当前系统无容器在运行。交互式启动一个 ubuntu 容器，exit 退出，发现容器名为 brave_thompson 的容器使用的是 ubuntu 镜像，但是处于停止状态。再交互式启动一个 ubuntu 容器，此时输入快捷键 <code>Ctrl</code> + <code>P</code> +<code>Q</code> 退出，我们通过查看所有容器状态，发现容器名为 epic_ptolemy 的容器正在进行。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329231754840.png"></p>
<h4 id="启动已经停止的容器"><a href="#启动已经停止的容器" class="headerlink" title="启动已经停止的容器"></a>启动已经停止的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><blockquote>
<p>删除已经停止的容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>强制删除未停止的容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除全部容器 (叼毛高危操作，不学也罢)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line">docker ps -a -q | xargs docker <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>

<h4 id="设置容器自启动"><a href="#设置容器自启动" class="headerlink" title="设置容器自启动"></a>设置容器自启动</h4><blockquote>
<p>如果我们希望 docker 服务启动，就立刻启动某个容器，可以采取以下两种方案：</p>
</blockquote>
<p><strong>方案 1：</strong> 创建容器时设置 <code>--restart=always</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --name 设置容器名 使用的镜像</span><br><span class="line">（上面命令  --name后面两个参数根据实际情况自行修改）</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 容器的重启策略如下：</span></span><br><span class="line"> --restart具体参数值详细信息：</span><br><span class="line">       no　　　　　　　 // 默认策略,容器退出时不重启容器；</span><br><span class="line">       on-failure　　  // 在容器非正常退出时（退出状态非0）才重新启动容器；</span><br><span class="line">       on-failure:3    // 在容器非正常退出时重启容器，最多重启3次；</span><br><span class="line">       always　　　　  // 无论退出状态是如何，都重启容器；</span><br><span class="line">       unless-stopped  // 在容器退出时总是重启容器，但是不考虑在 Docker 守护进程启动时就已经停止了的容器。</span><br></pre></td></tr></table></figure>

<p><strong>方案 2：</strong> 容器已经创建的情况下，更新 <code>--restart=always</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart=always 容器ID(或者容器名)</span><br></pre></td></tr></table></figure>

<h3 id="容器命令-重要"><a href="#容器命令-重要" class="headerlink" title="容器命令 (重要)"></a>容器命令 (重要)</h3><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="进入正在进行的容器"><a href="#进入正在进行的容器" class="headerlink" title="进入正在进行的容器"></a>进入正在进行的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器ID bashShell</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<p>以上两台命令均能重新进入容器内部，与之交互，区别在于：</p>
<ul>
<li><code>docker exec -it 容器ID bashShell</code> 命令进入的终端输入 <code>exit</code> 退出后，容器不会停止，原因是启动了新的进程 <strong>（推荐使用）</strong></li>
<li><code>docker attach 容器ID</code> 命令进入的容器内部，输入 <code>exit</code> 退出后，容器停止，并没有启动新的进程</li>
</ul>
<blockquote>
<p>案例演示</p>
</blockquote>
<p><strong>ubuntu 案例</strong></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403215810933.png"></p>
<p><strong>redis 案例</strong></p>
<p>🔍 疑问点：此处的 <code>redis-cli</code> 也输入 shell 接口吗?</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403221135498.png"></p>
<blockquote>
<p>总结：一般用 -d 后台启动的程序，再用 exec 进入对应容器实例</p>
</blockquote>
<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><p>容器内文件拷贝到宿主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p>宿主机文件拷贝到容器中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p>第一步：创建并查看 hosttodocker.txt 文件；第二步执行对应的指令，演示中就是有写错指令导致拷贝失败的演示；第三步：拷贝成功后查看复制的文件</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403225756391.png"></p>
<h4 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h4><p><code>export</code>：导出容器的内容流作为一个 tar 归档文件（对应 <code>import</code> 命令）；</p>
<p><code>import</code>：从 tar 包中的内容创建一个新的文件系统再导入为镜像（对应 <code>export</code> 命令）；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出 操作对象是容器</span></span><br><span class="line">docker <span class="built_in">export</span> 容器ID &gt; tar文件名</span><br><span class="line">docker <span class="built_in">export</span> aed61408780b &gt; myubuntu.tar</span><br><span class="line"><span class="comment"># 导入 cat tar文件的作用是将结果集通过管道符以流的形式传给下一个指令</span></span><br><span class="line"><span class="built_in">cat</span> tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p><strong>导出 ubuntu 容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> aed61408780b &gt; myubuntu.tar</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403231552658.png"></p>
<p><strong>删除当前 ubuntu 容器及镜像</strong></p>
<p>具体删除指令不再展示了，废话已经够多了</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403231700300.png"></p>
<p><strong>导入之前的 tar 文件作为镜像文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于之前是在/tmp路径下执行的导出，所以tar文件默认导出到了/tmp路径下</span></span><br><span class="line"><span class="built_in">cat</span> /tmp/myubuntu.tar | docker import - zhanglei/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p>导入完成后，我们可以发现，之前用于测试 <code>docker cp</code> 命令时的文件也被还原了。由此可以断定，导出的容器包含了当前容器状态下的所有内容。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403232358029.png"></p>
<h3 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h3><h4 id="所有命令示意图"><a href="#所有命令示意图" class="headerlink" title="所有命令示意图"></a>所有命令示意图</h4><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403232643173.png"></p>
<h4 id="常用命令表格及中文解释"><a href="#常用命令表格及中文解释" class="headerlink" title="常用命令表格及中文解释"></a>常用命令表格及中文解释</h4><table>
<thead>
<tr>
<th>命令</th>
<th>全称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>attach</td>
<td>Attach to a running container</td>
<td>当前 shell 下 attach 连接指定运行镜像</td>
</tr>
<tr>
<td>build</td>
<td>Build an image from a Dockerfile</td>
<td>通过 Dockerfile 定制镜像</td>
</tr>
<tr>
<td>commit</td>
<td>Create a new image from a container changes</td>
<td>提交当前容器为新的镜像</td>
</tr>
<tr>
<td>cp</td>
<td>Copy files&#x2F;folders from the containers filesystem to the host path</td>
<td>从容器中拷贝指定文件或者目录到宿主机中</td>
</tr>
<tr>
<td>create</td>
<td>Create a new container</td>
<td>创建一个新的容器，同 run，但不启动容器</td>
</tr>
<tr>
<td>diff</td>
<td>Inspect changes on a container’s filesystem</td>
<td>查看 docker 容器变化</td>
</tr>
<tr>
<td>events</td>
<td>Get real time events from the server</td>
<td>从 docker 服务获取容器实时事件</td>
</tr>
<tr>
<td>exec</td>
<td>Run a command in an existing container</td>
<td>在已存在的容器上运行命令</td>
</tr>
<tr>
<td>export</td>
<td>Stream the contents of a container as a tar archive</td>
<td>导出容器的内容流作为一个 tar 归档文件<em>对应 import</em></td>
</tr>
<tr>
<td>history</td>
<td>Show the history of an image</td>
<td>展示一个镜像形成历史</td>
</tr>
<tr>
<td>images</td>
<td>List images</td>
<td>列出系统当前镜像</td>
</tr>
<tr>
<td>import</td>
<td>Create a new filesystem image from the contents of a tarball</td>
<td>从 tar 包中的内容创建一个新的文件系统映像<em>对应 export</em></td>
</tr>
<tr>
<td>info</td>
<td>Display system-wide information</td>
<td>显示系统相关信息</td>
</tr>
<tr>
<td>inspect</td>
<td>Return low-level information on a container</td>
<td>查看容器详细信息</td>
</tr>
<tr>
<td>kill</td>
<td>Kill a running container</td>
<td>kill 指定 docker 容器</td>
</tr>
<tr>
<td>load</td>
<td>Load an image from a tar archive</td>
<td>从一个 tar 包中加载一个镜像 [对应 save]</td>
</tr>
<tr>
<td>login</td>
<td>Register or Login to the docker registry server</td>
<td>注册或者登陆一个 docker 源服务器</td>
</tr>
<tr>
<td>logout</td>
<td>Log out from a Docker registry server</td>
<td>从当前 Docker registry 退出</td>
</tr>
<tr>
<td>logs</td>
<td>Fetch the logs of a container</td>
<td>输出当前容器日志信息</td>
</tr>
<tr>
<td>port</td>
<td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td>
<td>查看映射端口对应的容器内部源端口</td>
</tr>
<tr>
<td>pause</td>
<td>Pause all processes within a container</td>
<td>暂停容器</td>
</tr>
<tr>
<td>ps</td>
<td>List containers</td>
<td>列出容器列表</td>
</tr>
<tr>
<td>pull</td>
<td>Pull an image or a repository from the docker registry server</td>
<td>从 docker 镜像源服务器拉取指定镜像或者库镜像</td>
</tr>
<tr>
<td>push</td>
<td>Push an image or a repository to the docker registry server</td>
<td>推送指定镜像或者库镜像至 docker 源服务器</td>
</tr>
<tr>
<td>restart</td>
<td>Restart a running container</td>
<td>重启运行的容器</td>
</tr>
<tr>
<td>rm</td>
<td>Remove one or more containers</td>
<td>移除一个或者多个容器</td>
</tr>
<tr>
<td>rmi</td>
<td>Remove one or more images</td>
<td>移除一个或多个镜像 无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除</td>
</tr>
<tr>
<td>run</td>
<td>Run a command in a new container</td>
<td>创建一个新的容器并运行一个命令</td>
</tr>
<tr>
<td>save</td>
<td>Save an image to a tar archive</td>
<td>保存一个镜像为一个 tar 包<strong>对应 load</strong></td>
</tr>
<tr>
<td>search</td>
<td>Search for an image on the Docker Hub</td>
<td>在 docker hub 中搜索镜像</td>
</tr>
<tr>
<td>start</td>
<td>Start a stopped containers</td>
<td>启动容器</td>
</tr>
<tr>
<td>stop</td>
<td>Stop a running containers</td>
<td>停止容器</td>
</tr>
<tr>
<td>tag</td>
<td>Tag an image into a repository</td>
<td>给源中镜像打标签</td>
</tr>
<tr>
<td>top</td>
<td>Lookup the running processes of a container</td>
<td>查看容器中运行的进程信息</td>
</tr>
<tr>
<td>unpause</td>
<td>Unpause a paused container</td>
<td>取消暂停容器<br></td>
</tr>
<tr>
<td>version</td>
<td>Show the docker version information</td>
<td>查看 docker 版本号</td>
</tr>
<tr>
<td>wait</td>
<td>Block until a container stops, then print its exit code</td>
<td>截取容器停止时的退出状态值</td>
</tr>
</tbody></table>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p><strong>参考资料：</strong><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1078131#slide-0">【云原生 Docker 系列第七篇】浅谈镜像的分层原理（几位？“两位”）-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是 image 镜像文件</p>
<h3 id="Docker-镜像的加载原理"><a href="#Docker-镜像的加载原理" class="headerlink" title="Docker 镜像的加载原理"></a>Docker 镜像的加载原理</h3><h4 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h4><blockquote>
<p>Docker 中的文件存储驱动叫做 storage driver。Docker 最早支持的 stotage driver 是 AUFS，它实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS。</p>
</blockquote>
<p>联合文件系统（UnionFS）：Union 文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。</p>
<p>Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行集成，基于基础镜像可以制作具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p>后来出现的 docker 版本中，除了 AUFS，还支持 OverlayFS、Btrfs、Device Mapper、VFS、ZFS 等 storage driver。</p>
<p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p>
<h4 id="bootfs-boot-File-system"><a href="#bootfs-boot-File-system" class="headerlink" title="bootfs(boot File system)"></a>bootfs(boot File system)</h4><p>bootfs（boot file system） 主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文件系统。</p>
<p>在 Docker 镜像的最底层是引导文件系统 bootfs。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p>
<h4 id="rootfs（root-File-system）"><a href="#rootfs（root-File-system）" class="headerlink" title="rootfs（root File system）"></a>rootfs（root File system）</h4><p>在 bootfs 之上，包含的就是典型 Linux 系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu、CentOS 等。</p>
<h4 id="Docker-镜像底层层次"><a href="#Docker-镜像底层层次" class="headerlink" title="Docker 镜像底层层次"></a>Docker 镜像底层层次</h4><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224108257.png"></p>
<p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用 Host 的 Kernel，自己只需要提供 rootfs 就可以。所以，对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别，不同的发行版可以共用 bootfs。</p>
<p>有差别的 rootfs：</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224120068.png"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h3 id="容器层与镜像层"><a href="#容器层与镜像层" class="headerlink" title="容器层与镜像层"></a>容器层与镜像层</h3><p>当容器启动时，一个新的<strong>可写层</strong>将被加载到镜像的顶部，这一层通常被称为 <code>容器层</code>，容器层之下的都叫 <code>镜像层</code>。所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406223513304.png"></p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote>
<p>docker commit -m&#x3D;” 提交的描述信息 “ -a&#x3D;” 作者 “ 容器 ID 要创建的目标镜像名:{标签名}</p>
</blockquote>
<h3 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a>实操案例</h3><p>目标：创建一个带有 vim 的 ubuntu 镜像</p>
<blockquote>
<p>拉取最新的 ubuntu 镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224847182.png"></p>
<blockquote>
<p>运行一个 ubuntu 实例，并进入终端界面</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406225002838.png"></p>
<blockquote>
<p>使用 vim 指令，发现指令不存在</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406225051600.png"></p>
<blockquote>
<p>安装 vim 指令</p>
</blockquote>
<p>执行过程没啥意思，就不截图了，命令附上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Vim</span></span><br><span class="line">apt-get -y install vim</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;带有vim的ubuntu&quot;</span> -a=<span class="string">&quot;zhanglei&quot;</span> ebd71331125f withvimubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233516020.png"></p>
<blockquote>
<p>查看已经生成的镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233621859.png"></p>
<blockquote>
<p>运行新构建的镜像，并查看对应的命令</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233909308.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Docker 中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似 Java 继承于一个 Base 基础类，自己再按需扩展。新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406234058685.png"></p>
<h2 id="镜像发布阿里云-个人版切勿用于生产环境"><a href="#镜像发布阿里云-个人版切勿用于生产环境" class="headerlink" title="镜像发布阿里云 (个人版切勿用于生产环境)"></a>镜像发布阿里云 (个人版切勿用于生产环境)</h2><blockquote>
<p>本章节比较偏实操，镜像的生成方法参考上一章节 <code>Dokcer镜像-&gt;怎么用</code> 章节，下面的案例展示以推送上一步生成的 withvimubuntu 镜像目标</p>
</blockquote>
<h3 id="登录阿里云，找到容器镜像服务"><a href="#登录阿里云，找到容器镜像服务" class="headerlink" title="登录阿里云，找到容器镜像服务"></a>登录阿里云，找到容器镜像服务</h3><p>点击进入 <a target="_blank" rel="noopener" href="https://account.aliyun.com/login/login.htm?oauth_callback=https://account.console.aliyun.com/v2/#/home/person">阿里云登录页 (aliyun.com)</a>，找到容器镜像服务</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001127056.png"></p>
<h3 id="能白嫖就不要缴费"><a href="#能白嫖就不要缴费" class="headerlink" title="能白嫖就不要缴费"></a>能白嫖就不要缴费</h3><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001223121.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001256358.png"></p>
<h3 id="设置访问凭证"><a href="#设置访问凭证" class="headerlink" title="设置访问凭证"></a>设置访问凭证</h3><p>首次进入，会强制你设置，不设置无法使用其镜像服务，要想更改访问凭证，参考下图即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001609532.png"></p>
<h3 id="设置命名空间，创建仓库"><a href="#设置命名空间，创建仓库" class="headerlink" title="设置命名空间，创建仓库"></a>设置命名空间，创建仓库</h3><p>注意创建顺序，阿里的防呆设计做的挺好的，看一下基本就了解了。创建仓库时，代码源选择本地仓库。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001951303.png"></p>
<h3 id="查看操作指南"><a href="#查看操作指南" class="headerlink" title="查看操作指南"></a>查看操作指南</h3><p>进入仓库的管理页面，查看对应的操作指南。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407002056656.png"></p>
<h3 id="实操上手"><a href="#实操上手" class="headerlink" title="实操上手"></a>实操上手</h3><p>密码其实就是之前设置的访问凭证，其他的就按照教程来就行</p>
<blockquote>
<p>推送镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=啊啊阿磊啊 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="comment"># docker tag [镜像号] registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本号]</span></span><br><span class="line">docker tag 07f05e531ec6 registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br><span class="line"><span class="comment"># docker push registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本号]</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407003606627.png"></p>
<blockquote>
<p>删除本地的镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004058887.png"></p>
<blockquote>
<p>从阿里云拉取镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本及版本号]</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004419457.png"></p>
<blockquote>
<p>运行镜像，并查看 vim 版本</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004544761.png"></p>
<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库</p>
<h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><ol>
<li>官方 Docker Hub 地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2%E4%BA%86%E4%B8%94%E5%87%86%E5%A4%87%E8%A2%AB%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%96%E4%BB%A3%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%A4%AA%E4%B8%BB%E6%B5%81%E3%80%82">https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</a></li>
<li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</li>
</ol>
<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote>
<p><strong>目标：</strong> 搭建本地私有仓库，将本地镜像推送到私有库</p>
</blockquote>
<h4 id="下载-Docker-Registry-镜像"><a href="#下载-Docker-Registry-镜像" class="headerlink" title="下载 Docker Registry 镜像"></a>下载 Docker Registry 镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker registry</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407073209069.png"></p>
<h4 id="运行对应的容器"><a href="#运行对应的容器" class="headerlink" title="运行对应的容器"></a>运行对应的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /app/myregistry/:/tmp/registry --privileged=<span class="literal">true</span> registry</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407073648139.png"></p>
<h4 id="创建带有安装-Ifconfig-命令的-Ubuntu-镜像"><a href="#创建带有安装-Ifconfig-命令的-Ubuntu-镜像" class="headerlink" title="创建带有安装 Ifconfig 命令的 Ubuntu 镜像"></a>创建带有安装 Ifconfig 命令的 Ubuntu 镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载ubuntu镜像</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -it  -name=withnettools ubuntu bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载nettools工具</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成镜像</span></span><br><span class="line">docker commit -m=<span class="string">&quot;带有ipconfig的镜像&quot;</span> -a=<span class="string">&quot;zhanglei&quot;</span> 473e414d8db9 myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p>生成镜像时有点奇怪，一开始预备的镜像名为 <code>withvnettoolsubuntu</code> ，一直显示格式错误……，不知道为什么</p>
<h4 id="查看私服库镜像"><a href="#查看私服库镜像" class="headerlink" title="查看私服库镜像"></a>查看私服库镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -XGET 私服IP端口/v2/_catalog</span></span><br><span class="line">curl -XGET http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407080125965.png"></p>
<h4 id="修改镜像的-Tag"><a href="#修改镜像的-Tag" class="headerlink" title="修改镜像的 Tag"></a>修改镜像的 Tag</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker   tag   镜像:Tag   Host:Port/Repository:Tag</span></span><br><span class="line">docker tag myubuntu:1.0.1 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407080623663.png"></p>
<h4 id="修改配置，使私库支持-Http-协议"><a href="#修改配置，使私库支持-Http-协议" class="headerlink" title="修改配置，使私库支持 Http 协议"></a>修改配置，使私库支持 Http 协议</h4><blockquote>
<p>docker 默认不允许 http 方式推送镜像，通过配置选项来取消这个限制。  修改完后如果不生效，建议重启 docker</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件 (需要拥有写入权限)</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081139388.png"></p>
<h4 id="推送镜像到私库"><a href="#推送镜像到私库" class="headerlink" title="推送镜像到私库"></a>推送镜像到私库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker push IP:端口/目标镜像名称:版本号</span></span><br><span class="line">docker push 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081426537.png"></p>
<p>查看此时的私服库镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081732590.png"></p>
<h4 id="删除本地镜像，从私库拉入"><a href="#删除本地镜像，从私库拉入" class="headerlink" title="删除本地镜像，从私库拉入"></a>删除本地镜像，从私库拉入</h4><blockquote>
<p>删除指令不做重复</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull 私库IP:端口/镜像名称:版本号</span></span><br><span class="line">docker pull 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407082244769.png"></p>
<p>运行镜像实例，并查看 ip</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 127.0.0.1:5000/myubuntu:1.0.1 bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407082457407.png"></p>
<h2 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以想象一下主机的一块磁盘，当做 U 盘插入 docker 的运行实例中。</p>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p><strong>为了能保存数据在 docker 中我们使用卷</strong>。将运行的环境打包镜像，run 后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接实时生效 (因为是同一块 U 盘)</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="宿主-Vs-容器之间映射添加容器卷"><a href="#宿主-Vs-容器之间映射添加容器卷" class="headerlink" title="宿主 Vs 容器之间映射添加容器卷"></a>宿主 Vs 容器之间映射添加容器卷</h4><blockquote>
<p>宿主机下的映射路径如果不存在，则会自动创建</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /app/myubuntu/tmp:/tmp ubuntu</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看运行情况</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker inspect 容器ID</span></span><br><span class="line">docker inspect 952c46cfdf8c</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407084858447.png"></p>
<blockquote>
<p>测试虚拟机与主机数据共享</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407085145676.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407085352209.png"></p>
<h4 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h4><blockquote>
<p>读写 (默认)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</span><br><span class="line"><span class="comment"># 或者 什么也不写</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只读 (Read Only)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>

<h4 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -it --privileged=true --volumes-from 父容器ID --name=容器名称 镜像:镜像版本</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> --volumes-from jovial_mclaren --name=myubuntu2 ubuntu</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407090334433.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407090311022.png"></p>
<h2 id="Docker-常规安装"><a href="#Docker-常规安装" class="headerlink" title="Docker 常规安装"></a>Docker 常规安装</h2><ol>
<li>搜索镜像</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像：启动镜像时，进行服务端口映射，容器卷实例持久化，环境变量的注入</li>
<li>停止容器</li>
<li>移除容器</li>
</ol>
<h3 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h3><h4 id="Docker-Hub-上面查找-Tomcat-镜像"><a href="#Docker-Hub-上面查找-Tomcat-镜像" class="headerlink" title="Docker Hub 上面查找 Tomcat 镜像"></a>Docker Hub 上面查找 Tomcat 镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询前5个满够了</span></span><br><span class="line"> docker search tomcat --<span class="built_in">limit</span> 5</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407213929228.png"></p>
<h4 id="从-Docker-Hub-上拉取-Tomcat-镜像到本地"><a href="#从-Docker-Hub-上拉取-Tomcat-镜像到本地" class="headerlink" title="从 Docker Hub 上拉取 Tomcat 镜像到本地"></a>从 Docker Hub 上拉取 Tomcat 镜像到本地</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407213959362.png"></p>
<h4 id="Docker-Images-查看是否有拉取到的-Tomcat"><a href="#Docker-Images-查看是否有拉取到的-Tomcat" class="headerlink" title="Docker Images 查看是否有拉取到的 Tomcat"></a>Docker Images 查看是否有拉取到的 Tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images 指定镜像名</span></span><br><span class="line">docker images tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214258844.png"></p>
<h4 id="使用-Tomcat-镜像创建容器实例-也叫运行镜像"><a href="#使用-Tomcat-镜像创建容器实例-也叫运行镜像" class="headerlink" title="使用 Tomcat 镜像创建容器实例 (也叫运行镜像)"></a>使用 Tomcat 镜像创建容器实例 (也叫运行镜像)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214604564.png"></p>
<h4 id="访问首页"><a href="#访问首页" class="headerlink" title="访问首页"></a>访问首页</h4><blockquote>
<p>问题：阿偶，启动失败了，报 404</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214500195.png"></p>
<blockquote>
<p>原因分析：</p>
</blockquote>
<ul>
<li>检查防火墙是否关闭，端口是否放开</li>
<li>新版的 <code>tomcat</code> 默认的 webapps 文件夹是空的，原来的 webapps 文件夹内容放入了 webapps.dist 下了</li>
</ul>
<blockquote>
<p>解决办法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407215913973.png"></p>
<h4 id="免修改版本"><a href="#免修改版本" class="headerlink" title="免修改版本"></a>免修改版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name tomcat8 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407215928883.png"></p>
<h3 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h3><blockquote>
<p>具体的版本需要到 dockerHub 上进行查询，此处按照 8.0.36 做演示</p>
</blockquote>
<h4 id="Docker-Hub-上面查找-Mysql-镜像"><a href="#Docker-Hub-上面查找-Mysql-镜像" class="headerlink" title="Docker Hub 上面查找 Mysql 镜像"></a>Docker Hub 上面查找 Mysql 镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql --<span class="built_in">limit</span> 5</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407225210764.png"></p>
<h4 id="从-Docker-Hub-上-阿里云加速器-拉取-Mysql-镜像到本地"><a href="#从-Docker-Hub-上-阿里云加速器-拉取-Mysql-镜像到本地" class="headerlink" title="从 Docker Hub 上 (阿里云加速器) 拉取 Mysql 镜像到本地"></a>从 Docker Hub 上 (阿里云加速器) 拉取 Mysql 镜像到本地</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker pull mysql:8.0.36</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407224909368.png"></p>
<h4 id="简单版安装"><a href="#简单版安装" class="headerlink" title="简单版安装"></a>简单版安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.36</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入容器，创建数据库</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407231902340.png"></p>
<blockquote>
<p>使用外部工具链接数据库，并插入中文数据</p>
</blockquote>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><blockquote>
<p>8 版本数据库链接数据库时报 <code>Public Key Retrieval is not allowed</code> 异常</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407232301848.png"></p>
<p><strong>解决办法：</strong> 可参考该文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/white0718/article/details/131790493">完美解决：MySQL8 报错：Public Key Retrieval is not allowed-CSDN 博客</a></p>
<p>问题的根本原因还是在于，mysql 8.0 默认使用 caching_sha2_password 身份验证机制，客户端默认不支持新的加密方式</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407232445789.png"></p>
<blockquote>
<p>8.0 版本插入中文数据在 docker 中查询乱码</p>
</blockquote>
<p><strong>问题：</strong> 参照下图，插入一条中文数据，并可在连接工具中正常查看，但是在 docker 容器实例下的控制台无法查看<br><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407233741906.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407233912940.png"></p>
<p><strong>现象原因：</strong> 该问题其实是由于 docker 容器中的系统不支持中文导致的，我们可以发现，docker 容器内部终端中，是无法输入中文的，因此会出现此现象</p>
<blockquote>
<p>5.7 版本插入中文会报异常</p>
</blockquote>
<p><strong>问题：</strong> 参照下图，插入中文会报异常</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407234802583.png"></p>
<p><strong>原因：</strong> mysql5.7 版本，数据库的默认字符集为拉丁文，导致的</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407235054575.png"></p>
<p><strong>解决办法</strong>：修改配置文件，重启 mysql 服务，可以参考实际应用安装</p>
<h4 id="实际应用安装"><a href="#实际应用安装" class="headerlink" title="实际应用安装"></a>实际应用安装</h4><p>实际应用安装，以 5.7 为例，-v 的数据，日志，配置所对应的容器卷映射按照实际配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 3306:3306 \</span></span><br><span class="line"><span class="comment">#           --privileged=true \</span></span><br><span class="line"><span class="comment">#           -v [主机日志存放路径]:/var/log/mysql \</span></span><br><span class="line"><span class="comment">#           -v [主机数据存放路径]:/var/lib/mysql \</span></span><br><span class="line"><span class="comment">#           -v [主机配置存放路径]:/etc/mysql/conf.d \</span></span><br><span class="line"><span class="comment">#           -e MYSQL_ROOT_PASSWORD=root \</span></span><br><span class="line"><span class="comment">#           --name [服务名] \</span></span><br><span class="line"><span class="comment">#           mysql[:版本号]</span></span><br><span class="line"></span><br><span class="line">docker run -d -p 3306:3306 \</span><br><span class="line">           --privileged=<span class="literal">true</span> \</span><br><span class="line">           -v /app/mysql/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">           --name mysql \</span><br><span class="line">           mysql:5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决中文插入报错问题：</p>
</blockquote>
<p>在 <code>/app/mysql/conf</code> 下新建 <code>my.cnf</code>，通过容器卷同步给 mysql 实例，解决中文乱码问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure>

<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><blockquote>
<p>不写废话，直接上指令</p>
</blockquote>
<h4 id="简单玩具版"><a href="#简单玩具版" class="headerlink" title="简单玩具版"></a>简单玩具版</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<h4 id="实际应用版"><a href="#实际应用版" class="headerlink" title="实际应用版"></a>实际应用版</h4><ol>
<li><p>宿主机创建目录 <code>/app/redis</code></p>
</li>
<li><p>修改配置文件，在 <code>/app/redis</code> 下创建文件 <code>redis.conf</code>，并修改</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开启密码验证（可选）</span><br><span class="line">requirepass 123</span><br><span class="line"></span><br><span class="line"># 允许redis外地连接，需要注释掉绑定的IP</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 关闭保护模式（可选）</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># 注释掉daemonize yes，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 开启redis数据持久化， （可选）</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis --privileged=<span class="literal">true</span> \</span><br><span class="line">           -v /app/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">           -v /app/redis/data:/data \</span><br><span class="line">           redis:6.0.8 \</span><br><span class="line">           redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h3><h4 id="下载镜像并启动容器"><a href="#下载镜像并启动容器" class="headerlink" title="下载镜像并启动容器"></a>下载镜像并启动容器</h4><blockquote>
<p>宝塔需要的端口：8888、888、20、21、80、443 为了方便使用共享主机网络模式 <code>--net=host</code></p>
</blockquote>
<p><strong>参考文章</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1830313">Docker 安装配置宝塔面板-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33420835/article/details/109013202">更改 Docker 的 shm（共享内存）大小_docker 修改 shm 大小-CSDN 博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/freeaihub/p/13197292.html">Docker 网络:host 模式 - freeaihub - 博客园 (cnblogs.com)</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取centos7镜像</span></span><br><span class="line">docker pull centos:centos7</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -itd --name baota --net=host --privileged=<span class="literal">true</span> \</span><br><span class="line">                -v /app/baota/www:/www centos:centos7 /usr/sbin/init</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it baota /bin/bash</span><br><span class="line"><span class="comment"># 执行安装指令</span></span><br><span class="line">yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414125907052.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414134349579.png"></p>
<ul>
<li>外网面板地址: <a target="_blank" rel="noopener" href="http://144.255.7.111:13453/06288b4b">http://144.255.7.111:13453/06288b4b</a></li>
<li>内网面板地址: http:&#x2F;&#x2F;:13453&#x2F;06288b4b</li>
<li>username: rpa5wno8</li>
<li>password: b136dcbb</li>
</ul>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><blockquote>
<p>进入容器内部，执行 <code>bt</code> 命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it baota /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414090247327.png"></p>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>待更新~~~~~~</p>
<h2 id="资源汇总"><a href="#资源汇总" class="headerlink" title="资源汇总"></a>资源汇总</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/tmfl/cloud/naxbau">大佬笔记</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lei-ctyh.github.io">Zhang Lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lei-ctyh.github.io/2024/12/09/archive/Docker%E5%B0%8F%E5%86%8C/">https://lei-ctyh.github.io/2024/12/09/archive/Docker%E5%B0%8F%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lei-ctyh.github.io" target="_blank">知了</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE-activemq/">数据/activemq</a></div><div class="post-share"><div class="social-share" data-image="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/09/archive/ActiveMQ/" title="ActiveMQ"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ActiveMQ</div></div><div class="info-2"><div class="info-item-1">入门概述MQ 种类和对比 MQ 就是消息中间件。MQ 是一种理念，ActiveMQ 是 MQ 的落地产品。不管是哪款消息中间件，都有如下一些技术维度：    MQ 消息的详细比较    各类 MQ 的擅长领域     MQ 种类 变成语言 擅长领域    kafka scala 大数据领域的主流 MQ。   rabbitmq erlang 基于 erlang 语言，不好修改底层，不好查找问题的原因，不建议选用   rocketmq java 适用于大型项目。适用于集群   activemq java 适用于中小型项目   是什么面向消息的中间件（message-oriented middleware）MOM 能够很好的解决以上问题。是指利用高效可靠的消息传递机制与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型在分布式环境下提供应用解耦，弹性伸缩，冗余存储、流量削峰，异步通信，数据同步等功能。 大致的过程是这样的：发送者把消息发送给消息服务器，消息服务器将消息存放在若干队列&#x2F;主题 topic...</div></div></div></a><a class="pagination-related" href="/2024/12/09/archive/Kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" title="Kafka常用命令总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Kafka常用命令总结</div></div><div class="info-2"><div class="info-item-1">主题脚本命令及其参数   参数 描述    –bootstrap-server 连接的 Kafka Broker 主机名称和端口号   –topic 操作的 topic 名称   –create 创建主题   –delete 删除主题   –alter 修改主题   –list 查看所有主题   –describe 查看主题详细描述   –partitions Integer 设置分区数   –replication-factor Integer 设置分区副本   这些参数可以与 kafka-topics.sh（Unix&#x2F;Linux）或 kafka-topics.bat（Windows）命令一起使用，用于管理 Kafka 主题。根据需要，选择使用适当的参数来执行相应的操作。 消费者脚本命令参数：   参数 描述    –bootstrap-server 连接的 Kafka Broker 主机名称和端口号   –topic 消费的 topic 名称   –group-id 消费者所属的消费者组...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhang Lei</div><div class="author-info-description">路漫漫其修远兮，吾将上下而求索</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lei-ctyh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:2468341590@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://www.cnblogs.com/aaalei" target="_blank" title="CnBlog"><i class="fa-solid fa-rss" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">该网站由 lei-ctyh 维护，欢迎访问！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">传统虚拟机和容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">1.3.</span> <span class="toc-text">能干嘛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Docker 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">三个基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">基本架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">运行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Docker"><span class="toc-number">3.</span> <span class="toc-text">安装 Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">先决条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">3.2.</span> <span class="toc-text">卸载旧版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Gcc-%E7%8E%AF%E5%A2%83"><span class="toc-number">3.3.</span> <span class="toc-text">安装 Gcc 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Yum-%E8%B5%84%E6%BA%90%E5%BA%93"><span class="toc-number">3.4.</span> <span class="toc-text">配置 Yum 资源库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Docker-%E5%BC%95%E6%93%8E"><span class="toc-number">3.5.</span> <span class="toc-text">安装 Docker 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Docker-%E5%BC%95%E6%93%8E"><span class="toc-number">3.6.</span> <span class="toc-text">启动 Docker 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90"><span class="toc-number">3.7.</span> <span class="toc-text">配置用户权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD-Docker"><span class="toc-number">3.8.</span> <span class="toc-text">卸载 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-HelloWorld-%E6%B5%8B%E8%AF%95"><span class="toc-number">3.9.</span> <span class="toc-text">运行 HelloWorld 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F"><span class="toc-number">3.10.</span> <span class="toc-text">Docker 下载加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">Docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">启动类命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">帮助类命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">列出本地主机上的镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">在远程仓库中搜索镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%89%80%E5%8D%A0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.4.</span> <span class="toc-text">查看镜像&#x2F;容器&#x2F;数据卷所占的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.5.</span> <span class="toc-text">删除镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%95%9C%E5%83%8F%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">4.3.6.</span> <span class="toc-text">查询镜像版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.7.</span> <span class="toc-text">虚悬镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4-%E5%9F%BA%E7%A1%80"><span class="toc-number">4.4.</span> <span class="toc-text">容器命令 (基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">新建 + 启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">启动交互式容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">启动守护式容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">列出当前容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">退出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.4.</span> <span class="toc-text">启动已经停止的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.5.</span> <span class="toc-text">重启容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.6.</span> <span class="toc-text">停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.7.</span> <span class="toc-text">强制停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.8.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="toc-number">4.4.9.</span> <span class="toc-text">设置容器自启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4-%E9%87%8D%E8%A6%81"><span class="toc-number">4.5.</span> <span class="toc-text">容器命令 (重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">4.5.1.</span> <span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">查看容器内运行的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">4.5.3.</span> <span class="toc-text">查看容器内部细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.4.</span> <span class="toc-text">进入正在进行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A"><span class="toc-number">4.5.5.</span> <span class="toc-text">从容器内拷贝文件到主机上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.6.</span> <span class="toc-text">导入导出容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">常用命令总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%91%BD%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">4.6.1.</span> <span class="toc-text">所有命令示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%A8%E6%A0%BC%E5%8F%8A%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A"><span class="toc-number">4.6.2.</span> <span class="toc-text">常用命令表格及中文解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F"><span class="toc-number">5.</span> <span class="toc-text">Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">5.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">Docker 镜像的加载原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">联合文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bootfs-boot-File-system"><span class="toc-number">5.2.2.</span> <span class="toc-text">bootfs(boot File system)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rootfs%EF%BC%88root-File-system%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">rootfs（root File system）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E5%BA%95%E5%B1%82%E5%B1%82%E6%AC%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">Docker 镜像底层层次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">5.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%82%E4%B8%8E%E9%95%9C%E5%83%8F%E5%B1%82"><span class="toc-number">5.4.</span> <span class="toc-text">容器层与镜像层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">5.6.</span> <span class="toc-text">实操案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E9%98%BF%E9%87%8C%E4%BA%91-%E4%B8%AA%E4%BA%BA%E7%89%88%E5%88%87%E5%8B%BF%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="toc-number">6.</span> <span class="toc-text">镜像发布阿里云 (个人版切勿用于生产环境)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.1.</span> <span class="toc-text">登录阿里云，找到容器镜像服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E7%99%BD%E5%AB%96%E5%B0%B1%E4%B8%8D%E8%A6%81%E7%BC%B4%E8%B4%B9"><span class="toc-number">6.2.</span> <span class="toc-text">能白嫖就不要缴费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81"><span class="toc-number">6.3.</span> <span class="toc-text">设置访问凭证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93"><span class="toc-number">6.4.</span> <span class="toc-text">设置命名空间，创建仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97"><span class="toc-number">6.5.</span> <span class="toc-text">查看操作指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E4%B8%8A%E6%89%8B"><span class="toc-number">6.6.</span> <span class="toc-text">实操上手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Registry"><span class="toc-number">7.</span> <span class="toc-text">Docker Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">解决了什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-1"><span class="toc-number">7.3.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD-Docker-Registry-%E9%95%9C%E5%83%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">下载 Docker Registry 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">7.3.2.</span> <span class="toc-text">运行对应的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89%E5%AE%89%E8%A3%85-Ifconfig-%E5%91%BD%E4%BB%A4%E7%9A%84-Ubuntu-%E9%95%9C%E5%83%8F"><span class="toc-number">7.3.3.</span> <span class="toc-text">创建带有安装 Ifconfig 命令的 Ubuntu 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A7%81%E6%9C%8D%E5%BA%93%E9%95%9C%E5%83%8F"><span class="toc-number">7.3.4.</span> <span class="toc-text">查看私服库镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E7%9A%84-Tag"><span class="toc-number">7.3.5.</span> <span class="toc-text">修改镜像的 Tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%BF%E7%A7%81%E5%BA%93%E6%94%AF%E6%8C%81-Http-%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.3.6.</span> <span class="toc-text">修改配置，使私库支持 Http 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F%E5%88%B0%E7%A7%81%E5%BA%93"><span class="toc-number">7.3.7.</span> <span class="toc-text">推送镜像到私库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%EF%BC%8C%E4%BB%8E%E7%A7%81%E5%BA%93%E6%8B%89%E5%85%A5"><span class="toc-number">7.3.8.</span> <span class="toc-text">删除本地镜像，从私库拉入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">8.</span> <span class="toc-text">Docker 容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">8.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">8.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-2"><span class="toc-number">8.3.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB-Vs-%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="toc-number">8.3.1.</span> <span class="toc-text">宿主 Vs 容器之间映射添加容器卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E8%AF%B4%E6%98%8E"><span class="toc-number">8.3.2.</span> <span class="toc-text">读写规则映射添加说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">8.3.3.</span> <span class="toc-text">卷的继承和共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%B8%B8%E8%A7%84%E5%AE%89%E8%A3%85"><span class="toc-number">9.</span> <span class="toc-text">Docker 常规安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Tomcat"><span class="toc-number">9.1.</span> <span class="toc-text">安装 Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Hub-%E4%B8%8A%E9%9D%A2%E6%9F%A5%E6%89%BE-Tomcat-%E9%95%9C%E5%83%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">Docker Hub 上面查找 Tomcat 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-Docker-Hub-%E4%B8%8A%E6%8B%89%E5%8F%96-Tomcat-%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">从 Docker Hub 上拉取 Tomcat 镜像到本地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Images-%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%8B%89%E5%8F%96%E5%88%B0%E7%9A%84-Tomcat"><span class="toc-number">9.1.3.</span> <span class="toc-text">Docker Images 查看是否有拉取到的 Tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Tomcat-%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B-%E4%B9%9F%E5%8F%AB%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F"><span class="toc-number">9.1.4.</span> <span class="toc-text">使用 Tomcat 镜像创建容器实例 (也叫运行镜像)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5"><span class="toc-number">9.1.5.</span> <span class="toc-text">访问首页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8D%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC"><span class="toc-number">9.1.6.</span> <span class="toc-text">免修改版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Mysql"><span class="toc-number">9.2.</span> <span class="toc-text">安装 Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Hub-%E4%B8%8A%E9%9D%A2%E6%9F%A5%E6%89%BE-Mysql-%E9%95%9C%E5%83%8F"><span class="toc-number">9.2.1.</span> <span class="toc-text">Docker Hub 上面查找 Mysql 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-Docker-Hub-%E4%B8%8A-%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F%E5%99%A8-%E6%8B%89%E5%8F%96-Mysql-%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">从 Docker Hub 上 (阿里云加速器) 拉取 Mysql 镜像到本地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88%E5%AE%89%E8%A3%85"><span class="toc-number">9.2.3.</span> <span class="toc-text">简单版安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">9.2.4.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85"><span class="toc-number">9.2.5.</span> <span class="toc-text">实际应用安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Redis"><span class="toc-number">9.3.</span> <span class="toc-text">安装 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%8E%A9%E5%85%B7%E7%89%88"><span class="toc-number">9.3.1.</span> <span class="toc-text">简单玩具版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%89%88"><span class="toc-number">9.3.2.</span> <span class="toc-text">实际应用版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF"><span class="toc-number">9.4.</span> <span class="toc-text">安装宝塔面板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">9.4.1.</span> <span class="toc-text">下载镜像并启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number">9.4.2.</span> <span class="toc-text">修改密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Nginx"><span class="toc-number">9.5.</span> <span class="toc-text">安装 Nginx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB"><span class="toc-number">10.</span> <span class="toc-text">资源汇总</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/01/archive/git%E5%85%A5%E9%97%A8/" title="Git 入门指南：写给完全不懂版本控制的你">Git 入门指南：写给完全不懂版本控制的你</a><time datetime="2025-12-01T16:00:00.000Z" title="发表于 2025-12-02 00:00:00">2025-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/archive/%E8%8B%A5%E4%BE%9D%E7%B3%BB%E7%BB%9F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="若依系统生产环境图片不显示问题解决方案">若依系统生产环境图片不显示问题解决方案</a><time datetime="2025-10-22T01:57:55.000Z" title="发表于 2025-10-22 09:57:55">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/archive/%E5%8D%83%E5%B9%B4%E8%99%AB%EF%BC%9A%E4%B8%80%E5%9C%BA%E8%80%97%E8%B5%84%E5%8D%83%E4%BA%BF%E7%BE%8E%E5%85%83%E3%80%81%E9%99%A9%E4%BA%9B%E6%91%A7%E6%AF%81%E4%B8%96%E7%95%8C%E7%9A%84%E6%95%B0%E5%AD%97%E5%8D%B1%E6%9C%BA/" title="千年虫：一场耗资千亿美元、险些摧毁世界的数字危机">千年虫：一场耗资千亿美元、险些摧毁世界的数字危机</a><time datetime="2025-09-17T08:07:28.000Z" title="发表于 2025-09-17 16:07:28">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/archive/%E9%AB%98%E6%95%88%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%EF%BC%9A%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E4%B8%8E%E6%97%A5%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/" title="高效时间管理核心：待办清单与日程管理的艺术">高效时间管理核心：待办清单与日程管理的艺术</a><time datetime="2025-09-17T02:35:16.000Z" title="发表于 2025-09-17 10:35:16">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/09/archive/Git%20Worktree%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Git Worktree 常用命令">Git Worktree 常用命令</a><time datetime="2025-09-09T10:01:17.000Z" title="发表于 2025-09-09 18:01:17">2025-09-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zhang Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>