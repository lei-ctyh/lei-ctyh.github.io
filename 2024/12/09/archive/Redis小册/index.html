<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis小册 | 知了</title><meta name="author" content="Zhang Lei"><meta name="copyright" content="Zhang Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安装 Redis判断是否安装 GCC 环境 以下命令均可检查是否安装 GCC  123gcc --version# orgcc -v   123whereis gcc# orwhereis g++    如需安装, 执行以下命令即可  1yum -y install gcc-c++   安装 下载 redis, 联网情况下可以 wget 命令直接下载, 此方式默认下载至当前用户的家目录, 也可以下">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis小册">
<meta property="og:url" content="https://lei-ctyh.github.io/2024/12/09/archive/Redis%E5%B0%8F%E5%86%8C/index.html">
<meta property="og:site_name" content="知了">
<meta property="og:description" content="安装 Redis判断是否安装 GCC 环境 以下命令均可检查是否安装 GCC  123gcc --version# orgcc -v   123whereis gcc# orwhereis g++    如需安装, 执行以下命令即可  1yum -y install gcc-c++   安装 下载 redis, 联网情况下可以 wget 命令直接下载, 此方式默认下载至当前用户的家目录, 也可以下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&cs=tinysrgb&w=800">
<meta property="article:published_time" content="2024-12-09T01:59:45.000Z">
<meta property="article:modified_time" content="2024-12-09T02:28:44.000Z">
<meta property="article:author" content="Zhang Lei">
<meta property="article:tag" content="数据&#x2F;redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&cs=tinysrgb&w=800"><link rel="shortcut icon" href="/images/icon/favicon-32x32.png"><link rel="canonical" href="https://lei-ctyh.github.io/2024/12/09/archive/Redis%E5%B0%8F%E5%86%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis小册',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://bing.img.run/uhd.php);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">知了</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis小册</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis小册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T01:59:45.000Z" title="发表于 2024-12-09 09:59:45">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-09T02:28:44.000Z" title="更新于 2024-12-09 10:28:44">2024-12-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h2><h3 id="判断是否安装-GCC-环境"><a href="#判断是否安装-GCC-环境" class="headerlink" title="判断是否安装 GCC 环境"></a>判断是否安装 GCC 环境</h3><blockquote>
<p>以下命令均可检查是否安装 GCC</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132137323.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis gcc</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">whereis g++</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132156616.png"></p>
<blockquote>
<p>如需安装, 执行以下命令即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119093335549.png"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>下载 redis, 联网情况下可以 wget 命令直接下载, 此方式默认下载至当前用户的家目录, 也可以下载好安装包上传至 linux</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-7.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132407697.png"></p>
<blockquote>
<p>&#x2F;opt 目录下解压 redis, 注意文件夹读写权限问题。<a target="_blank" rel="noopener" href="https://www.linuxcool.com/tar">tar 命令 – 压缩和解压缩文件 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tar -zxvf redis-7.0.0.tar.gz -C /opt/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132259120.png"></p>
<blockquote>
<p>进入安装目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/redis-7.0.0/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行 make 命令, 出现下图红框内容代表安装成功, 安装需要能够访问外网, 以及有足够的权限, 不知道为什么 sudo 的都不行, 最后直接使用的 root 用户进行的编译</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132311352.png"></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><blockquote>
<p>进入默认安装路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/bin</span><br><span class="line"><span class="comment"># 列出所有文件</span></span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132327916.png"></p>
<blockquote>
<p>将默认的 redis.conf 拷贝到我们自己定义的路径下, 以防后续修改坏了的话还有备份。<a target="_blank" rel="noopener" href="https://www.linuxcool.com/cp">cp 命令 – 复制文件或目录 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /myredis/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到自定义文件夹下</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /opt/redis-7.0.0/redis.conf /myredis/conf/redis7.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置 redis 的配置文件, 使用 Vim 打开 &#x2F;myredis&#x2F;conf&#x2F;redis7.conf 设置以下参数, 配置文件修改后, 需要重启 redis 服务才会生效</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后台服务的模式启动</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 关闭redis的保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 注释掉bind参数</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 -::1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 添加redis密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>daemonize</code></td>
<td><strong>yes:</strong> Redis 以守护进程形式在后台运行，PID 号写入指定的 <code>pidfile</code> 文件。需要手动终止该进程。<br><strong>no:</strong> Redis 以前台模式运行，显示 Redis 命令行界面。退出终端或关闭连接工具将停止 Redis 进程。<img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131175630472.png"></td>
</tr>
<tr>
<td><code>protected-mode</code></td>
<td><strong>yes:</strong> 开启保护模式。只允许来自 <code>bind</code> 参数指定地址或通过 <code>requirepass</code> 密码访问。如果两者均未设置，则只允许本地地址访问。<br> <strong>no:</strong> 关闭保护模式。如果未设置 <code>bind</code> 和 <code>requirepass</code>，允许任何地址和 IP 直接连接 Redis，无需密码验证。</td>
</tr>
<tr>
<td><code>bind</code></td>
<td>通过设置 <code>bind</code> 参数，限制只允许指定地址连接到 Redis 服务。</td>
</tr>
<tr>
<td><code>requirepass</code></td>
<td>设置 Redis 密码。连接 Redis 服务时必须提供正确密码，否则无法访问。</td>
</tr>
</tbody></table>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><blockquote>
<p>启动 redis 服务, <code>/usr/local/bin</code> 目录下运行 <code>redis-server</code> ，启用&#x2F;myredis&#x2F;conf&#x2F;redis7.conf 文件, 服务启动是没有输出消息的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/conf/redis7.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看是否启动成功 <a target="_blank" rel="noopener" href="https://www.linuxcool.com/ps">ps 命令 – 显示进程状态 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis|grep -v grep</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132341742.png"></p>
<h3 id="链接服务"><a href="#链接服务" class="headerlink" title="链接服务"></a>链接服务</h3><blockquote>
<p>链接 <code>redis-cli</code> 是 redis 的命令行工具, 有很多参数可以 <code>redis-cli --help</code> 去了解, 链接成功如下图所示</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 1234 -p 6379</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240116231738455.png"></p>
<blockquote>
<p>测试服务是否能正常使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132355860.png"></p>
<h3 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h3><blockquote>
<p>退出客户端</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><blockquote>
<p>redis-cli 内部执行 <code>shutdown</code> 或者 <code>redis-cli -a 1234 shutdown</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未进入 redis-cli</span></span><br><span class="line">redis-cli -a 1234 shutdown</span><br><span class="line"><span class="comment"># 进入  redis-cli内部后</span></span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240116232000371.png"></p>
<h2 id="Redis-十大数据类型"><a href="#Redis-十大数据类型" class="headerlink" title="Redis 十大数据类型"></a>Redis 十大数据类型</h2><h3 id="Key-键"><a href="#Key-键" class="headerlink" title="Key(键)"></a>Key(键)</h3><p>Redis 键命令用于管理 redis 的键。</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>DEL key</code> 该命令用于在 key 存在时删除 key</li>
<li><code>DUMP key</code> 序列化给定 key ，并返回被序列化的值。使用 <code>DUMP</code> 命令所获取的序列化数据可以用 <code>RESTORE</code> 命令来恢复</li>
<li><code>EXISTS key</code> 判断键是否存在，存在返回 1，不存在返回 0</li>
<li><code>EXPIRE key seconds</code> 设置键的过期秒数</li>
<li><code>EXPIREAT key timestamp</code> 作用和 <code>EXPIRE</code> 一样，不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳，可以指定到期时间</li>
<li><code>PEXPIRE key seconds</code> 设置键的过期毫秒数</li>
<li><code>PEXPIREAT key timestamp</code> 作用和 <code>EXPIRE</code> 一样，不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳，可以指定到期时间</li>
<li><code>KEYS partten</code> 查找所有符合给定模式 ( pattern) 的 key 全部就是 key <strong>正式环境禁用，使用 scan 命令代替</strong>。</li>
<li><code>MOVE key db</code> 移动 key 到指定的库</li>
<li><code>PERSIST key</code> 移除 key 的过期时间，能让数据一致保持</li>
<li><code>TTL key</code> 看 key 剩余时间还有多少秒</li>
<li><code>PTTL key</code> 看 key 剩余时间还有多少毫秒</li>
<li><code>RANDOMKEY</code> 随机返回库中的一个 key</li>
<li><code>RENAME key newkey</code> 修改 key 的名称</li>
<li><code>RENAMENX key newkey</code> 修改 key 的名称，当新 key 不存在时才生效</li>
<li><code>TYPE key</code> 返回 key 的类型</li>
<li><code>SCAN cursor [MATCH pattern] [COUNT count]</code> 迭代数据库中的数据库键。返回值有下一次用于迭代的游标，<code>COUNT count</code>，是一种提示 (hint)，如 <code>Count 10</code> 表示期望返回 10 个 key，大多数情况是有效的，但不一定 100% 返回 10 个 key。</li>
</ul>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>String 是 Redis 中最简单同时也是最常用的数据类型。它是一个二进制安全的字符串，可以存储任何类型的数据，如字符串、整数、浮点数等。</p>
<ul>
<li><code>SET key value</code> 设置指定 <code>key</code> 的值。</li>
<li><code>GET key</code> 获取指定 <code>key</code> 的值。</li>
<li><code>GETRANGE key start end</code> 返回 <code>key</code> 中字符串值的子字符串。</li>
<li><code>GETSET key value</code> 将给定 <code>key</code> 的值设为 <code>value</code>，并返回 <code>key</code> 的旧值。</li>
<li><code>GETBIT key offset</code> 对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位（bit）。</li>
<li><code>MGET key1 [key2..] </code> 获取所有（一个或多个）给定 <code>key</code> 的值。</li>
<li><code>SETBIT key offset value</code> 对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位（bit）。</li>
<li><code>SETEX key seconds value</code> 将值 <code>value</code> 关联到 <code>key</code>，并将 <code>key</code> 的过期时间设为 <code>seconds</code>（以秒为单位）。</li>
<li><code>SETNX key value</code> 只有在 <code>key</code> 不存在时设置 <code>key</code> 的值。</li>
<li><code>SETRANGE key offset value</code> 用 <code>value</code> 参数覆写给定 <code>key</code> 所储存的字符串值，从偏移量 <code>offset</code> 开始。</li>
<li><code>STRLEN key</code> 返回 <code>key</code> 所储存的字符串值的长度。</li>
<li><code>MSET key value [key value ...]</code> 同时设置一个或多个 <code>key-value</code> 对。</li>
<li><code>MSETNX key value [key value ...] </code> 同时设置一个或多个 <code>key-value</code> 对，当且仅当所有给定 <code>key</code> 都不存在。</li>
<li><code>PSETEX key milliseconds value</code> 同 <code>SETEX</code> 命令相似，但它以毫秒为单位设置 <code>key</code> 的生存时间。</li>
<li><code>INCR key</code> 将 <code>key</code> 中储存的数字值增一。</li>
<li><code>INCRBY key increment</code> 将 <code>key</code> 所储存的值加上给定的增量值（increment）。</li>
<li><code>INCRBYFLOAT key increment</code> 将 <code>key</code> 所储存的值加上给定的浮点增量值（increment）。</li>
<li><code>DECR key</code> 将 <code>key</code> 中储存的数字值减一。</li>
<li><code>DECRBY key decrement</code> 将 <code>key</code> 所储存的值减去给定的减量值（decrement）。</li>
<li><code>APPEND key value</code> 如果 <code>key</code> 已经存在并且是一个字符串，<code>APPEND</code> 命令将指定的 <code>value</code> 追加到该 <code>key</code> 原来值的末尾。<br><strong>常用命令</strong>：</li>
<li><code>SET key value</code>：设置 key 的值。</li>
<li><code>GET key</code>：获取 key 的值。</li>
<li><code>INCR key</code>：将 key 中的数字值增 1。</li>
<li><code>DECR key</code>：将 key 中的数字值减 1。</li>
<li><code>STRLEN key</code>：获取 key 的值的长度。</li>
<li><code>EXISTS key</code>：判断 key 是否存在。</li>
<li><code>DEL key</code>：删除 key 及其值。</li>
<li><code>EXPIRE key seconds</code>：为 key 设置过期时间（秒）。</li>
<li><code>TTL key</code>：查看 key 的剩余生存时间（秒）。</li>
</ul>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 中的 List 是一个双向链表，支持快速的插入和删除操作。它可以作为队列或栈来使用。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>LPUSH key value</code>：在列表的左端插入一个或多个值。</li>
<li><code>RPUSH key value</code>：在列表的右端插入一个或多个值。</li>
<li><code>LPOP key</code>：移除并返回列表的左端元素。</li>
<li><code>RPOP key</code>：移除并返回列表的右端元素。</li>
<li><code>LRANGE key start stop</code>：获取列表指定范围内的元素。</li>
<li><code>LLEN key</code>：获取列表的长度。</li>
</ul>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 中的 Set 是一个无序的字符串集合，它不允许有重复的元素。Set 提供了集合操作，如添加、删除、合并等。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>SADD key member</code>：向集合添加一个或多个成员。</li>
<li><code>SREM key member</code>：从集合移除一个或多个成员。</li>
<li><code>SMEMBERS key</code>：返回集合中的所有成员。</li>
<li><code>SISMEMBER key member</code>：判断成员是否在集合中。</li>
<li><code>SCARD key</code>：获取集合的成员数量。</li>
</ul>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis 中的 Hash 是一个键值对的集合，类似于一个对象。Hash 中的每个字段（Field）和值（Value）都是字符串。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>HSET key field value</code>：为哈希表 key 中的字段 field 设置值 value。</li>
<li><code>HGET key field</code>：获取哈希表 key 中字段 field 的值。</li>
<li><code>HMSET key field1 value1 field2 value2</code>：同时设置哈希表 key 的多个字段的值。</li>
<li><code>HMGET key field1 field2</code>：同时获取哈希表 key 的多个字段的值。</li>
<li><code>HGETALL key</code>：获取哈希表 key 中的所有字段和值。</li>
<li><code>HDEL key field</code>：删除哈希表 key 中的字段 field。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><blockquote>
<p>redis 持久化 (也叫备份和恢复) 是指将数据写入持久存储，例如固态磁盘 （SSD）。Redis 提供了一系列持久性选项。这些包括：</p>
</blockquote>
<ul>
<li><strong>RDB</strong>（Redis 数据库）：RDB 持久性按指定的时间间隔执行数据集的时间点快照。</li>
<li><strong>AOF</strong>（仅追加文件）：AOF 持久性记录服务器接收的每个写入操作。然后，可以在服务器启动时再次重播这些操作，从而重建原始数据集。使用与 Redis 协议本身相同的格式记录命令。</li>
<li><strong>RDB + AOF</strong>：您还可以在同一实例中组合 AOF 和 RDB。</li>
<li><strong>无持久性</strong>：您可以完全禁用<strong>持久性</strong>。这有时在缓存时使用。</li>
</ul>
<h3 id="持久化的两种方式"><a href="#持久化的两种方式" class="headerlink" title="持久化的两种方式"></a>持久化的两种方式</h3><blockquote>
<p>下图形象的描述了持久化的两种方式, 我们可以对其有个大概印象, 后续再回头看这张图就会有更多的理解</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119193642354.png"></p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><h5 id="是什么-能干嘛"><a href="#是什么-能干嘛" class="headerlink" title="是什么, 能干嘛"></a>是什么, 能干嘛</h5><blockquote>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘, 也就是行话讲的 Snapshot 内存快照，它恢复时再将硬盘快照文件直接读回到内存里</p>
</blockquote>
<h5 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h5><h6 id="配置文件新旧版本说明"><a href="#配置文件新旧版本说明" class="headerlink" title="配置文件新旧版本说明"></a>配置文件新旧版本说明</h6><p>讲在前头, redis6 和 7 的 RDB 配置的主要在于同步频次上, 以及在 redis7 中如果不进行显示配置, 则会按照默认的同步快照的批量进行.</p>
<p>关于同步快照的设置格式为 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 距离最近一次同步的秒数    键改变的数量</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6.0.16 之前的配置文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119195211598.png"></p>
<blockquote>
<p>redis2.0 到 redis7 的配置</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119195705438.png"></p>
<h6 id="自动触发快照保存"><a href="#自动触发快照保存" class="headerlink" title="自动触发快照保存"></a>自动触发快照保存</h6><p><strong>修改同步频次</strong>本文档使用的是 redis7.0.0 进行操作, 因此为了更好的观察现象, 我们修改同步的配置为 <code>save 20 2</code>,也就是距离上传同步大于 20 秒, 并且有至少两次键值改变才触发同步</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202317352.png"></p>
<p><strong>修改快照保存路径</strong> 快照保存路径默认为当前 redis 所工作目录下, 我们可以修改配置文件中的 dir 参数自定义快照保存路径, 🔔 需要注意的是, 文件夹需要提前存在</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202043117.png"></p>
<p><strong>修改保存文件的名称</strong> 文件默认保存的文件名为 <code>dump.rdb</code> 单机情况下肯定是无须修改, 但如果是集群环境下, 还是最好对文件名做一定的调整, 方便区分是那台服务的备份文件, 我们本次修改为 <code>dump6379.rdb</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202035248.png"></p>
<p><strong>踩坑记录</strong></p>
<blockquote>
<p>问题现象: 当触发了自动备份时, 会爆出下图中的错误</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210051618.png"></p>
<blockquote>
<p>排查过程:</p>
</blockquote>
<ol>
<li><p>修改配置文件, 自定义日志的输出路径 <code>logfile &quot;/myredis/logs/redis.log&quot;</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210336172.png"></p>
</li>
<li><p>启动服务, 好嘛这次连服务都起不来了<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210546990.png"></p>
</li>
<li><p>按照 GPT 的回答, 是日志权限不足, 一查还真是, 除了当前用户,其他人没有写的权限</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210814526.png"></p>
</li>
<li><p>修改日志的权限 <code>sudo chmod 666 /myredis/logs/redis.log</code></p>
</li>
<li><p>服务启动, 再次进行触发备份的操作, 步骤 1 的问题复现</p>
</li>
<li><p>查看 redis 日志 <code>cat redis.log</code>, 密密麻麻两个字 吃人 (权限不足)<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119211312698.png"></p>
</li>
<li><p>修改备份文件夹权限 <code>sudo chmod 777 dumpfiles/</code><br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119211445713.png"></p>
</li>
<li><p>大功告成 <code>dump6379</code> 就是自动触发的快照保存<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119212005640.png"></p>
</li>
</ol>
<p><strong>总结</strong> ① 与 redis 服务交互的文件需要给予足够的权限 ② 触发自动备份的时机除了上述满足条件外, 还有主动 <code>shutdown</code> 服务时也会进行一次备份</p>
<h6 id="手动触发快照保存"><a href="#手动触发快照保存" class="headerlink" title="手动触发快照保存"></a>手动触发快照保存</h6><blockquote>
<p>Redis 提供了两个命令来生成 RDB 文件分别是 <code>save</code> 和 <code>bgsave</code></p>
</blockquote>
<ul>
<li><code>save</code> 在主程序中执行会阻塞当前 redis 服务器，直到持久化工作完成执行 save 命令期间，Redis 不能处理其他命令，<strong>线上禁止使用</strong></li>
<li><code>basve</code> Redis 会在后台异步进行快照操作，不阻塞快照同时还可以响应客户端请求，该触发方式会 fork 一个子进程由子进程复制持久化过程。讲点大白话就是，执行 <code>bsave</code> 之后, 会 <code>fork</code> 复刻一个当前的进程, 专门用来进行数据集的保存。原来的进程继续用来接受处理 redis 的线上请求</li>
</ul>
<h6 id="Lastsave"><a href="#Lastsave" class="headerlink" title="Lastsave"></a>Lastsave</h6><blockquote>
<p>查看最后一次快照的保存时间 <code>lastsave</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120094219499.png"></p>
<h5 id="优势及注意点"><a href="#优势及注意点" class="headerlink" title="优势及注意点"></a>优势及注意点</h5><p><strong>优势</strong></p>
<ul>
<li>RDB 是 Redis 数据的一个非常紧凑的单文件时间点表示。RDB 文件非常适合备份。例如，您可能希望在最近的 24 小时内每小时归档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松恢复不同版本的数据集。</li>
<li>RDB 非常适合灾难恢复，它是一个可以传输到远程数据中心或 AmazonS3（可能已加密）的压缩文件。</li>
<li>RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘 I&#x2F;O 或类似操作。</li>
<li>与 AOF 相比，RDB 允许使用大数据集更快地重启。</li>
<li>在副本上，<em>RDB 支持重启和故障转移后的部分重新同步。</em></li>
</ul>
<p><strong>注意点</strong></p>
<ol>
<li>适合大规模的数据恢复;</li>
<li>按照业务定时备份;</li>
<li>对数据完整性和一至 - 致性要求不高;</li>
<li>RDB 文件在内存中的加载速度要比 AOF 快得多</li>
</ol>
<h5 id="劣势及注意点"><a href="#劣势及注意点" class="headerlink" title="劣势及注意点"></a>劣势及注意点</h5><p><strong>劣势</strong></p>
<ul>
<li><p>如果您需要在 Redis 停止工作时（例如断电后）将数据丢失的可能性降到最低，那么 RDB 并不好。您可以配置生成 RDB 的不同保存点（例如，在对数据集至少 5 分钟和 100 次写入之后，您可以有多个保存点）。但是，您通常会每五分钟或更长时间创建一次 RDB 快照，<strong>因此，如果 Redis 由于任何原因在没有正确关闭的情况下停止工作，您应该准备好丢失最新分钟的数据。</strong></p>
</li>
<li><p>RDB 需要经常 fork() 以便使用子进程在磁盘上持久化。如果数据集很大，fork() 可能会很耗时，并且如果数据集很大并且 CPU 性能不是很好，可能会导致 Redis 停止为客户端服务几毫秒甚至一秒钟。AOF 也需要 fork() 但频率较低，您可以调整要重写日志的频率，而不需要对持久性进行任何权衡。</p>
</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li><p>在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong>;</p>
</li>
<li><p>内存数据的全量同步，如果<strong>数据量太大会导致 I&#x2F;O 严重影响服务器性能</strong>;</p>
</li>
<li><p>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。f<strong>ork 的时候内存中的数据被克隆了一份，大致 2 倍的膨胀性</strong>，需要考虑</p>
</li>
</ul>
<h5 id="模拟数据丢失"><a href="#模拟数据丢失" class="headerlink" title="模拟数据丢失"></a>模拟数据丢失</h5><blockquote>
<p>录入数据, 正常触发保存. 保存后, 设置 a5 的值, 并且此次数据录入并未满足自动保存条件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120101638883.png"></p>
<blockquote>
<p>模拟意外的发生</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询进程号</span></span><br><span class="line">ps aux |grep &#123;redis&#125;</span><br><span class="line"><span class="comment"># 杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 &#123;进程号&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120102208295.png"></p>
<blockquote>
<p>重启服务, 并查询 a3, a4, a5 的值, 可以发现 最后一次保存时间点前的数据 a3 和 a4 能正常获取, 而 a5 的数据发生了丢失</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120102542245.png"></p>
<h5 id="检查修复-Dump-文件"><a href="#检查修复-Dump-文件" class="headerlink" title="检查修复 Dump 文件"></a>检查修复 Dump 文件</h5><blockquote>
<p>以下指令用来修复备份文件, 能修复就修复了, 修复不了基本上就寄了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-rdb /myredis/dumpfiles/dump6379.rdb</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120103349033.png"></p>
<h5 id="触发快照保存的情况总结"><a href="#触发快照保存的情况总结" class="headerlink" title="触发快照保存的情况总结"></a>触发快照保存的情况总结</h5><ul>
<li>符合配置文件中快照配置条件</li>
<li>手动 <code>save</code>&#x2F;<code>bsave</code> 命令执行</li>
<li>执行 <code>flushall</code>&#x2F;<code>flushdb</code> 命令也会触发备份, 不过会清空备份文件, 没意义</li>
<li>执行 <code>shutdown</code> 且没开启 AOF 持久化</li>
<li>主从复制, 主节点自动触发 (当前还未验证,后面验证)</li>
</ul>
<h5 id="禁用快照-自动保存"><a href="#禁用快照-自动保存" class="headerlink" title="禁用快照 (自动保存)"></a>禁用快照 (自动保存)</h5><blockquote>
<p>使用命令动态临时的关闭快照</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config <span class="built_in">set</span> save <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120104839516.png"></p>
<blockquote>
<p>或者直接修改配置文件中的 <code>save</code> 参数为 <code>&#39;&#39;</code></p>
</blockquote>
<h5 id="RDB-配置项详解"><a href="#RDB-配置项详解" class="headerlink" title="RDB 配置项详解"></a>RDB 配置项详解</h5><blockquote>
<p>也就是配置文件的件 SNAPSHOTTING 模块</p>
</blockquote>
<ul>
<li><code>stop-writes-on-bgsave-error </code> <strong>默认 yes</strong>,如果配置成 no，表示你不在乎数据不一致或者有其他的手段发现和控制这种不一致，那么在快照写入失败时，也能确保 redis 继续接受新的写请求|</li>
<li><code>rdbcompression</code> <strong>默认 yes</strong>, 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能</li>
<li><code>rdbchecksum</code> <strong>默认 yes</strong> 在存储快照后，还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</li>
<li><code>rdb-del-sync-files</code> 在没有持久性的情况下删除复制中使用的 RDB 文件启用。<strong>默认情况下 no</strong>，此选项是禁用的</li>
<li><code>save 20 2</code></li>
<li><code>dbfilename dump6379.rdb</code></li>
<li><code>dir /myredis/dumpfiles</code></li>
</ul>
<h5 id="一图总结"><a href="#一图总结" class="headerlink" title="一图总结"></a>一图总结</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120110106579.png"></p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><h5 id="是什么-能干嘛-1"><a href="#是什么-能干嘛-1" class="headerlink" title="是什么, 能干嘛"></a>是什么, 能干嘛</h5><blockquote>
<p>以日志的形式来记录每个 <code>增删改</code> 操作，将 Redis 执行过的所有写指令记录下来 (<strong>读操作不记录</strong>)，只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</blockquote>
<h5 id="AOF-持久化的工作流程图"><a href="#AOF-持久化的工作流程图" class="headerlink" title="AOF 持久化的工作流程图"></a>AOF 持久化的工作流程图</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120131908075.png"></p>
<ol>
<li>Client 作为命令的来源，会有多个源头以及源源不断的请求命令。</li>
<li>在这些命令到达 Redis Server 以后并不是直接写入 AOF 文件，会将其这些命令先放入 AOF 缓存中进行保存。这里的 AOF 缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘 IO 操作。</li>
<li>AOF 缓冲会根据 AOF 缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的 AOF 文件。</li>
<li>随着写入 AOF 内容的增加为避免文件膨胀，会根据规则进行命令的合并 (又称<strong>AOF 重写</strong>)，从而起到 AOF 文件压缩的目的。</li>
<li>当 Redis Server 服务器重启的时候会从 AOF 文件载入数据。</li>
</ol>
<h5 id="AOF-三种同步的写回策略"><a href="#AOF-三种同步的写回策略" class="headerlink" title="AOF 三种同步的写回策略"></a>AOF 三种同步的写回策略</h5><blockquote>
<p>三种写回策略</p>
</blockquote>
<ol>
<li><code>always</code> 可以理解为, 客户端执行写一个指令, 离开就往日志文件中追加一个</li>
<li><code>everysec</code> 每秒写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘</li>
<li><code>no</code> 操作系统控制的写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓中区，由操作系统决定何时将缓中区内容写回磁盘</li>
</ol>
<blockquote>
<p>各种策略优缺点</p>
</blockquote>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步写回</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td>Everysec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>岩机时丢失 1 秒内的数据</td>
</tr>
<tr>
<td>No</td>
<td>操作系统控制的写回</td>
<td>性能好</td>
<td>岩机时丢失数据较多</td>
</tr>
</tbody></table>
<h5 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h5><h6 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h6><p><strong>开启 AOF</strong></p>
<blockquote>
<p>AOF 默认是关闭的, 开起需要将配置文件中的 <code>appendonly</code> 参数设置为 <code>yes</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120134647477.png"></p>
<p><strong>设置回写策略</strong></p>
<blockquote>
<p>使用默认的写回策略, 默认写回即可</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120134928816.png"></p>
<p><strong>备份存放路径</strong></p>
<blockquote>
<p>redis6 中的 AOF 保存文件的位置和 RDB 保存文件的位置一样，都是通过 redis.conf 配置文件的 dir 配置, 但是在 redis 中, 增加了 <code>appenddirname</code> 参数, 用来指定 AOF 的日志存放文件夹。因此当前 redis7 中的 AOF 备份的实际存放路径为 <code>dir</code>+<code>appenddirname</code>。本次修改 AOF 保存文件的路径为 <code>/myredis/backupfiles/appendonlydir</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120215308219.png"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120215403262.png"></p>
<p><strong>备份文件名</strong></p>
<blockquote>
<p>Redis6 版本中的备份文件名由 <code>appendfilename</code> 参数控制, 是单独一个文件。但是由于 AOF 是一个一个指令集的叠加, 导致文件会逐渐膨胀, 过大的文件会导致影响写入指令的 IO 性能。 因此在 Redis7 中, 使用了一组文件来作为 AOF 的备份文件, 分别是 <code>基础文件base</code>, <code>增量文件incr</code>, <code>清单文件manifest</code> 。而 <code>appendfilename</code> 参数所配置的为该组文件的文件名后缀, 此次我们使用默认的不做变更。</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120223442310.png"></p>
<h6 id="生成-AOF-备份文件"><a href="#生成-AOF-备份文件" class="headerlink" title="生成 AOF 备份文件"></a>生成 AOF 备份文件</h6><blockquote>
<p>按需求配置完参数, 重启 reds 服务, nice, 启动失败</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120224030427.png"></p>
<blockquote>
<p>额, 这波属实是不长记性了, 处理一下小意外, 无伤大雅</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建备份文件的路径</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /myredis/backupfiles</span><br><span class="line"><span class="comment"># 给备份文件夹修改写入权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 /myredis/backupfiles</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120224608380.png"></p>
<blockquote>
<p>正常写入数据</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225154128.png"></p>
<blockquote>
<p>查看生成的备份文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225400306.png"></p>
<blockquote>
<p>重启 redis, 为避免是从由于 RDB 文件中加载的数据, 我们将 RDB 备份文件重命名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> dump6379.rdb dump6379.rdb.bak</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225834361.png"></p>
<blockquote>
<p>重启服务, 获取数据, 该说不说, 兄弟们好使 👍</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120230047211.png"></p>
<blockquote>
<p>作死执行一手 <code>flushall</code> , 查看一下备份文件的情况</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120230702616.png"></p>
<blockquote>
<p>重启 Redis, 查询数据发现, 没有值</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120231112178.png"></p>
<blockquote>
<p>命令不是逐条写入, 写的这么清楚, 我是不是能改一下呢, 删掉 <code>flushall</code> 来恢复数据呢? 说干就干, 不过干之前备份文件夹。本来还想记录踩坑经过呢， 没想到一把梭哈，我真是张飞吃豆芽, 粗中有细啊.</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120231924031.png"></p>
<h6 id="异常恢复-AOF-备份文件"><a href="#异常恢复-AOF-备份文件" class="headerlink" title="异常恢复 AOF 备份文件"></a>异常恢复 AOF 备份文件</h6><blockquote>
<p>AOF 备份文件可能会由于网络断链, 服务进程被杀掉等情况导致命令还未完全写入备份文件导致的文件损坏, 这里我们乱写一通模拟坏掉的文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120232431665.png"></p>
<blockquote>
<p>备份文件损坏后, 我们发现连服务都起不来</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120232620664.png"></p>
<blockquote>
<p>修复备份文件, 记住检查指令中一定要加上 <code>--fix</code> 参数, 是否继续选 <code>y</code> 就行了, 如下图操作所示, 好使。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix  /myredis/backupfiles/appendonlydir/appendonly.aof.1.incr.aof</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120233119037.png"></p>
<h5 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h5><ul>
<li>优点： 更好的保护数据不丢失、性能高、可做紧急恢复</li>
<li>缺点：① 相同数据集的数据而言 aof 文件要远大于 rdb 文件，恢复速度慢于 rdb； ②aof 运行效率要慢于 rdb,每秒同步策略效率较好，不同步效率和 rdb 相同</li>
</ul>
<h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><h6 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h6><blockquote>
<p>由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中，随着 Redis 不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis 新增了重写机制，当 AOF 文件的大小超过所设定的峰值时，Redis 就会<strong>自动</strong>启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 <code>bgrewriteaof</code> 来重写。<strong>启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集</strong></p>
</blockquote>
<h6 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h6><blockquote>
<p>触发机制分为两种情况, 分别是自动触发和手动触发</p>
</blockquote>
<ul>
<li><p><strong>自动触发：</strong> 需要同时满足下图中的两个条件，即 <code>auto-aof-rewrite-percentage</code> 本次 AOF 文件大小达到上次 AOF 文件的百分之多少; <code>auto-aof-rewrite-min-size </code> 重写时需要满足的文件大小至少要满足多少。举个 🌰: redis7 中默认参数分别是 <code>auto-aof-rewrite-percentage 100</code>, <code>auto-aof-rewrite-min-size 64mb</code> 也就意味着, 当本次的 AOF 的大小是之前 AOF 的百分之百<strong>并且</strong>本次文件大小不小于 64Mb, 才会触发自动重写机制</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122214437669.png"></p>
</li>
<li><p><strong>手动触发：</strong> 客户端向服务器发送 <code>bgrewriteaof</code> 命令</p>
</li>
</ul>
<h6 id="案例演示-仅演示自动触发"><a href="#案例演示-仅演示自动触发" class="headerlink" title="案例演示 (仅演示自动触发)"></a>案例演示 (仅演示自动触发)</h6><blockquote>
<p>前期配置文件修改</p>
</blockquote>
<ul>
<li>开启 AOF : <code>appendonly yes</code> 默认是 no, 设置为 yes 即可开启</li>
<li>重写峰值: <code>auto-aof-rewrite-min-size 1kb</code> 默认的重写峰值是 64mb 太大了, 不好测试, 我们修改为 1kb</li>
<li>关闭混合持久化: <code>aof-use-rdb-preamble no</code> 默认是 yes, 我们为了单纯的测 AOF, 所以关掉与 AOF 的混合持久化</li>
<li>删除原来的 aof 与 rdb 文件, 避免干扰项</li>
</ul>
<p><code> </code></p>
<blockquote>
<p>启动服务, 执行写入数据的指令, 当我执行了 16 次 <code> set k1 1111111111111111111111111111111</code> 之后, 增量 AOF 文件的大小来到了 967kb</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122221418987.png"></p>
<blockquote>
<p>此时我们查看一下 <code>cat appendonly.aof.1.incr.aof</code> 文件的内容, 不出以外, 清一色的如下指令, 如下图所示</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122221724897.png"></p>
<blockquote>
<p>趁此间隙, 解释一下这些指令集怎么看吧 <code># *&#123;该条指令包含几个参数&#125;</code>, <code># $&#123;该参数的长度&#125;</code>, 也就是说下面这个指令集的意思是包含三个参数, 第一个参数的长度是 3, 值是 set , 第二个参数的长度是 2, 值是 k1, 后面的规则相同…….</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="variable">$2</span></span><br><span class="line">k1</span><br><span class="line"><span class="variable">$31</span></span><br><span class="line">1111111111111111111111111111111</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继续写入数据, 触发重写</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223637183.png"></p>
<blockquote>
<p>查看 apf 备份文件夹下的文件情况, 我们发现 incr 文件没有继续增加大小, 反而是 base 文件变大了, 并且文件的后缀均变成了 2</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223537711.png"></p>
<blockquote>
<p>我们先看一下 base 文件里新增的内容, 根据刚刚学习的指令集, 我们发现 base 文件中只存了我们当前最新的数据, 并没有保存以前输入的一大堆 set k1 111111</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223946887.png"></p>
<blockquote>
<p>再来看一下 incre 文件, 第一次查看时, 没有内容, 第二次查看时又有内容了。为什么呢？因为第一次查看查看时，我发现没有数据， 所以我又执行了一条指令。由此我们可以断定， <code>set k1 ababab......</code> 触发重写后, 会将当前内存里的数据写入 base 文件, 后续的指令写入到 incr 文件中</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122224348340.png"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122224603069.png"></p>
<blockquote>
<p><strong>结论:</strong> 也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code>：默认值为 100，以及 <code>auto-aof-rewrite-min-size</code>：64mb 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，<strong>默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发</strong></p>
</blockquote>
<h6 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h6><blockquote>
<p>AOF 的重写原理可以参考以下链接 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2294422">Redis7.0 以后 AOF 底层原理变更图解-腾讯云开发者社区-腾讯云 (tencent.com)</a>。</p>
</blockquote>
<ol>
<li>在重写开始前，redis 会创建一个“重写子进程”，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</li>
<li>当“重写子进程 “ 完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中</li>
<li>当追加结束后，redis 就会用新 AOF 文件来代替 I 旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中</li>
<li>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似</li>
</ol>
<h5 id="AOF-配置项详解"><a href="#AOF-配置项详解" class="headerlink" title="AOF 配置项详解"></a>AOF 配置项详解</h5><blockquote>
<p>也就是配置文件中的 APPEND_ONLY_MODLE 模块</p>
</blockquote>
<ul>
<li><code>appendonly</code> 是否开启 AOF, 默认 no</li>
<li><code>appendfilename</code> AOF 系列文件的前缀名</li>
<li><code>appendfsync</code> 三种同步策略 <strong>everysec&#x2F;always&#x2F;no</strong></li>
<li><code>no-appendfsync-on-rewrite</code> aof 重写期间是否同步, 默认值 no</li>
<li><code>auto-aof-rewrite-percentage</code> 重写触发百分比</li>
<li><code>auto-aof-rewrite-min-size</code> 重写触发文件大小的最小值</li>
</ul>
<h5 id="一图总结-1"><a href="#一图总结-1" class="headerlink" title="一图总结"></a>一图总结</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122231102027.png"></p>
<h3 id="RDB-AOF-混合持久化"><a href="#RDB-AOF-混合持久化" class="headerlink" title="RDB+AOF 混合持久化"></a>RDB+AOF 混合持久化</h3><h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><blockquote>
<p>关于 RDB 和 AOF 这两种持久化模式, 我们该如何选择, 官网是这样说的 <a target="_blank" rel="noopener" href="https://redis.io/docs/management/persistence/#backing-up-aof-persistence">Redis persistence | Redis</a>, 建议我们两者均开启</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123205559279.png"></p>
<h4 id="RDB-Vs-AOF"><a href="#RDB-Vs-AOF" class="headerlink" title="RDB Vs AOF"></a><code>RDB</code> Vs <code>AOF</code></h4><h5 id="能否共存"><a href="#能否共存" class="headerlink" title="能否共存?"></a>能否共存?</h5><blockquote>
<p>不用看了, 两者肯定能共存, 前面测试 AOF 的时候, rdb 备份文件也生成了</p>
</blockquote>
<h5 id="两者同时存在时的优先级谁高"><a href="#两者同时存在时的优先级谁高" class="headerlink" title="两者同时存在时的优先级谁高?"></a>两者同时存在时的优先级谁高?</h5><blockquote>
<p>优先级是 AOF 的高, 主要原因在于 AOF 备份的实时性太搞了, 在开启 <code>always</code> 的写回策略时, 能保证数据的百分百一直, 所以数据恢复以及加载时, 肯定会以 AOF 为主</p>
</blockquote>
<h5 id="数据恢复的顺序和加载流程"><a href="#数据恢复的顺序和加载流程" class="headerlink" title="数据恢复的顺序和加载流程"></a>数据恢复的顺序和加载流程</h5><blockquote>
<p>在同时开启 rdb 和 aof 持久化时，重启时只会加载 aof 文件，不会加载 rdb 文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123210320789.png"></p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><blockquote>
<p>两种持久化方式的特点</p>
</blockquote>
<ul>
<li>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾</li>
</ul>
<blockquote>
<p>🔔 推荐同时开启两种持久化方式, 虽然两者同时开启是, AOF 的优先级总是高于 RDB, 但是, 由于 AOF 文件总是在一直变化, 所以不易备份, 应该留存 RDB 文件用作备份, 分机备份</p>
</blockquote>
<h4 id="RDB-AOF-混合模式"><a href="#RDB-AOF-混合模式" class="headerlink" title="RDB + AOF 混合模式"></a><code>RDB</code> + <code>AOF</code> 混合模式</h4><blockquote>
<p>先说好处, 这种方式结合了 RDB 和 AOF 的优点，既能快速加载又能避免丢失过多的数据。强烈推荐</p>
</blockquote>
<h5 id="开启混合模式"><a href="#开启混合模式" class="headerlink" title="开启混合模式"></a>开启混合模式</h5><blockquote>
<p>之前测试 AOF 重写的时候关闭了, 这次再打开</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123211637657.png"></p>
<h5 id="写入数据-触发重写"><a href="#写入数据-触发重写" class="headerlink" title="写入数据, 触发重写"></a>写入数据, 触发重写</h5><blockquote>
<p>我们可以看到, 在开启混合模式之后, redis 在压缩指令集的时候, 并没有将内存快照处理成 base.aof 文件, 而是处理成了 RDB 文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123212034897.png"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>使用 RDB 进行快照存储，然后使用 AOF 持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能</p>
</blockquote>
<h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><blockquote>
<p>关机就关机, 停服务就停服务, 主打一个对数据不关心, 强烈不推荐, 多大的并发啊, Redis 都支持不了你, 处理不了就加设备…..<br>至于如何开启, 把 AOF 和 RDB 都关了就算开启</p>
</blockquote>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>关于 Redis 的事务, 官网上是这样介绍的 <a target="_blank" rel="noopener" href="https://redis.io/docs/interact/transactions/">Transactions | Redis</a>, Redis Transactions allow the execution of a group of commands in a single step, they are centered around the commands <a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a>, <a target="_blank" rel="noopener" href="https://redis.io/commands/exec"><code>EXEC</code></a>, <a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code></a> and <a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code></a>。讲人话就是可以一次执行多个命令，事务的本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</p>
</blockquote>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p>开启 一个队列中，一次性、顺序性、排他性的执行一系列命令, 不允许其他指令加塞, 大致原理参照下图</p>
</blockquote>
<h3 id="Redis-事务-VS-数据库事务"><a href="#Redis-事务-VS-数据库事务" class="headerlink" title="Redis 事务 VS 数据库事务"></a>Redis 事务 VS 数据库事务</h3><h4 id="数据库事务及特性"><a href="#数据库事务及特性" class="headerlink" title="数据库事务及特性"></a>数据库事务及特性</h4><blockquote>
<p>数据库事务是一组数据库操作，它们在数据库中被视为一个单一的工作单元，要么全部执行，要么全部不执行。事务是确保数据库数据一致性和完整性的一种机制。在事务的执行过程中，如果发生错误，所有已执行的操作将被撤销，数据库回滚到事务开始之前的状态。只有当所有操作都成功完成时，事务才会被提交，数据库保存更新后的状态。</p>
</blockquote>
<p>🙈 这里多提一嘴, 数据库事务具有以下四个主要特性，通常被称为 ACID 特性：</p>
<ol>
<li><p><strong>原子性（Atomicity）：</strong> 事务是一个原子操作，要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任何一个操作失败，整个事务将被撤销，数据库回到事务开始之前的状态。</p>
</li>
<li><p><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束后，数据库的完整性约束应该保持一致。这意味着事务执行后，数据库应该处于一个合法的状态，不违反任何完整性规则。</p>
</li>
<li><p><strong>隔离性（Isolation）：</strong> 事务的执行应该是相互隔离的，即一个事务的执行不应该影响其他事务的执行。隔离性通常通过并发控制机制来实现，以防止多个事务之间的干扰。</p>
</li>
<li><p><strong>持久性（Durability）：</strong> 一旦事务提交，其修改将永久保存在数据库中，即使系统发生故障或重启，事务的结果也不会丢失。</p>
</li>
</ol>
<h4 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h4><table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>单独的隔离操作</td>
<td>Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，redis 命令执行是<strong>单线程</strong>架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</td>
</tr>
<tr>
<td>没有隔离级别的概念</td>
<td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td>
</tr>
<tr>
<td>不保证原子性</td>
<td>Redis 的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>
</tr>
<tr>
<td>排它性</td>
<td>Redis 会保证一个事务内的命令依次执行，而不会被其它命令插入 (这个感觉和第一个特性的区别不大)</td>
</tr>
</tbody></table>
<h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MULTI</td>
<td>开启一个事务</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行所有事务内的命令</td>
</tr>
<tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个或多个键，如果在事务执行之前这些键被修改，则事务将被打断</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消所有对所有键的监视</td>
</tr>
</tbody></table>
<h4 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h4><blockquote>
<p><code>multi</code> 指令输入后, 将需要执行的指令依次放入队列, 但并不执行, 返回 <code>QUEUED</code> 代表放入成功, 当输入 exec 时, 一次性执行完前面的指令, 并返回对应的结果。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">MULTI</span><br><span class="line"><span class="comment"># ......输入语句</span></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123225013798.png"></p>
<blockquote>
<p>正常执行大体流程示意图</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio" alt="事务执行流程图"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123232127571.png"></p>
<h4 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h4><blockquote>
<p><code>multi</code> 指令输入后, 将需要执行的指令依次放入队列, 但并不执行, 返回 <code>QUEUED</code> 代表放入成功, 当输入 <code>discard</code> 时,取消执行前面的指令, 并结束事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">MULTI</span><br><span class="line"><span class="comment"># ......输入语句</span></span><br><span class="line"><span class="comment"># 放弃执行</span></span><br><span class="line">DISCARD</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123233016457.png"></p>
<blockquote>
<p>事务放弃执行的大体流程图如下</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E4%BA%8B%E5%8A%A1%E6%94%BE%E5%BC%83%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123233326990.png"></p>
<h4 id="全体连坐"><a href="#全体连坐" class="headerlink" title="全体连坐"></a>全体连坐</h4><blockquote>
<p>该种情况是指在开启事务后部分语法编译阶段就未通过, 会导致事务内的所有指令均不执行.</p>
</blockquote>
<p>下图中, 首先设置 <code>k1</code> 的值为 <code>zhanglei</code> , 然后开启事务, 修改 <code>k1</code> 的值为 <code>zhangsan</code> , 然后将 输入了一条错误的指令 <code>set k2</code> ,由于该指令语法错误, 并且都<strong>编译未通过</strong>, 因此在后续执行 <code>exec</code> 提交时, <code>set k1 zhangsan</code> 指令并未生效. 获取 <code>k1</code> 的值仍然为 <code>zhangslei</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131213214926.png"></p>
<h4 id="冤头债主"><a href="#冤头债主" class="headerlink" title="冤头债主"></a>冤头债主</h4><blockquote>
<p>该情况是指, <code>redis</code> 开启事务之后, 存在错误的指令, 但是在编译阶段并未发现, 而当提交执行后, 冤有头债有主, 正取的指令执行, 错误的指令停止</p>
</blockquote>
<p>如下图所示, 首先设置 <code>k1</code> 的值为 <code>zhanglei</code>, 设置 <code>count</code> 的值为 <code>abc</code> , 开启事务, 修改 <code>k1</code> 的值为 <code>zhangsan</code> 并执行 <code>incr count指令</code>. 我们要知道的是, <code>incr</code> 这条自增指令并未在此时报错, 但是它存在语法错误, 字符串无法执行自增指令, 后续获取 <code>k1</code> 和 <code>count</code> 的值, 我们可以发现, 与编译未通过不同的是, <code>set k1 zhangsan</code> 这条指令仍然生效了. 仅有 <code>incr count</code> 该指令未执行成功</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131214404940.png"></p>
<p><strong>注意事项</strong> 与传统数据库事务不同,Redis 事务中的指令并不是一起成功一起失败的, 并且 Redis 未提供数据回滚的能力, 开发者需要再事务执行失败后, 自行恢复数据状态</p>
<h4 id="Watch-监控"><a href="#Watch-监控" class="headerlink" title="Watch 监控"></a>Watch 监控</h4><blockquote>
<p>Redis 使用 <code>watch</code> 来实现乐观锁定, 类似于 CAS(check and set) ,Redis Watch 命令用于监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断</p>
</blockquote>
<p>如下图所示, 有两台 redis 客户端, 客户端 1 先执行左侧红框内 ① 中的指令, 设置 k1, k2 和 money 的值, 并监视 (<code>watch</code>) money 的值, 然后客户端 ② 执行右侧红框 ② 中的指令, 并修改了 money 的值为 200, 客户端 1 执行左侧蓝框 ③ 中的指令, 并开启事务, 修改 money 以及 k1 的值, 我们可以发现, 修改指令并未生效, 原因就是 <code>watch</code> 的 money 值发生改变, 导致事务中端</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131221112849.png"></p>
<p><strong>取消监视的几种情况</strong></p>
<ul>
<li>手动执行 <code>unwatch</code> 指令</li>
<li>执行 <code>exec</code> 提交事务后, 会取消所有的监视</li>
<li>客户端断开链接, 也会取消所有的监视</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>讲白了, Redis 的事务就三步: ① 开启事务; ② 命令入队, ③ 执行命令</p>
</blockquote>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144268090">高频 Redis 面试题解析：Redis 事务是否具备原子性？ - 知乎 (zhihu.com)</a></p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="Redis 管道"></a>Redis 管道</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><blockquote>
<p>如何优化命令往返导致的性能瓶颈?</p>
</blockquote>
<h4 id="面试题由来"><a href="#面试题由来" class="headerlink" title="面试题由来"></a>面试题由来</h4><p>Redis 是一种基于客户端 - 服务端模型以及请求&#x2F;响应协议的 TCP 服务。一个请求会遵循以下步骤：</p>
<ol>
<li>客户端向服务端发送命令分四步 (发送命令 → 命令排队 → 命令执行 → 返回结果)，并监听 Socket 返回，通常以阻塞模式等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
<p>上述两步称为：<strong>Round Trip Time</strong>(简称 RTT,数据包往返于两端的时间)，如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 redis 调用多次 read() 和 write() 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好，o(╥﹏╥)o</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131224548063.png"></p>
<p><strong>答案</strong></p>
<blockquote>
<p>管道 (pipeline) 可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与 redis 的通信次数来实现降低往返延时时间。pipeline 实现的原理是队列，先进先出特性就保证数据的顺序性。</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131224611607.png"></p>
<h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>Pipeline 是为了解决 RTT 往返回时，仅仅是将命令打包一次性发送，对整个 Redis 的执行不造成其它任何影响. 批处理命令变种, 类似于 redis 原生命令中的 <code>mest</code> 和 <code>mget</code></p>
</blockquote>
<h3 id="怎么用-3"><a href="#怎么用-3" class="headerlink" title="怎么用"></a>怎么用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> cmd.txt | redis-cli -a 1234 --pipe</span><br></pre></td></tr></table></figure>

<p>先将需要执行的指令写入一个文档, 文档中的指令格式可以是通常的指令, 也可以是 aof 的增量文件的指令格式. 安装上方的指令即可将文档中的指令打包扔给 redis server 执行</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131225908947.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="Pipeline-与原生批量命令对比"><a href="#Pipeline-与原生批量命令对比" class="headerlink" title="Pipeline 与原生批量命令对比"></a>Pipeline 与原生批量命令对比</h4><ul>
<li>原生批量命令是原子性 (例如:mset,mget)，pipeline 是非原子性</li>
<li>原生批量命令一次只能执行一种命令，pipeline 支持批量执行不同命令</li>
<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>
</ul>
<h4 id="Pipeline-与事务对比"><a href="#Pipeline-与事务对比" class="headerlink" title="Pipeline 与事务对比"></a>Pipeline 与事务对比</h4><ul>
<li>事务具有原子性，管道不具有原子性</li>
<li><strong>管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到 exec 命令后才会执行</strong>，管道不会</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>pipeline 缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</li>
<li>使用 pipeline 组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li>
</ul>
<h2 id="Redis-发布与订阅"><a href="#Redis-发布与订阅" class="headerlink" title="Redis 发布与订阅"></a>Redis 发布与订阅</h2><h3 id="学习定位"><a href="#学习定位" class="headerlink" title="学习定位"></a>学习定位</h3><blockquote>
<p>该部分内容了解即可</p>
</blockquote>
<h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</blockquote>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li><p><strong>消息订阅：</strong> Redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号, 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201103328724.png"></p>
</li>
<li><p><strong>消息发布：</strong> 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201103555854.png"></p>
</li>
</ul>
<h3 id="怎么用-4"><a href="#怎么用-4" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>① 订阅一个或多个符合给定模式的频道。② 推荐先订阅再发布, 否则在订阅之前发布的消息接收不到。</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody></table>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><h5 id="订阅-退订-发布"><a href="#订阅-退订-发布" class="headerlink" title="订阅&#x2F;退订&#x2F;发布"></a>订阅&#x2F;退订&#x2F;发布</h5><blockquote>
<p>涉及指令 <code>SUBSCRIBE</code> and <code>UNSUBSCRIBE</code> and <code>PUBLISH</code></p>
</blockquote>
<ul>
<li>客户端 A 订阅消息, 客户端 C 发布消息 如下图 ①②③</li>
<li>客户端 B 也订阅消息, 客户端 C 发布消息 如下图 ④⑤⑥ 此时客户端 B 并<strong>未收到订阅之前的消息</strong></li>
<li>客户端 A 退订消息, 客户端 C 发布消息 如下图 ⑦⑧⑨ 此时仅有客户端 B 收到了消息</li>
</ul>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201114933423.png"></p>
<h4 id="批量订阅与发布"><a href="#批量订阅与发布" class="headerlink" title="批量订阅与发布"></a>批量订阅与发布</h4><blockquote>
<p>涉及指令: <code>PUBSUB NUMPAT</code> and <code>PUNSUBSCRIBE</code></p>
</blockquote>
<ul>
<li>查看当前订阅模式的数量 当前为 0 如下图 ①</li>
<li>订阅 <code>a* b* c*</code> 三种模式 如下图 ②</li>
<li>再次查看订阅模式的数量 如下图 ③</li>
<li>发布消息, 客户端通过订阅模式的方式接收 如图 ④⑤⑥⑦</li>
<li>退订 <code>PUNSUBSCRIBE a* b* c*</code> 这个参数在不同的客户端下有不同的表现, 此处不做展示了就</li>
</ul>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201133834586.png"></p>
<h4 id="查看订阅与发布系统状态"><a href="#查看订阅与发布系统状态" class="headerlink" title="查看订阅与发布系统状态"></a>查看订阅与发布系统状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看订阅模式的数量 (订阅模式的数量而不是客户端的数量)。</span><br><span class="line">PUBSUB NUMPAT</span><br><span class="line"># 查看给定频道的订阅者数量， 订阅模式的客户端不计算在内</span><br><span class="line">PUBSUB NUMSUB [channel-1 ... channel-N]</span><br><span class="line"># 活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。有pattern参数, 则只会返回与pattern参数相匹配的</span><br><span class="line">PUBSUB channels [pattern]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Redis 可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。仅代表我个人，不推荐使用该功能，专业的事情交给专业的中间件处理，redis 就做好分布式缓存功能</p>
</blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>发布的消息在 Redis 系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃</li>
<li>消息只管发送对于发布者而言消息是即发即失的，不管接收，也没有 ACK 机制，无法保证消息的消费成功。</li>
<li>以上的缺点导致 Redis 的 Pub&#x2F;Sub 模式就像个小玩具，在生产环境中几乎无用武之地，为此 Redis5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub&#x2F;Sub 更加的强大</li>
</ul>
<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>一句话来讲就是 <strong>主从复制</strong> , master 以写为主, slave 以读为主, 并且当 master 数据变化的时候，自动将新的数据异步同步到其它 slave 数据库。 下图是来自于官网的解释 <a target="_blank" rel="noopener" href="https://redis.io/docs/management/replication/">Redis replication | Redis</a></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201141151733.png"></p>
<h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
<li>容灾恢复</li>
<li>数据备份</li>
<li>水平扩容，可支持高并发</li>
</ul>
<h3 id="怎么用-5"><a href="#怎么用-5" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><strong>配从不配主</strong> 只需要修改从库的配置文件即可， 无须修改主库的配置文件</li>
<li><strong>权限问题</strong> 如果主库配置了密码， 则要将从库配置文件中 <code>masterauth</code> 参数配置为主库的密码, 否则主库会拒绝从库的请求</li>
<li><strong>基本的命令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>info replication</code></td>
<td>可以查看复制节点的主从关系和配置信息</td>
</tr>
<tr>
<td><code>replicaof 主库IP 主库端口</code></td>
<td>告诉当前的 Redis 服务器从哪个主库复制数据</td>
</tr>
<tr>
<td><code>replicaof no one</code></td>
<td>当前服务器将停止复制来自其他服务器的数据，并成为独立的主服务器。</td>
</tr>
<tr>
<td><code>SLAVEOF 192.168.1.100 6379</code></td>
<td>命令等同于 <code>replicaof </code> , 是旧版本的命令, 为兼容而保留的</td>
</tr>
<tr>
<td><code>SLAVEOF no one</code></td>
<td>命令等同于 <code>replicaof no one</code> , 是旧版本的命令, 为兼容而保留的</td>
</tr>
</tbody></table>
<h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><blockquote>
<p>如果使用三台虚拟机来启动三台 redis 服务, 电脑有点吃不消, 我们使用三个不同的端口号来模拟三台服务即可, 反正原理上大差不差</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/redis%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240222213914823.png"></p>
<h4 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h4><ol>
<li>开启 daemaonize yes</li>
<li>注释 bind 127.0.0.1</li>
<li>关闭 protected-mode no</li>
<li>指定端口</li>
<li>指定工作目录 备份会存放在该目录下 <code>dir /myredis/redis6381/backupfiles</code></li>
<li>修改 pid 文件名称,pidfile <code>/myredis/redis6381/run/redis_6381.pid</code></li>
<li>修改 log 文件名字,logfile <code>/myredis/redis6381/logs/redis_6381.log</code></li>
<li>设置 requirepass 密码</li>
<li>设置 dump.rdb 名字</li>
<li>开启 aof 备份 <code>appendonly yes</code></li>
<li>设置 aof 文件的备份文件夹，<code>appenddirname &quot;appendonlydir&quot;</code> , 这样配置的花 AOF 备份文件就在&#x2F;myredis&#x2F;redis6381&#x2F;backupfiles&#x2F;appendonlydir 文件夹下</li>
<li>设置 aof 文件名前缀， <code>appendfilename &quot;appendonly.aof&quot;</code></li>
<li><strong>如果是从机，则需要配置主机的通行证 masterauth，必须的</strong></li>
</ol>
<blockquote>
<p>拷贝三份配置文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6379.conf</span><br><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6380.conf</span><br><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6381.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240222214740056.png"></p>
<h4 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h4><blockquote>
<p>修改完三份配置文件后, 启动三个端口的服务, 如下动图我们可以发现, 在主服务 6379 上设置的 k1 和 k2, 均能在从服务上读取数据, 但是从服务拒绝写入数据</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/recording.gif"></p>
<h3 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240529232412978.png" alt="|480"></p>
<h4 id="主机停止服务"><a href="#主机停止服务" class="headerlink" title="主机停止服务"></a>主机停止服务</h4><p>默认情况下，master 服务挂掉之后，不会在 slave 节点中自动重选一个 master，redis 无法在对外提供写入服务，如果想要重启服务，需要人工干预。无人值守成为刚需。</p>
<h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><p>吹哨人巡查监控后台 master 主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务</p>
<p><strong>作用</strong>：</p>
<ul>
<li>监控 Redis 的运行状态，包括 master 和 slave</li>
<li>当 master 宕机，能够自动将从机切换成主机<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240530231114346.png" alt="|550"></li>
</ul>
<h3 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li>主从监控：监控主从 Redis 运行是否正常</li>
<li>消息通知：可以将故障转移的结果通知给客户端</li>
<li>故障转移：如果主机异常，则进行主从切换，将其中一个 salve 作为新的 master</li>
<li>配置中心：客户端可以通过哨兵来获取当前 redis 服务的主节点地址</li>
</ol>
<h3 id="怎么用-6"><a href="#怎么用-6" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="架构说明-1"><a href="#架构说明-1" class="headerlink" title="架构说明"></a>架构说明</h4><p>由于每一台虚拟机进启动一台 redis 的话，下图架构至少需要 6 台虚拟机，这样的话 16G 的内存有点吃不消，因此，如下图中的架构图所示，仅以端口号来对服务进行区分</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240530233523704.png" alt="|600"></p>
<h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h3><h4 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h4><p><code>sudo mkdir /myredis/sentinel26379</code></p>
<h4 id="配置-sentinel-conf-文件"><a href="#配置-sentinel-conf-文件" class="headerlink" title="配置 sentinel.conf 文件"></a>配置 sentinel.conf 文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line">logfile &quot;/myredis/sentinel26379/logs/sentinel26379.log&quot;</span><br><span class="line"></span><br><span class="line">pidfile /myredis/sentinel26379/run/sentinel26379.pid</span><br><span class="line"># 修改工作的目录</span><br><span class="line">dir /myredis/sentinel26379</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>

<h4 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h4><p>由于测试机器上安装了 docker，并且自动启动了 docker 容器，因此需要先关闭一下，避免冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/redis6379/conf/redis7_6379.conf</span><br><span class="line">redis-server /myredis/redis6380/conf/redis7_6380.conf</span><br><span class="line">redis-server /myredis/redis6381/conf/redis7_6381.conf</span><br></pre></td></tr></table></figure>

<p>测试主从复制正常</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601004628234.png" alt="|500"></p>
<h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel26379/conf/sentinel_26379.conf --sentinel</span><br><span class="line">redis-sentinel /myredis/sentinel26380/conf/sentinel_26380.conf --sentinel</span><br><span class="line">redis-sentinel /myredis/sentinel26381/conf/sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601010332809.png" alt="|540"></p>
<h4 id="测试哨兵自动切换的流程"><a href="#测试哨兵自动切换的流程" class="headerlink" title="测试哨兵自动切换的流程"></a>测试哨兵自动切换的流程</h4><p>首先，正常启动主机服务，从机服务，查看同步是否正常，如下图 ①-⑤，此时我们停止主机 6379 的服务，如下图步骤 ⑥，为了验证从机是否自动切换成主机，我们进行了步骤 ⑦ 和 ⑧，发现从机并没有切换为主机，当进行操作 ⑨ 的时候，我们可以发现 6380 显示的身份为 master，此时再进行写入操作，发现成功，并且数据同步到了 6381 机器上,如下图步骤 10-11(说明主机下线时，从机上位需要一定的时间)，当 6379 服务重新启动的时候，我们可以发现此时 6379 的身份已经变成了从机，至此哨兵切换主从机的步骤完成。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601011357939.png" alt="|900"></p>
<h4 id="对比配置文件"><a href="#对比配置文件" class="headerlink" title="对比配置文件"></a>对比配置文件</h4><p>senter</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601013211368.png"></p>
<h3 id="运行流程和选举原理"><a href="#运行流程和选举原理" class="headerlink" title="运行流程和选举原理"></a>运行流程和选举原理</h3><p>当一个主从配置中的 master 失效之后，sentinel 可以选举出一个新的 master 用于自动接替原 master 的工作，主从配置中的其他 redis 服务器自动指向新的 master 同步数据。般建议 sentinel 采取奇数台，防止某一台 sentinel 无法连接到 master 导致误切换</p>
<p>哨兵是禁军，哨兵 leader 是进军统帅，而选举则是发动政变，推举新的 master</p>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>哨兵节点的数量应该为多个，哨兵本身应该是集群，保证高可用</li>
<li>哨兵节点的数量应该为多个</li>
<li>各个哨兵节点的配置应一致</li>
<li>如果哨兵节点部署在 Docker 等容器里，尤其注意端口的正确映射</li>
<li>哨兵集群 + 主从复制，并不能保证数据零丢失</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h3 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h3><blockquote>
<p>为节省服务器资源，将会在同一台服务器上，不同端口下起六台服务。均位于 <code> /myredis/cluster</code> 文件夹下</p>
</blockquote>
<h4 id="3-主-3-从的集群配置"><a href="#3-主-3-从的集群配置" class="headerlink" title="3 主 3 从的集群配置"></a>3 主 3 从的集群配置</h4><p>^8208ce</p>
<p><strong>配置相关文件及文件夹</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建此次配置的根路径</span><br><span class="line"> <span class="built_in">mkdir</span> /myredis/cluster</span><br><span class="line"> 创建所属的文件夹</span><br><span class="line"> <span class="built_in">mkdir</span> /myredis/cluster/redisCluster6381</span><br><span class="line"> 创建配置文件，配置文件的内容参考下面的conf代码块</span><br><span class="line">vim  /myredis/cluster/redisCluster6381/redisCluster6382/cluster.conf</span><br></pre></td></tr></table></figure>

<p><strong>cluster.conf 文件的内容，不同的端口文件只需要更换 ip 端口就好了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6386</span><br><span class="line">logfile &quot;/myredis/cluster/redisCluster6386/cluster.log&quot;</span><br><span class="line">pidfile /myredis/cluster/redisCluster6386/cluster.pid</span><br><span class="line">dir /myredis/cluster/redisCluster6386</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">requirepass 111111</span><br><span class="line">masterauth 111111</span><br><span class="line"> </span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6386.conf</span><br><span class="line">cluster-node-timeout 5000</span><br></pre></td></tr></table></figure>

<p><strong>启动 6 台 redis 实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/cluster/redisCluster6381/cluster.conf</span><br><span class="line">......</span><br><span class="line">redis-server /myredis/cluster/redisCluster6386/cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121000916770.png"></p>
<p><strong>构建集群关系</strong></p>
<p>构建集群关系的指令格式如下，其中 <code>--cluster-replicas 1 </code> 表示为每个 master 创建一个 slave 节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster create --cluster-replicas 1  127.0.0.1:6381  127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 127.0.0.1:6386</span><br></pre></td></tr></table></figure>

<p>执行构建集群的命令后，我们可以发现 <code>6381</code>，<code>6382</code> ，<code>6383</code> 为主节点，从节点依次为 <code>6384</code>，<code>6385</code>，<code>6386</code>。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121002035757.png"></p>
<p><strong>查验集群状态</strong><br>随便进入一台 redis 实例中去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看集群节点从属关系</span><br><span class="line">cluster nodes</span><br><span class="line">查看集群状态</span><br><span class="line">cluster info</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121003459885.png"></p>
<h4 id="集群读写"><a href="#集群读写" class="headerlink" title="集群读写"></a>集群读写</h4><blockquote>
<p>问题：为什么 set k1 v1 在 6383 端口是历下就能正常写入，而在 6381 就会报错</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121003818430.png"></p>
<p>由于 redis 使用了槽位分区，<code>k1</code> 经过 crc16 算法会落在 12706 的位置上，而该位置由实例 6383 负责。那么问题又来了，我们该如何解决这个问题呢?总不能每次都自己算一遍吧</p>
<blockquote>
<p>解决方案：进入实例时，新加 <code>-c</code> 参数优化路由</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121004337765.png"></p>
<p>当我们想知道一个键会落在那个槽位置时，可以选择使用 <code>cluster keyslot 键名称</code></p>
<h4 id="主从容错迁移"><a href="#主从容错迁移" class="headerlink" title="主从容错迁移"></a>主从容错迁移</h4><blockquote>
<p>如果此时一台 6381 的主机停止服务，可能是发生宕机，也可能是发生其他因素导致需要停止该服务，那么会发生什么现象?</p>
</blockquote>
<p>我们在模拟宕机之前，6381 为主机，其从机为 6385，当我们手动停止 6381 的服务，再次查看集群状态，我们可以发现 6381 的状态标识已经变换成了 fail，而 6385 的角色从 slave 转换成了 master</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121234211822.png"></p>
<p> 我们模拟宕机问题处理完毕，重启 6381 服务 <code> redis-server /myredis/cluster/redisCluster6381/cluster.conf</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121234951860.png"></p>
<p>查看集群状态，我们可以发现 6381 服务并未恢复到主机的地位，而是变成了 6385 的从机</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121235107880.png"></p>
<p>设想我们 6381 服务器的性能较好，希望让其担任主机的角色，6385 成为其从机，我们应该如何调整节点的从属呢?</p>
<p>在从节点上执行 <code>CLUSTER FAILOVER</code> 命令，将启动手动故障转移过程</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122000241907.png"></p>
<blockquote>
<p><strong>注意</strong> 由于主机宕机，切换成从机上位需要一定的时间，如果此时刚好有其主机负责的槽位接收到了客户端请求，会响应给客户端请求响应失败，如果主机接收到了数据，未来得及同步到从机中去，立刻发生了宕机，则会导致数据的丢失。因此主从集群也<strong>无法保证数据的强一致性</strong></p>
</blockquote>
<h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><blockquote>
<p>随着业务量的增加，对集群需要进行扩容，在原有集群的基础上再增加两台 redis 实例，端口号分别为 6387 和 6388。分别是一主一从</p>
</blockquote>
<p>先启动两个 redis 实例，与之前 6 个服务启动 redis 实例的方式相同。内容参考 <a href="Redis%E5%B0%8F%E5%86%8C.md#%5E8208ce">三主三从集群配置</a> 我们可以发现，6387 和 6388 服务启动后并未直接加入集群中去</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122205053293.png"></p>
<p>将新增的 6387 节点作为 master 加原集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 密码 --cluster add-node 新增节点ip:端口 引路机器ip:端口</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122205954970.png"></p>
<p>此时我们检查集群状况 <code>redis-cli -a 密码 --cluster check 真实ip地址:端口</code> 可以发现，新增加进来的 6387 节点虽然被分配为了主节点，但是并没有负责的槽位</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122210450449.png"></p>
<p>使用 <code>redis-cli -a 密码 --cluster reshard IP地址:端口号</code> 重新分派槽位号。在执行重新分派的指令之后，程序会询问你要重新分派多少槽位，以及这些槽位要重新分配给谁，以及从哪些节点迁移槽位 (all 代表所有节点)。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122211537084.png"></p>
<p>为新增的主节点添加从节点 6388</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- redis-cli -a 密码 --cluster add-node 新slaveip:端口  引路节点ip:端口 --cluster-slave --cluster-master-id 新主机节点ID </span><br><span class="line">redis-cli -a 111111 --clusetr add-node 127.0.0.1:6388 127.0.0.1:6384 --cluster-slave --cluster-master-id db03f008a93e4e878fd9d071090ecb3f72ad9cbe</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122212626161.png"></p>
<p>确定从节点加入完成后，我们检查一些当前集群状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster check 127.0.0.1:6381 </span><br></pre></td></tr></table></figure>

<p>根据下图我们可以看到，6388 节点已经成功加入集群，并且成为了 6377 的从节点</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122212846952.png"></p>
<h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><blockquote>
<p>集群既然能扩容，也相应的能缩容，我们现在将 6388 个 6387 两个节点从集群中移除</p>
</blockquote>
<p>移除集群节点前，先要获取节点的 ID</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122213545920.png"></p>
<p>直接执行删除从节点的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  redis-cli -a 密码 --cluster del-node 从机ip:端口 从机节点ID</span><br><span class="line">redis-cli -a 111111 --cluster  del-node  127.0.0.1:6388 475638d51e2be82d3db552325e89b9ca5da5e83d</span><br></pre></td></tr></table></figure>

<p>我们使用同样的方式删除主节点，可以发现系统会提示我们 6387 下仍有数据，让我们重新分派槽位号之后再试</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122213935037.png"></p>
<p>按照提示，我们手动地在 Redis 集群中重新分配哈希槽，执行下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster reshard 127.0.0.1:6387</span><br></pre></td></tr></table></figure>

<p>重新分配哈希槽的过程无非是，分配多少个哈希槽，由谁分出来，给谁的一个过程</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122214752427.png"></p>
<p>此时我们再次执行移除节点 6387 的指令，显示移除成功</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122215021973.png"></p>
<p>再次查看集群状况，我们可以发现集群状态再次变成了三主三从，不同点是，6381 节点负责了 8192 个槽位，这是因为我们将 6387 所有的槽位均分配给了 6381 的原因。至此我们实现了集群的缩容</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122215117956.png"></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote>
<p>不在同一个 slot 槽下的多键操作支持不好，需要使用通用占位符</p>
</blockquote>
<p>使用 mset 直接操作 三个 key，提示这些 key 的哈希不在同一个槽位下</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220037410.png"></p>
<p>因此我们需要使用哈希标签 <code>&#123;&#125;</code>，用于确保这组键会被分到一起 <img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220208881.png"></p>
<p>同样，我们使用 mget 的时候，也会遇到这种问题，也是使用哈希标签来解决问题</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220340548.png"></p>
<blockquote>
<p>现在集群架构是 3 主 3 从的 集群 r 由 3 个 master 平分 16384 个 slot，每个 master 的小集群负责 1&#x2F;3 的 slot，对应一部分数据。<strong>cluster-require-full-coverage：</strong> 默认值 yes , 即需要集群完整性，方可对外提供服务 通常情况，如果这 3 个小集群中，任何一个（1 主 1 从）挂了，你这个集群对外可提供的数据只有 2&#x2F;3 了， 整个集群是不完整的， redis 默认在这种情况下，是不会对外提供服务的。如果你的诉求是，集群不完整的话也需要对外提供服务，需要将该参数设置为 no，不是很建议这样做</p>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.com.cn/documentation.html">redis 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">Redis 命令中心）</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lei-ctyh.github.io">Zhang Lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lei-ctyh.github.io/2024/12/09/archive/Redis%E5%B0%8F%E5%86%8C/">https://lei-ctyh.github.io/2024/12/09/archive/Redis%E5%B0%8F%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lei-ctyh.github.io" target="_blank">知了</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE-redis/">数据/redis</a></div><div class="post-share"><div class="social-share" data-image="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/09/archive/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/" title="Obsidian插件汇总"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Obsidian插件汇总</div></div><div class="info-2"><div class="info-item-1">Webpage HTML Export ❗❗❗ 该插件必须置顶, 强烈推荐  插件简介导出你的 markdown 文档成 HTML，毕竟不是所有人的电脑上都有 typora 或者 obsidian 这类的 markdown 编辑器, 但是所有人的电脑上都有浏览器呀 🎣 插件配置 该插件配置项较多，但大部分参数均可按照默认值设置。我本人在使用时仅调整了了 嵌入配置，仅在此处列举比较关键的几项配置  页面功能配置 Page Feature 英文配置截图    Page Feature 中文配置截图   页面行为配置 Page Behaviors 英文配置截图    Page Behaviors 中文配置截图   嵌入配置简单在这讲一下嵌入配置是个什么东西，先说结论，再讲原理  结论：下图中的三个配置全部打开，导出文件时就会仅导出一个 html 文件，否则将会多导出一个依赖文件。 原理：该插件在生成 html 时，会根据下面的参数来判断是否把 js 和 css 代码导入到 html。这些 js 和 css 配置可能是有很大一部分是重复的，也就是说不一样的文章可以复用同一个 js 和...</div></div></div></a><a class="pagination-related" href="/2024/12/09/archive/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/" title="SqlManger开发文档"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SqlManger开发文档</div></div><div class="info-2"><div class="info-item-1"> 教程地址 PyQt5 教程 (w3schools.cn)  开发记录创建项目 新建 python 项目, 环境选择新的 venv 环境   安装必要依赖 当前依赖为项目新增依赖, 后续可能会随开发进行更新  12345678910# 提供了与 Python 3.5 或更高版本兼容的 32 位或 64 位架构的 wheelspip3 install PyQt5# 要安装 Qt Designer 等开发工具以支持 PyQt5 wheelspip3 install pyqt5-tools# 安装链接mysql所需依赖pip3 install pymysql# 链接mysql时所用到的加密方式pip3 install cryptography# 美化包依赖, 拉取依赖时, 不能使用豆瓣源, 豆瓣源没有这个依赖pip3 install qdarkstyle   如果直接使用官方镜像源出现安装失败的情况, 可以考虑国内的镜像源  1234# 清华源pip3 install &#123;package&#125; -i...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://images.pexels.com/photos/4709285/pexels-photo-4709285.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhang Lei</div><div class="author-info-description">路漫漫其修远兮，吾将上下而求索</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lei-ctyh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:2468341590@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://www.cnblogs.com/aaalei" target="_blank" title="CnBlog"><i class="fa-solid fa-rss" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">该网站由 lei-ctyh 维护，欢迎访问！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Redis"><span class="toc-number">1.</span> <span class="toc-text">安装 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85-GCC-%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text">判断是否安装 GCC 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">修改配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">启动服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">链接服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.6.</span> <span class="toc-text">退出客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.7.</span> <span class="toc-text">停止服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis 十大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-%E9%94%AE"><span class="toc-number">2.1.</span> <span class="toc-text">Key(键)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">String（字符串）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">List（列表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">Hash（哈希）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">总体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">持久化的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB"><span class="toc-number">3.2.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">是什么, 能干嘛</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B0%E6%97%A7%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">配置文件新旧版本说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%BF%AB%E7%85%A7%E4%BF%9D%E5%AD%98"><span class="toc-number">3.2.1.2.2.</span> <span class="toc-text">自动触发快照保存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%BF%AB%E7%85%A7%E4%BF%9D%E5%AD%98"><span class="toc-number">3.2.1.2.3.</span> <span class="toc-text">手动触发快照保存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Lastsave"><span class="toc-number">3.2.1.2.4.</span> <span class="toc-text">Lastsave</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">优势及注意点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">劣势及注意点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">模拟数据丢失</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BF%AE%E5%A4%8D-Dump-%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">检查修复 Dump 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%BF%AB%E7%85%A7%E4%BF%9D%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">触发快照保存的情况总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%BF%AB%E7%85%A7-%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98"><span class="toc-number">3.2.1.8.</span> <span class="toc-text">禁用快照 (自动保存)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.1.9.</span> <span class="toc-text">RDB 配置项详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.1.10.</span> <span class="toc-text">一图总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF"><span class="toc-number">3.2.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">是什么, 能干嘛</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">AOF 持久化的工作流程图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E4%B8%89%E7%A7%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">AOF 三种同步的写回策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-1"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.2.4.1.</span> <span class="toc-text">配置文件说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E6%88%90-AOF-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.4.2.</span> <span class="toc-text">生成 AOF 备份文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D-AOF-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.4.3.</span> <span class="toc-text">异常恢复 AOF 备份文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">优劣势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">AOF 重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.2.6.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.6.2.</span> <span class="toc-text">触发机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-%E4%BB%85%E6%BC%94%E7%A4%BA%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">3.2.2.6.3.</span> <span class="toc-text">案例演示 (仅演示自动触发)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.6.4.</span> <span class="toc-text">重写原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.2.7.</span> <span class="toc-text">AOF 配置项详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.2.8.</span> <span class="toc-text">一图总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-AOF-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">RDB+AOF 混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">官网建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-Vs-AOF"><span class="toc-number">3.3.2.</span> <span class="toc-text">RDB Vs AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E5%85%B1%E5%AD%98"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">能否共存?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%81%E9%AB%98"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">两者同时存在时的优先级谁高?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">数据恢复的顺序和加载流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">3.3.3.</span> <span class="toc-text">如何选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-AOF-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.4.</span> <span class="toc-text">RDB + AOF 混合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">开启混合模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE-%E8%A7%A6%E5%8F%91%E9%87%8D%E5%86%99"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">写入数据, 触发重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">纯缓存模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">4.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">4.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1-VS-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">Redis 事务 VS 数据库事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-number">4.3.1.</span> <span class="toc-text">数据库事务及特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.3.2.</span> <span class="toc-text">Redis 的特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-2"><span class="toc-number">4.4.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.1.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="toc-number">4.4.2.</span> <span class="toc-text">正常执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.4.3.</span> <span class="toc-text">放弃事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90"><span class="toc-number">4.4.4.</span> <span class="toc-text">全体连坐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB"><span class="toc-number">4.4.5.</span> <span class="toc-text">冤头债主</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watch-%E7%9B%91%E6%8E%A7"><span class="toc-number">4.4.6.</span> <span class="toc-text">Watch 监控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%AE%A1%E9%81%93"><span class="toc-number">5.</span> <span class="toc-text">Redis 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">5.1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%94%B1%E6%9D%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">面试题由来</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">5.2.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-3"><span class="toc-number">5.3.</span> <span class="toc-text">怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.1.</span> <span class="toc-text">Pipeline 与原生批量命令对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.2.</span> <span class="toc-text">Pipeline 与事务对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">6.</span> <span class="toc-text">Redis 发布与订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.1.</span> <span class="toc-text">学习定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">6.2.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">6.3.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-4"><span class="toc-number">6.4.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">6.4.2.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A2%E9%98%85-%E9%80%80%E8%AE%A2-%E5%8F%91%E5%B8%83"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">订阅&#x2F;退订&#x2F;发布</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">6.4.3.</span> <span class="toc-text">批量订阅与发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">6.4.4.</span> <span class="toc-text">查看订阅与发布系统状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A4%8D%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">Redis 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-2"><span class="toc-number">7.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-5"><span class="toc-number">7.3.</span> <span class="toc-text">怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-1"><span class="toc-number">7.4.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">7.4.1.</span> <span class="toc-text">架构说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">7.4.2.</span> <span class="toc-text">文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%BC%94%E7%A4%BA"><span class="toc-number">7.4.3.</span> <span class="toc-text">操作演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.5.</span> <span class="toc-text">原理和流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.6.</span> <span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="toc-number">7.6.1.</span> <span class="toc-text">复制延时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.6.2.</span> <span class="toc-text">主机停止服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%93%A8%E5%85%B5"><span class="toc-number">8.</span> <span class="toc-text">Redis 哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-5"><span class="toc-number">8.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-3"><span class="toc-number">8.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-6"><span class="toc-number">8.3.</span> <span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">架构说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-2"><span class="toc-number">8.4.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">8.4.1.</span> <span class="toc-text">创建相关文件夹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-sentinel-conf-%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.2.</span> <span class="toc-text">配置 sentinel.conf 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">8.4.3.</span> <span class="toc-text">启动主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5"><span class="toc-number">8.4.4.</span> <span class="toc-text">启动哨兵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%93%A8%E5%85%B5%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">8.4.5.</span> <span class="toc-text">测试哨兵自动切换的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.6.</span> <span class="toc-text">对比配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8C%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">运行流程和选举原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.6.</span> <span class="toc-text">使用建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-number">9.</span> <span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-3"><span class="toc-number">9.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BB-3-%E4%BB%8E%E7%9A%84%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.1.</span> <span class="toc-text">3 主 3 从的集群配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%86%99"><span class="toc-number">9.1.2.</span> <span class="toc-text">集群读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E8%BF%81%E7%A7%BB"><span class="toc-number">9.1.3.</span> <span class="toc-text">主从容错迁移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-number">9.1.4.</span> <span class="toc-text">集群扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="toc-number">9.1.5.</span> <span class="toc-text">集群缩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">9.2.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">10.</span> <span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/31/%E8%88%86%E6%83%85%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/" title="舆情分析项目分析">舆情分析项目分析</a><time datetime="2025-03-31T00:46:20.000Z" title="发表于 2025-03-31 08:46:20">2025-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/18/archive/PGSQL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="PGSQL基本概念">PGSQL基本概念</a><time datetime="2025-03-18T03:08:52.000Z" title="发表于 2025-03-18 11:08:52">2025-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/10/archive/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/" title="HashMart开发文档">HashMart开发文档</a><time datetime="2024-12-10T01:24:50.000Z" title="发表于 2024-12-10 09:24:50">2024-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/10/archive/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/" title="相对路径的使用">相对路径的使用</a><time datetime="2024-12-10T01:24:50.000Z" title="发表于 2024-12-10 09:24:50">2024-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/10/archive/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/" title="Dbeaver工具手册">Dbeaver工具手册</a><time datetime="2024-12-10T01:24:46.000Z" title="发表于 2024-12-10 09:24:46">2024-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zhang Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>