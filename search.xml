<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ActiveMQ</title>
    <url>/2024/12/09/archive/ActiveMQ/</url>
    <content><![CDATA[<h2 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h2><h3 id="MQ-种类和对比"><a href="#MQ-种类和对比" class="headerlink" title="MQ 种类和对比"></a>MQ 种类和对比</h3><blockquote>
<p>MQ 就是消息中间件。MQ 是一种理念，ActiveMQ 是 MQ 的落地产品。不管是哪款消息中间件，都有如下一些技术维度：</p>
</blockquote>
<p><img src="/assets/ActiveMQ/image-20240408221948862.png" alt="|560"></p>
<blockquote>
<p>MQ 消息的详细比较</p>
</blockquote>
<p><img src="/assets/ActiveMQ/image-20240408222125860.png"></p>
<blockquote>
<p>各类 MQ 的擅长领域</p>
</blockquote>
<table>
<thead>
<tr>
<th>MQ 种类</th>
<th>变成语言</th>
<th>擅长领域</th>
</tr>
</thead>
<tbody><tr>
<td>kafka</td>
<td>scala</td>
<td>大数据领域的主流 MQ。</td>
</tr>
<tr>
<td>rabbitmq</td>
<td>erlang</td>
<td>基于 erlang 语言，不好修改底层，不好查找问题的原因，不建议选用</td>
</tr>
<tr>
<td>rocketmq</td>
<td>java</td>
<td>适用于大型项目。适用于集群</td>
</tr>
<tr>
<td>activemq</td>
<td>java</td>
<td>适用于中小型项目</td>
</tr>
</tbody></table>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>面向消息的中间件（message-oriented middleware）MOM 能够很好的解决以上问题。是指利用高效可靠的消息传递机制与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型在分布式环境下提供应用解耦，弹性伸缩，冗余存储、流量削峰，异步通信，数据同步等功能。</p>
<p>大致的过程是这样的：发送者把消息发送给消息服务器，消息服务器将消息存放在若干队列&#x2F;主题 topic 中，在合适的时候，消息服务器回将消息转发给接受者。在这个过程中，发送和接收是异步的，也就是发送无需等待，而且发送者和接受者的生命周期也没有必然的关系；尤其在发布 pub&#x2F;订阅 sub 模式下，也可以完成一对多的通信，即让一个消息有多个接受者。</p>
<p><img src="/assets/ActiveMQ/image-20240408224621057.png"></p>
<h2 id="如何安装与查看控制台"><a href="#如何安装与查看控制台" class="headerlink" title="如何安装与查看控制台"></a>如何安装与查看控制台</h2><h3 id="Linux-系统直接安装"><a href="#Linux-系统直接安装" class="headerlink" title="Linux 系统直接安装"></a>Linux 系统直接安装</h3><h4 id="检查-JAVA-环境"><a href="#检查-JAVA-环境" class="headerlink" title="检查 JAVA 环境"></a>检查 JAVA 环境</h4><p>由于 ActiveMQ 是 java 编写的，因此需要有 jdk 的运行环境，检查 Java 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240408234356463.png"></p>
<h4 id="官网下载安装包"><a href="#官网下载安装包" class="headerlink" title="官网下载安装包"></a>官网下载安装包</h4><p>凡遇技术，必定官网 <a href="https://activemq.apache.org/">ActiveMQ (apache.org)</a></p>
<blockquote>
<p>注意：5.16.x 版本及以下支持 java8，5.17.x-5.18.x 需要 java11，6 版本则需要 java17</p>
</blockquote>
<p>下图中左侧是稳定版，右侧是开发版。</p>
<p><img src="/assets/ActiveMQ/image-20240408231212252.png"></p>
<p>按需要查找版本，此处贴一个 5.14.5 版本的链接 <a href="https://activemq.apache.org/components/classic/download/classic-05-14-05">ActiveMQ — ActiveMQ (apache.org)</a>，由于后续涉及集群的搭建，建议下载 Linux 的版本，毕竟没有见过 window 搭建集群的</p>
<p><img src="/assets/ActiveMQ/image-20240409182551469.png"></p>
<h4 id="上传安装包到-Linux-服务器"><a href="#上传安装包到-Linux-服务器" class="headerlink" title="上传安装包到 Linux 服务器"></a>上传安装包到 Linux 服务器</h4><p>安装包放到&#x2F;opt 目录下，放在哪个目录没有硬性要求</p>
<p><img src="/assets/ActiveMQ/image-20240408235316664.png"></p>
<h4 id="创建软件安装文件夹"><a href="#创建软件安装文件夹" class="headerlink" title="创建软件安装文件夹"></a>创建软件安装文件夹</h4><blockquote>
<p>软件安装文件夹，没有路径要求</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建软件安装的文件夹 -p 父目录不存在，则循环创建</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /software/activeMQ/</span><br></pre></td></tr></table></figure>

<h4 id="解压缩安装包"><a href="#解压缩安装包" class="headerlink" title="解压缩安装包"></a>解压缩安装包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-activemq-5.14.5-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409000433353.png"></p>
<h4 id="拷贝解压文件"><a href="#拷贝解压文件" class="headerlink" title="拷贝解压文件"></a>拷贝解压文件</h4><p>拷贝解压的软件到指定的安装文件夹，直接解压过去也是可以的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r apache-activemq-5.14.5 /software/activeMQ/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409000715651.png"></p>
<h4 id="普通启动"><a href="#普通启动" class="headerlink" title="普通启动"></a>普通启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先要跳转到 %软件的安装目录%/bin 目录下</span></span><br><span class="line"><span class="built_in">cd</span> /software/activeMQ/apache-activemq-5.14.5/bin</span><br><span class="line"><span class="comment"># 执行启动命令</span></span><br><span class="line">./activemq start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409001242335.png"></p>
<h4 id="启动时指定日志输出文件（重要"><a href="#启动时指定日志输出文件（重要" class="headerlink" title="启动时指定日志输出文件（重要)"></a>启动时指定日志输出文件（重要)</h4><p>activemq 日志默认的位置是在：%activemq 安装目录%&#x2F;data&#x2F;activemq.log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  activemq start  &gt;  %指定路径%</span></span><br><span class="line"> activemq start  &gt;  /usr/local/raohao/activemq.log</span><br></pre></td></tr></table></figure>

<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><blockquote>
<p>前情提要：Docker 需要已经安装，Docker 的使用参考 <a href="Docker%E5%B0%8F%E5%86%8C.md">Docker小册</a></p>
</blockquote>
<h4 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h4><blockquote>
<p>官方并没有为 ActiveMq 制作镜像，我们只能选择点赞数最多的一个下载使用。版本 5.14.3</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search activemq</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409173028743.png"></p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull webcenter/activemq</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409173703232.png"></p>
<h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images webcenter/activemq</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409174536552.png"></p>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><blockquote>
<p>也可以直接执行该指令，省去前面查询的步骤</p>
</blockquote>
<ul>
<li>61616 是 activemq 的容器使用端口（映射为 61617）</li>
<li>8161 是 web 页面管理端口（对外映射为 8161）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=<span class="string">&#x27;activemq5.14.3&#x27;</span> \</span><br><span class="line">     -d \</span><br><span class="line">  -p 8161:8161 \</span><br><span class="line">  -p 61616:61616 \</span><br><span class="line">  -e ACTIVEMQ_ADMIN_LOGIN=admin \</span><br><span class="line">  -e ACTIVEMQ_ADMIN_PASSWORD=123456 \</span><br><span class="line">  -v /app/activemq/data:/data/activemq \</span><br><span class="line">  -v /app/activemq/log:/var/log/activemq \</span><br><span class="line">  webcenter/activemq:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409175301711.png"></p>
<h3 id="检查服务是否启动"><a href="#检查服务是否启动" class="headerlink" title="检查服务是否启动"></a>检查服务是否启动</h3><h4 id="方式-1：检查进程"><a href="#方式-1：检查进程" class="headerlink" title="方式 1：检查进程"></a>方式 1：检查进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep activemq</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409015224394.png"></p>
<h4 id="方式-2：检查端口是否被占用"><a href="#方式-2：检查端口是否被占用" class="headerlink" title="方式 2：检查端口是否被占用"></a>方式 2：检查端口是否被占用</h4><p>ActiveMQ 默认端口是 61616</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 61616</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409181131261.png"></p>
<h4 id="方式-3：换种方式查看端口是否被占用"><a href="#方式-3：换种方式查看端口是否被占用" class="headerlink" title="方式 3：换种方式查看端口是否被占用"></a>方式 3：换种方式查看端口是否被占用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i:61616</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ActiveMQ/image-20240409181157709.png"></p>
<h3 id="启动异常排查"><a href="#启动异常排查" class="headerlink" title="启动异常排查"></a>启动异常排查</h3><h4 id="JDK-版本不满足当前-MQ-的需求"><a href="#JDK-版本不满足当前-MQ-的需求" class="headerlink" title="JDK 版本不满足当前 MQ 的需求"></a>JDK 版本不满足当前 MQ 的需求</h4><blockquote>
<p>现象描述：linux 系统直接安装的方式下，项目迟迟启动不起来，activemq.log 中也没有任何异常的抛出</p>
</blockquote>
<p><strong>排查结果：</strong> activeMQ5.17.x 版本要求的 JDK 版本为 11，而本地当前的 java 版本为 java8，因此导致的启动失败，这也是前面截图中部分操作的指令使用的是 6.1.1 做演示的原因</p>
<p><img src="/assets/ActiveMQ/image-20240409181844086.png"></p>
<h4 id="权限不够导致的-Web-页面无法启动"><a href="#权限不够导致的-Web-页面无法启动" class="headerlink" title="权限不够导致的 Web 页面无法启动"></a>权限不够导致的 Web 页面无法启动</h4><blockquote>
<p>现象描述：无法连接控制页面，但是服务确已经启动，<code>activemq console</code> 爆出权限不够的异常</p>
</blockquote>
<p><img src="/assets/ActiveMQ/image-20240409215527343.png"></p>
<p><strong>解决办法：</strong> 使用拥有足够权限的用户启动服务</p>
<h4 id="外部访问不到"><a href="#外部访问不到" class="headerlink" title="外部访问不到"></a>外部访问不到</h4><blockquote>
<p>现象描述：<code>curl 127.0.0.1:8161</code> 有返回的网页数据，但是在外部计算机中通过域名加端口，浏览器访问不到</p>
</blockquote>
<p>查看是否是 linux 防火墙导致 <a href="https://blog.csdn.net/jialexiaoxuan/article/details/134288680">linux系统中查看防火墙以及开放端口号命令_linux查看加入防火墙端口-CSDN博客</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<h3 id="访问控制台"><a href="#访问控制台" class="headerlink" title="访问控制台"></a>访问控制台</h3><blockquote>
<p>访问地址：http:&#x2F;&#x2F;% 主机 IP%:8161，默认用户名密码均为 admin，</p>
</blockquote>
<p><img src="/assets/ActiveMQ/image-20240409220439596.png"></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>官网：<a href="https://activemq.apache.org/">ActiveMQ (apache.org)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Dbeaver工具手册</title>
    <url>/2024/12/10/archive/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="安装-SQL-Formatter-插件"><a href="#安装-SQL-Formatter-插件" class="headerlink" title="安装 SQL Formatter 插件"></a>安装 SQL Formatter 插件</h2><blockquote>
<p>由于 Dbeaver 自带的 sql 美化确实有点难看，因此选择使用第三方插件进行 sql 的格式美化</p>
</blockquote>
<h3 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h3><p>系统需要安装 nodejs 环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240418102138568.png" alt="|470"></p>
<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>新建希望插件安装的文件夹，并在文件夹下执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sql-formatter</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240418104132910.png"></p>
<h3 id="配置-Dbeaver"><a href="#配置-Dbeaver" class="headerlink" title="配置 Dbeaver"></a>配置 Dbeaver</h3><p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240418111657891.png"></p>
<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240418111812734.png" alt="|600"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  -c &quot;D:\\soft\\sql-formatter\\node_modules\\sql-formatter\\config.json&quot; 属于格式化的配置文件选项</span></span><br><span class="line">node <span class="string">&quot;D:\\soft\\sql-formatter\\node_modules\\sql-formatter\\bin\\sql-formatter-cli.cjs&quot;</span> -c <span class="string">&quot;D:\\soft\\sql-formatter\\node_modules\\sql-formatter\\config.json&quot;</span> <span class="variable">$&#123;file&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Configuration-Options-配置选项"><a href="#Configuration-Options-配置选项" class="headerlink" title="Configuration Options 配置选项"></a>Configuration Options 配置选项</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sql&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;keywordCase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;upper&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;dataTypeCase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lower&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;linesBetweenQueries&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/language.md"><strong><code>language</code></strong></a> the SQL dialect to use (when using <code>format()</code>).<br><code>language</code>  要使用的 SQL 方言（使用  <code>format()</code>  时）。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/dialect.md"><strong><code>dialect</code></strong></a> the SQL dialect to use (when using <code>formatDialect()</code> since version 12).<br><code>dialect</code>  要使用的 SQL 方言（从版本 12 开始使用  <code>formatDialect()</code>  时）。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/tabWidth.md"><strong><code>tabWidth</code></strong></a> amount of indentation to use.<br><code>tabWidth</code>  要使用的缩进量。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/useTabs.md"><strong><code>useTabs</code></strong></a> to use tabs for indentation.<br><code>useTabs</code>  使用制表符进行缩进。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/keywordCase.md"><strong><code>keywordCase</code></strong></a> uppercases or lowercases keywords.<br><code>keywordCase</code>  大写或小写关键字。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/dataTypeCase.md"><strong><code>dataTypeCase</code></strong></a> uppercases or lowercases data types.<br><code>dataTypeCase</code>  大写或小写数据类型。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/functionCase.md"><strong><code>functionCase</code></strong></a> uppercases or lowercases function names.<br><code>functionCase</code>  大写或小写函数名称。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/identifierCase.md"><strong><code>identifierCase</code></strong></a> uppercases or lowercases identifiers. (<strong>experimental!</strong>)<br><code>identifierCase</code>  大写或小写标识符。（实验性！</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/indentStyle.md"><strong><code>indentStyle</code></strong></a> defines overall indentation style. (<strong>deprecated!</strong>)<br><code>indentStyle</code>  定义整体缩进样式。（已弃用！</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/logicalOperatorNewline.md"><strong><code>logicalOperatorNewline</code></strong></a> newline before or after boolean operator (AND, OR, XOR).<br><code>logicalOperatorNewline</code>  布尔运算符（AND、OR、XOR）之前或之后的换行符。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/expressionWidth.md"><strong><code>expressionWidth</code></strong></a> maximum number of characters in parenthesized expressions to be kept on single line.<br><code>expressionWidth</code>  括号表达式中要保留在单行上的最大字符数。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/linesBetweenQueries.md"><strong><code>linesBetweenQueries</code></strong></a> how many newlines to insert between queries.<br><code>linesBetweenQueries</code>  在查询之间插入多少个换行符。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/denseOperators.md"><strong><code>denseOperators</code></strong></a> packs operators densely without spaces.<br><code>denseOperators</code>  密集地打包运算符，没有空格。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/newlineBeforeSemicolon.md"><strong><code>newlineBeforeSemicolon</code></strong></a> places semicolon on separate line.<br><code>newlineBeforeSemicolon</code>  将分号放在单独的行上。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/params.md"><strong><code>params</code></strong></a> collection of values for placeholder replacement.<br><code>params</code>  占位符替换值的集合。</li>
<li><a href="https://github.com/sql-formatter-org/sql-formatter/blob/master/docs/paramTypes.md"><strong><code>paramTypes</code></strong></a> specifies parameter placeholders types to support.<br><code>paramTypes</code>  指定要支持的参数占位符类型。</li>
</ul>
<h2 id="复制格式化-Sql-为一行"><a href="#复制格式化-Sql-为一行" class="headerlink" title="复制格式化 Sql 为一行"></a>复制格式化 Sql 为一行</h2><h3 id="使用鼠标点击面板的方式"><a href="#使用鼠标点击面板的方式" class="headerlink" title="使用鼠标点击面板的方式"></a>使用鼠标点击面板的方式</h3><p>具体过程参考一下 gif 图即可</p>
<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/recording.gif" alt="|840"></p>
<h3 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h3><ol>
<li>选择中要复制的代码</li>
<li>使用快捷键 <code>ctrl</code> + <code>shift</code> +<code>C</code></li>
</ol>
<h2 id="快捷键优化"><a href="#快捷键优化" class="headerlink" title="快捷键优化"></a>快捷键优化</h2><h3 id="键位映射设置路径"><a href="#键位映射设置路径" class="headerlink" title="键位映射设置路径"></a>键位映射设置路径</h3><p>obsidian 的快捷键设置路径 <code>窗口| 首选项| 用户界面 |键</code> 选项卡下</p>
<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240422133542562.png" alt="|520"></p>
<p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240422133701768.png" alt="|520"></p>
<h3 id="快捷键优化项"><a href="#快捷键优化项" class="headerlink" title="快捷键优化项"></a>快捷键优化项</h3><p>建议所有的开发工具厂商的快捷键能不能和 IDEA 对齐一下颗粒度啊……</p>
<h4 id="注释快捷键"><a href="#注释快捷键" class="headerlink" title="注释快捷键"></a>注释快捷键</h4><p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240422133938544.png" alt="|480"></p>
<h4 id="格式化快捷键"><a href="#格式化快捷键" class="headerlink" title="格式化快捷键"></a>格式化快捷键</h4><p><img src="/assets/Dbeaver%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/image-20240422134059052.png" alt="|480"></p>
]]></content>
      <tags>
        <tag>工具/dbeaver</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker小册</title>
    <url>/2024/12/09/archive/Docker%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[<h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Docker 是一种开源的容器化平台，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是一种轻量级、独立、可执行的软件包，包含了运行一个应用所需的所有内容：代码、运行时环境、系统工具、系统库等。Docker 可以让开发者快速地构建、测试和部署应用程序，而无需担心跨环境的兼容性问题。</p>
<h3 id="传统虚拟机和容器"><a href="#传统虚拟机和容器" class="headerlink" title="传统虚拟机和容器"></a>传统虚拟机和容器</h3><blockquote>
<p>传统虚拟机（virtual machine）：</p>
</blockquote>
<p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如 VirtualBox、VMware 等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p>
<p>缺点：资源占用多、冗余步骤多、启动慢</p>
<blockquote>
<p>Linux 容器（Linux Container，简称 LXC）：</p>
</blockquote>
<p>Linux 容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行</p>
<blockquote>
<p>差异对比：</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>大小</td>
<td>一般为 Mb</td>
<td>一般为 Gb</td>
</tr>
<tr>
<td>速度</td>
<td>接近原生</td>
<td>比较慢</td>
</tr>
<tr>
<td>系统支持数量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li>应用程序容器化： Docker 可以将应用程序及其依赖项打包到一个容器中，使其在任何环境中都能以相同的方式运行，从而简化部署和维护。</li>
<li>开发环境管理： Docker 可以用于创建和管理开发环境，确保团队中的所有成员都使用相同的开发环境，避免由于环境差异而导致的问题。</li>
<li>持续集成和持续部署（CI&#x2F;CD）： Docker 可以与 CI&#x2F;CD 工具集成，实现自动化构建、测试和部署流程，提高开发团队的效率。</li>
<li>微服务架构： Docker 可以帮助将应用程序拆分为多个微服务，每个微服务都运行在自己的容器中，从而实现更好的可伸缩性和灵活性。</li>
<li>快速部署和扩展： Docker 可以快速部署新的容器实例，并根据需求扩展容器数量，以满足应用程序的需求。</li>
<li>资源隔离和安全性： Docker 提供了一定程度的资源隔离，使得不同容器之间的应用程序能够相互独立运行，提高安全性。</li>
</ol>
<p>总的来说，Docker 是一个非常灵活和强大的工具，可以帮助开发者和运维团队简化应用程序的开发、部署和管理过程。</p>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><h3 id="三个基本概念"><a href="#三个基本概念" class="headerlink" title="三个基本概念"></a>三个基本概念</h3><ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：由某特定的 docker 镜像的所有迭代版本组成的镜像仓库。仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>对象</td>
</tr>
<tr>
<td>镜像</td>
<td>类</td>
</tr>
</tbody></table>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>Docker 使用客户端 - 服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 守护进程运行在主机上，然后通过 Socket 连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320095558960.png"></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><blockquote>
<p>这一块刚接触有点难以理解，先有个大概印象就可以，后续再回头补充</p>
</blockquote>
<ol>
<li><p>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p>
</li>
<li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p>
</li>
<li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p>
</li>
<li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p>
</li>
<li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p>
</li>
<li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p>
</li>
<li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p>
</li>
</ol>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320095829501.png"></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Docker 镜像 (Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td>Docker 容器 (Container)</td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td>Docker 客户端 (Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>Docker 主机 (Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td>Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br><br>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br><br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。<br><br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过  &lt;仓库名&gt;:&lt;标签&gt;  的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以  latest  作为默认标签。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>关于 Docker 的安装，不同平台的安装方式不太一样，本文中以 <a href="https://docs.docker.com/engine/install/centos/">CentOS 系统安装</a> 为例，若是想在其他平台安装 Docker，可以 <a href="https://docs.docker.com/engine/install/">官网安装教程</a>，或者 <a href="https://docs.docker.com/engine/install/">菜鸟安装教程</a></p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 (64-bit) 上，要求系统为 64 位、Linux 系统内核版本为 3.8 以上，这里选用 Centos7.x</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前linux系统的发行版本</span></span><br><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br><span class="line"><span class="comment"># uname命令用于打印当前系统相关信息（内核版本号、和操作系统类型等）。</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318212342461.png"></p>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="安装-Gcc-环境"><a href="#安装-Gcc-环境" class="headerlink" title="安装 Gcc 环境"></a>安装 Gcc 环境</h3><p>gcc 几乎是开发环境下的必装，我们在安装 centerOS 系统时，在软件选择界面有勾选安装 [[]] 开发工具选项，会自动带上 gcc 环境，如果不确定是否应安装了 gcc 环境，可参考我的另一篇文章 <a href="Redis%E5%B0%8F%E5%86%8C.md">Redis 小册</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<h3 id="配置-Yum-资源库"><a href="#配置-Yum-资源库" class="headerlink" title="配置 Yum 资源库"></a>配置 Yum 资源库</h3><blockquote>
<p>安装 <code>yum-config-manager</code>：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum-util提供yum-config-manager功能</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318221558649.png"></p>
<blockquote>
<p>配置 docker 的资源库地址：</p>
</blockquote>
<ol>
<li>官方地址：（比较慢，不推荐），如果配置的镜像地址是国外的，很容易出现在拉取镜像时链接超时</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在yum资源库中添加docker资源库</span></span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>阿里云镜像地址：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318222200485.png"></p>
<p>阿里云官网提供了很多资源镜像，镜像地址：<code>https://mirrors.aliyun.com</code>，进入之后可以选择自己需要的资源进行配置</p>
<blockquote>
<p>创建缓存（可选）</p>
</blockquote>
<p>此处好像涉及 linux 的基础知识，执行了以下命令，后续下载会快一些。暂且在这留个坑吧！ TODO</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318222402380.png"></p>
<h3 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h3><blockquote>
<p>安装最新版本的 Docker 引擎、Docker 客户端：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line"><span class="built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要安装制定版本：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="comment"># sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line"><span class="built_in">sudo</span> yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223305552.png"></p>
<p>安装过程中会出现两次是否继续的选项，按照提示输入 <code>y</code>，然后点击 <code>Enter</code> 即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223517816.png"></p>
<p>安装完成的提示：</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318223611540.png"></p>
<h3 id="启动-Docker-引擎"><a href="#启动-Docker-引擎" class="headerlink" title="启动 Docker 引擎"></a>启动 Docker 引擎</h3><p>如果没有启动 Docker 引擎，那么执行 <code>docker version</code> 查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker 引擎客户端）的版本号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h3 id="配置用户权限"><a href="#配置用户权限" class="headerlink" title="配置用户权限"></a>配置用户权限</h3><blockquote>
<p>案例演示（异常分析）：</p>
</blockquote>
<p>未启动 Docker 引擎的情况下查看 <code>docker version</code>，我们只能看到客户端的版本信息，然而启动 Docker 服务时，我们输入了一次用户密码，发现由于权限问题仍然没有启动 Docker 引擎。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318224158376.png"></p>
<p>解决方案如下：</p>
<ul>
<li>方案 ①：使用 sudo 获取管理员权限，运行 docker 命令。</li>
<li>方案 ②：docker 守护进程启动的时候，会默认赋予名字为 docker 的用户组读写 Unix socket 的权限，因此只要创建 docker 用户组，并将当前用户加入到 docker 用户组中，那么当前用户就有权限访问 Unix socket 了，进而也就可以执行 docker 相关命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加docker用户组</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment">#将登陆用户加入到docker用户组中  sudo gpasswd -a $USER docker</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a su docker</span><br><span class="line"><span class="comment">#更新用户组</span></span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>

<p>此处使用方案 ② 来解决问题，下图中可以看到 <code>docker version</code> 指令已经可以看到能给显示出 Docker 引擎的信息了。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318225940978.png"></p>
<h3 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h3><p>会安装就要会卸载，该部分就不做演示了，刚安装就卸载怪麻烦的，卸载 Docker 主要为以下几步：</p>
<blockquote>
<p>关闭服务：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>yum</code> 卸载 Docker 引擎：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除镜像、容器、卷、自定义配置等文件：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="运行-HelloWorld-测试"><a href="#运行-HelloWorld-测试" class="headerlink" title="运行 HelloWorld 测试"></a>运行 HelloWorld 测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240318231133329.png"></p>
<h3 id="Docker-下载加速"><a href="#Docker-下载加速" class="headerlink" title="Docker 下载加速"></a>Docker 下载加速</h3><blockquote>
<p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，我们此处使用阿里云的镜像加速器，若考虑使用其他的云服务商家，可以参考以下链接：<a href="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker 镜像加速</a></p>
</blockquote>
<p>访问该网址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务 (aliyun.com)</a>，登入阿里云，即可看到以下界面</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320012654699.png"></p>
<p>没啥好啰嗦的，按照文档来就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;&#123;此地址是上方复制的地址&#125;&quot;</span>]</span><br><span class="line">&#125; EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="启动类命令"><a href="#启动类命令" class="headerlink" title="启动类命令"></a>启动类命令</h3><blockquote>
<p>启动 docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止 Docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启 Docker：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看状态：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置开机自启：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例实操</p>
</blockquote>
<p>我们在停止 docker 发现给出了一个警告，警告的大概意思为虽然 docker 服务停掉了，但是他仍然可以被 <code>docker.socket</code> 服务唤醒。也就是说只要 <code>docker.socket</code> 只要没有停止，只要输入 docker 指令都会得到响应，不得不说很银杏</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240320010659092.png"></p>
<h3 id="帮助类命令"><a href="#帮助类命令" class="headerlink" title="帮助类命令"></a>帮助类命令</h3><blockquote>
<p>查看 Docker 版本：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 Docker 概要信息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 Docker 总体帮助文档：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 docker 具体命令帮助文档：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker 具体命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="列出本地主机上的镜像"><a href="#列出本地主机上的镜像" class="headerlink" title="列出本地主机上的镜像"></a>列出本地主机上的镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326214342362.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>-a</code>：列出所有镜像（含历史镜像）</li>
<li><code>-q</code>：只显示镜像 ID</li>
<li><code>-f</code>：过滤</li>
</ul>
<p><strong>结果参数:</strong></p>
<ul>
<li><code>REPOSITORY</code>：表示镜像的仓库源</li>
<li><code>TAG</code>：镜像的标签（版本号）</li>
<li><code>IMAGE ID</code>：镜像 ID</li>
<li><code>CREATED</code>：镜像创建时间</li>
<li><code>SIZE</code>：镜像大小</li>
</ul>
<blockquote>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
</blockquote>
<h4 id="在远程仓库中搜索镜像"><a href="#在远程仓库中搜索镜像" class="headerlink" title="在远程仓库中搜索镜像"></a>在远程仓库中搜索镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326215407409.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>-f</code>：过滤</li>
<li><code>--limit 数量</code>：只展示前几项</li>
</ul>
<p><strong>结果参数：</strong></p>
<ul>
<li><code>NAME</code>:  镜像仓库源的名称</li>
<li><code>DESCRIPTION</code>:  镜像的描述</li>
<li><code>OFFICIAL</code>:  是否 docker 官方发布</li>
<li><code>stars</code>:  类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li><code>AUTOMATED</code>:  自动构建</li>
</ul>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称[:tag]</span><br></pre></td></tr></table></figure>

<p>不加 tag 时，默认下载最新的镜像（即 tag 为 <code>latest</code>）。镜像下有多少 tag 需要去 <a href="https://hub.docker.com/">Docker Hub Container Image Library </a> 查询</p>
<blockquote>
<p>案例实操：</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326221107956.png"></p>
<h4 id="查看镜像-容器-数据卷所占的空间"><a href="#查看镜像-容器-数据卷所占的空间" class="headerlink" title="查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326222046176.png"></p>
<p><strong>结果参数：</strong></p>
<ul>
<li><code>Images</code>：总共有多少镜像</li>
<li><code>Containers</code>：运行了多少个实例</li>
<li>TODO 剩下两个待补充</li>
</ul>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>删除单个镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名称/ID</span><br></pre></td></tr></table></figure>

<p>删除多个镜像，可以使用空格分隔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br></pre></td></tr></table></figure>

<p>删除全部镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi  -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>-f：强制删除所有镜像，包含运行中的。</li>
</ul>
<blockquote>
<p>案例实操：</p>
</blockquote>
<p>由于功能并不复杂，仅仅演示删除单个的即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326221010366.png"></p>
<h4 id="查询镜像版本号"><a href="#查询镜像版本号" class="headerlink" title="查询镜像版本号"></a>查询镜像版本号</h4><blockquote>
<p>登入 <a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a> 网站，搜索希望查找的镜像，需要一点点神秘力量</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221420629.png"></p>
<blockquote>
<p>点击查看详情</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221525871.png"></p>
<blockquote>
<p>点击查看版本号</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407221628788.png"></p>
<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>仓库名、标签都是 <code>&lt;none&gt;</code> 的镜像，俗称虚悬镜像（dangling image）。docker 再进行构建失败的时候可能出现。</p>
<h3 id="容器命令-基础"><a href="#容器命令-基础" class="headerlink" title="容器命令 (基础)"></a>容器命令 (基础)</h3><blockquote>
<p>执行容器命令的前提是已经有了该容器的镜像。</p>
</blockquote>
<h4 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建 + 启动容器"></a>新建 + 启动容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [选项] IMAGE [命令] [参数...]</span><br></pre></td></tr></table></figure>

<p><strong>常用的参数：</strong></p>
<ul>
<li><code>--name</code>：为容器指定一个名称</li>
<li><code>-d</code>：后台运行容器并返回容器 ID，也即启动守护式容器</li>
<li><code>-i</code>：以交互模式（interactive）运行容器，通常与 <code>-t</code> 同时使用</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与 <code>-i</code> 同时使用。也即启动交互式容器（前台有伪终端，等待交互）</li>
<li><code>-e</code>：为容器添加环境变量</li>
<li><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口（不太常用）</li>
<li><code>-p</code>：指定端口映射（常用）</li>
</ul>
<p><strong><code>-p</code> 指定端口映射的几种不同形式：</strong></p>
<ul>
<li><code>-p hostPort:containerPort</code>：端口映射，例如 <code>-p 8080:80</code></li>
<li><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></li>
<li><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></li>
<li><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如 <code>-p 8080:80 -p 8888:3306</code></li>
</ul>
<h5 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h5><p>所谓启动交互式容器，简单点理解来说就是启动容器后，给你弹出一个输入指令的界面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -i 交互模式</span></span><br><span class="line"><span class="comment"># -t 分配一个伪输入终端tty</span></span><br><span class="line"><span class="comment"># ubuntu 镜像名称</span></span><br><span class="line"><span class="comment"># /bin/bash（或者bash） shell交互的接口, 此参数也可以不写，默认bash</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329222019959.png"></p>
<h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的后台运行模式。下面我们分别以守护式进程的方式启动 ubuntu 和 reids。我们可以发现 ubuntu 的启动其实是有问题的，没有启动起来, 具体的原因参考下文中的 <strong>Q&amp;A</strong>部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -d 代表容器以守护式方式启动</span></span><br><span class="line">docker run -d ubuntu</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329224244064.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -d 代表容器以守护式方式启动</span></span><br><span class="line"> docker run -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329230017821.png"></p>
<p><strong>Q&amp;A：</strong></p>
<blockquote>
<p><strong>Q：</strong> 我们以交互式容器的方式启动 ubuntu，系统明明响应了服务已启动，通过 <code>docker ps -a</code> 查看所有容器发现，启动的容器已经退出了，这是为什么呢???</p>
</blockquote>
<p><strong>A：</strong> Docker 容器后台运行,就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行 top，tail），就是会自动退出的。</p>
<p>上面那句话讲起来可能有点抽象，下图中是我们执行 <code>docker run -it ubuntu /bin/bash</code> 启动起来的 ubuntu 容器，我们通过 <code>ps -ef</code> 查看系统当前所有进程发现仅有两个进程再执行，一个是咱们的 bash 交互接口，一个是 ps 进程查询。也就是说，守护式启动 ubuntu 时，系统内根本就没有进程在执行，docker 就会认为系统无事可做，所以就退出了。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329225036381.png"></p>
<h4 id="列出当前容器"><a href="#列出当前容器" class="headerlink" title="列出当前容器"></a>列出当前容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240326231447166.png"></p>
<p><strong>常用参数：</strong></p>
<ul>
<li><code>-a</code>：列出当前所有正在运行的容器 + 历史上运行过的容器</li>
<li><code>-l</code>：显示最近创建的容器</li>
<li><code>-n</code>：显示最近 n 个创建的容器</li>
<li><code>-q</code>：静默模式，只显示容器编号</li>
</ul>
<p><strong>结果解析：</strong></p>
<ul>
<li><code>CONTAINER ID</code>：运行容器的 ID</li>
<li><code>IMAGE</code>：使用的镜像</li>
<li><code>COMMAND</code>：执行的命令，<code>bash</code> 和 <code>/bin/bash</code> 居多，后面可能还会补充</li>
<li><code>CREATED</code>：创建时间</li>
<li><code>STATUS</code>：当前状态</li>
<li><code>PORTS</code>：映射端口 提供 <code>-P</code> 和 <code>-p</code> 指定</li>
<li><code>NAMES</code>：当前容器的名称，可以通过 <code>--name &#123;希望叫的名字&#125;</code> 来指定名称，不然就会随机分配。</li>
</ul>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>退出容器其实是指的退出交互式容器的交互界面，通常有以下两种退出方式：① 交互界面输入 <code>exit</code> 指令, 退出后容器会停止; ② 输入 <code>ctrl</code> + <code>P</code> + <code>Q</code> ，退出后容器不会停止。</p>
<blockquote>
<p>案例演示：</p>
</blockquote>
<p>首先查看所有容器，交代出当前系统无容器在运行。交互式启动一个 ubuntu 容器，exit 退出，发现容器名为 brave_thompson 的容器使用的是 ubuntu 镜像，但是处于停止状态。再交互式启动一个 ubuntu 容器，此时输入快捷键 <code>Ctrl</code> + <code>P</code> +<code>Q</code> 退出，我们通过查看所有容器状态，发现容器名为 epic_ptolemy 的容器正在进行。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240329231754840.png"></p>
<h4 id="启动已经停止的容器"><a href="#启动已经停止的容器" class="headerlink" title="启动已经停止的容器"></a>启动已经停止的容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><blockquote>
<p>删除已经停止的容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>强制删除未停止的容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除全部容器 (叼毛高危操作，不学也罢)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line">docker ps -a -q | xargs docker <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>

<h4 id="设置容器自启动"><a href="#设置容器自启动" class="headerlink" title="设置容器自启动"></a>设置容器自启动</h4><blockquote>
<p>如果我们希望 docker 服务启动，就立刻启动某个容器，可以采取以下两种方案：</p>
</blockquote>
<p><strong>方案 1：</strong> 创建容器时设置 <code>--restart=always</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name 设置容器名 使用的镜像</span><br><span class="line">（上面命令  --name后面两个参数根据实际情况自行修改）</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 容器的重启策略如下：</span></span><br><span class="line"> --restart具体参数值详细信息：</span><br><span class="line">       no　　　　　　　 // 默认策略,容器退出时不重启容器；</span><br><span class="line">       on-failure　　  // 在容器非正常退出时（退出状态非0）才重新启动容器；</span><br><span class="line">       on-failure:3    // 在容器非正常退出时重启容器，最多重启3次；</span><br><span class="line">       always　　　　  // 无论退出状态是如何，都重启容器；</span><br><span class="line">       unless-stopped  // 在容器退出时总是重启容器，但是不考虑在 Docker 守护进程启动时就已经停止了的容器。</span><br></pre></td></tr></table></figure>

<p><strong>方案 2：</strong> 容器已经创建的情况下，更新 <code>--restart=always</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker update --restart=always 容器ID(或者容器名)</span><br></pre></td></tr></table></figure>

<h3 id="容器命令-重要"><a href="#容器命令-重要" class="headerlink" title="容器命令 (重要)"></a>容器命令 (重要)</h3><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<h4 id="进入正在进行的容器"><a href="#进入正在进行的容器" class="headerlink" title="进入正在进行的容器"></a>进入正在进行的容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器ID bashShell</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<p>以上两台命令均能重新进入容器内部，与之交互，区别在于：</p>
<ul>
<li><code>docker exec -it 容器ID bashShell</code> 命令进入的终端输入 <code>exit</code> 退出后，容器不会停止，原因是启动了新的进程 <strong>（推荐使用）</strong></li>
<li><code>docker attach 容器ID</code> 命令进入的容器内部，输入 <code>exit</code> 退出后，容器停止，并没有启动新的进程</li>
</ul>
<blockquote>
<p>案例演示</p>
</blockquote>
<p><strong>ubuntu 案例</strong></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403215810933.png"></p>
<p><strong>redis 案例</strong></p>
<p>🔍 疑问点：此处的 <code>redis-cli</code> 也输入 shell 接口吗?</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403221135498.png"></p>
<blockquote>
<p>总结：一般用 -d 后台启动的程序，再用 exec 进入对应容器实例</p>
</blockquote>
<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><p>容器内文件拷贝到宿主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p>宿主机文件拷贝到容器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p>第一步：创建并查看 hosttodocker.txt 文件；第二步执行对应的指令，演示中就是有写错指令导致拷贝失败的演示；第三步：拷贝成功后查看复制的文件</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403225756391.png"></p>
<h4 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h4><p><code>export</code>：导出容器的内容流作为一个 tar 归档文件（对应 <code>import</code> 命令）；</p>
<p><code>import</code>：从 tar 包中的内容创建一个新的文件系统再导入为镜像（对应 <code>export</code> 命令）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出 操作对象是容器</span></span><br><span class="line">docker <span class="built_in">export</span> 容器ID &gt; tar文件名</span><br><span class="line">docker <span class="built_in">export</span> aed61408780b &gt; myubuntu.tar</span><br><span class="line"><span class="comment"># 导入 cat tar文件的作用是将结果集通过管道符以流的形式传给下一个指令</span></span><br><span class="line"><span class="built_in">cat</span> tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例演示：</p>
</blockquote>
<p><strong>导出 ubuntu 容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> aed61408780b &gt; myubuntu.tar</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403231552658.png"></p>
<p><strong>删除当前 ubuntu 容器及镜像</strong></p>
<p>具体删除指令不再展示了，废话已经够多了</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403231700300.png"></p>
<p><strong>导入之前的 tar 文件作为镜像文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于之前是在/tmp路径下执行的导出，所以tar文件默认导出到了/tmp路径下</span></span><br><span class="line"><span class="built_in">cat</span> /tmp/myubuntu.tar | docker import - zhanglei/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p>导入完成后，我们可以发现，之前用于测试 <code>docker cp</code> 命令时的文件也被还原了。由此可以断定，导出的容器包含了当前容器状态下的所有内容。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403232358029.png"></p>
<h3 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h3><h4 id="所有命令示意图"><a href="#所有命令示意图" class="headerlink" title="所有命令示意图"></a>所有命令示意图</h4><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240403232643173.png"></p>
<h4 id="常用命令表格及中文解释"><a href="#常用命令表格及中文解释" class="headerlink" title="常用命令表格及中文解释"></a>常用命令表格及中文解释</h4><table>
<thead>
<tr>
<th>命令</th>
<th>全称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>attach</td>
<td>Attach to a running container</td>
<td>当前 shell 下 attach 连接指定运行镜像</td>
</tr>
<tr>
<td>build</td>
<td>Build an image from a Dockerfile</td>
<td>通过 Dockerfile 定制镜像</td>
</tr>
<tr>
<td>commit</td>
<td>Create a new image from a container changes</td>
<td>提交当前容器为新的镜像</td>
</tr>
<tr>
<td>cp</td>
<td>Copy files&#x2F;folders from the containers filesystem to the host path</td>
<td>从容器中拷贝指定文件或者目录到宿主机中</td>
</tr>
<tr>
<td>create</td>
<td>Create a new container</td>
<td>创建一个新的容器，同 run，但不启动容器</td>
</tr>
<tr>
<td>diff</td>
<td>Inspect changes on a container’s filesystem</td>
<td>查看 docker 容器变化</td>
</tr>
<tr>
<td>events</td>
<td>Get real time events from the server</td>
<td>从 docker 服务获取容器实时事件</td>
</tr>
<tr>
<td>exec</td>
<td>Run a command in an existing container</td>
<td>在已存在的容器上运行命令</td>
</tr>
<tr>
<td>export</td>
<td>Stream the contents of a container as a tar archive</td>
<td>导出容器的内容流作为一个 tar 归档文件<em>对应 import</em></td>
</tr>
<tr>
<td>history</td>
<td>Show the history of an image</td>
<td>展示一个镜像形成历史</td>
</tr>
<tr>
<td>images</td>
<td>List images</td>
<td>列出系统当前镜像</td>
</tr>
<tr>
<td>import</td>
<td>Create a new filesystem image from the contents of a tarball</td>
<td>从 tar 包中的内容创建一个新的文件系统映像<em>对应 export</em></td>
</tr>
<tr>
<td>info</td>
<td>Display system-wide information</td>
<td>显示系统相关信息</td>
</tr>
<tr>
<td>inspect</td>
<td>Return low-level information on a container</td>
<td>查看容器详细信息</td>
</tr>
<tr>
<td>kill</td>
<td>Kill a running container</td>
<td>kill 指定 docker 容器</td>
</tr>
<tr>
<td>load</td>
<td>Load an image from a tar archive</td>
<td>从一个 tar 包中加载一个镜像 [对应 save]</td>
</tr>
<tr>
<td>login</td>
<td>Register or Login to the docker registry server</td>
<td>注册或者登陆一个 docker 源服务器</td>
</tr>
<tr>
<td>logout</td>
<td>Log out from a Docker registry server</td>
<td>从当前 Docker registry 退出</td>
</tr>
<tr>
<td>logs</td>
<td>Fetch the logs of a container</td>
<td>输出当前容器日志信息</td>
</tr>
<tr>
<td>port</td>
<td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td>
<td>查看映射端口对应的容器内部源端口</td>
</tr>
<tr>
<td>pause</td>
<td>Pause all processes within a container</td>
<td>暂停容器</td>
</tr>
<tr>
<td>ps</td>
<td>List containers</td>
<td>列出容器列表</td>
</tr>
<tr>
<td>pull</td>
<td>Pull an image or a repository from the docker registry server</td>
<td>从 docker 镜像源服务器拉取指定镜像或者库镜像</td>
</tr>
<tr>
<td>push</td>
<td>Push an image or a repository to the docker registry server</td>
<td>推送指定镜像或者库镜像至 docker 源服务器</td>
</tr>
<tr>
<td>restart</td>
<td>Restart a running container</td>
<td>重启运行的容器</td>
</tr>
<tr>
<td>rm</td>
<td>Remove one or more containers</td>
<td>移除一个或者多个容器</td>
</tr>
<tr>
<td>rmi</td>
<td>Remove one or more images</td>
<td>移除一个或多个镜像 无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除</td>
</tr>
<tr>
<td>run</td>
<td>Run a command in a new container</td>
<td>创建一个新的容器并运行一个命令</td>
</tr>
<tr>
<td>save</td>
<td>Save an image to a tar archive</td>
<td>保存一个镜像为一个 tar 包<strong>对应 load</strong></td>
</tr>
<tr>
<td>search</td>
<td>Search for an image on the Docker Hub</td>
<td>在 docker hub 中搜索镜像</td>
</tr>
<tr>
<td>start</td>
<td>Start a stopped containers</td>
<td>启动容器</td>
</tr>
<tr>
<td>stop</td>
<td>Stop a running containers</td>
<td>停止容器</td>
</tr>
<tr>
<td>tag</td>
<td>Tag an image into a repository</td>
<td>给源中镜像打标签</td>
</tr>
<tr>
<td>top</td>
<td>Lookup the running processes of a container</td>
<td>查看容器中运行的进程信息</td>
</tr>
<tr>
<td>unpause</td>
<td>Unpause a paused container</td>
<td>取消暂停容器<br></td>
</tr>
<tr>
<td>version</td>
<td>Show the docker version information</td>
<td>查看 docker 版本号</td>
</tr>
<tr>
<td>wait</td>
<td>Block until a container stops, then print its exit code</td>
<td>截取容器停止时的退出状态值</td>
</tr>
</tbody></table>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p><strong>参考资料：</strong><a href="https://developer.aliyun.com/article/1078131#slide-0">【云原生 Docker 系列第七篇】浅谈镜像的分层原理（几位？“两位”）-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是 image 镜像文件</p>
<h3 id="Docker-镜像的加载原理"><a href="#Docker-镜像的加载原理" class="headerlink" title="Docker 镜像的加载原理"></a>Docker 镜像的加载原理</h3><h4 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h4><blockquote>
<p>Docker 中的文件存储驱动叫做 storage driver。Docker 最早支持的 stotage driver 是 AUFS，它实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS。</p>
</blockquote>
<p>联合文件系统（UnionFS）：Union 文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。</p>
<p>Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行集成，基于基础镜像可以制作具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p>后来出现的 docker 版本中，除了 AUFS，还支持 OverlayFS、Btrfs、Device Mapper、VFS、ZFS 等 storage driver。</p>
<p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p>
<h4 id="bootfs-boot-File-system"><a href="#bootfs-boot-File-system" class="headerlink" title="bootfs(boot File system)"></a>bootfs(boot File system)</h4><p>bootfs（boot file system） 主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文件系统。</p>
<p>在 Docker 镜像的最底层是引导文件系统 bootfs。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p>
<h4 id="rootfs（root-File-system）"><a href="#rootfs（root-File-system）" class="headerlink" title="rootfs（root File system）"></a>rootfs（root File system）</h4><p>在 bootfs 之上，包含的就是典型 Linux 系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu、CentOS 等。</p>
<h4 id="Docker-镜像底层层次"><a href="#Docker-镜像底层层次" class="headerlink" title="Docker 镜像底层层次"></a>Docker 镜像底层层次</h4><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224108257.png"></p>
<p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用 Host 的 Kernel，自己只需要提供 rootfs 就可以。所以，对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别，不同的发行版可以共用 bootfs。</p>
<p>有差别的 rootfs：</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224120068.png"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h3 id="容器层与镜像层"><a href="#容器层与镜像层" class="headerlink" title="容器层与镜像层"></a>容器层与镜像层</h3><p>当容器启动时，一个新的<strong>可写层</strong>将被加载到镜像的顶部，这一层通常被称为 <code>容器层</code>，容器层之下的都叫 <code>镜像层</code>。所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406223513304.png"></p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote>
<p>docker commit -m&#x3D;” 提交的描述信息 “ -a&#x3D;” 作者 “ 容器 ID 要创建的目标镜像名:{标签名}</p>
</blockquote>
<h3 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a>实操案例</h3><p>目标：创建一个带有 vim 的 ubuntu 镜像</p>
<blockquote>
<p>拉取最新的 ubuntu 镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406224847182.png"></p>
<blockquote>
<p>运行一个 ubuntu 实例，并进入终端界面</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406225002838.png"></p>
<blockquote>
<p>使用 vim 指令，发现指令不存在</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406225051600.png"></p>
<blockquote>
<p>安装 vim 指令</p>
</blockquote>
<p>执行过程没啥意思，就不截图了，命令附上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Vim</span></span><br><span class="line">apt-get -y install vim</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;带有vim的ubuntu&quot;</span> -a=<span class="string">&quot;zhanglei&quot;</span> ebd71331125f withvimubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233516020.png"></p>
<blockquote>
<p>查看已经生成的镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233621859.png"></p>
<blockquote>
<p>运行新构建的镜像，并查看对应的命令</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406233909308.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Docker 中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似 Java 继承于一个 Base 基础类，自己再按需扩展。新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240406234058685.png"></p>
<h2 id="镜像发布阿里云-个人版切勿用于生产环境"><a href="#镜像发布阿里云-个人版切勿用于生产环境" class="headerlink" title="镜像发布阿里云 (个人版切勿用于生产环境)"></a>镜像发布阿里云 (个人版切勿用于生产环境)</h2><blockquote>
<p>本章节比较偏实操，镜像的生成方法参考上一章节 <code>Dokcer镜像-&gt;怎么用</code> 章节，下面的案例展示以推送上一步生成的 withvimubuntu 镜像目标</p>
</blockquote>
<h3 id="登录阿里云，找到容器镜像服务"><a href="#登录阿里云，找到容器镜像服务" class="headerlink" title="登录阿里云，找到容器镜像服务"></a>登录阿里云，找到容器镜像服务</h3><p>点击进入 <a href="https://account.aliyun.com/login/login.htm?oauth_callback=https://account.console.aliyun.com/v2/#/home/person">阿里云登录页 (aliyun.com)</a>，找到容器镜像服务</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001127056.png"></p>
<h3 id="能白嫖就不要缴费"><a href="#能白嫖就不要缴费" class="headerlink" title="能白嫖就不要缴费"></a>能白嫖就不要缴费</h3><p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001223121.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001256358.png"></p>
<h3 id="设置访问凭证"><a href="#设置访问凭证" class="headerlink" title="设置访问凭证"></a>设置访问凭证</h3><p>首次进入，会强制你设置，不设置无法使用其镜像服务，要想更改访问凭证，参考下图即可</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001609532.png"></p>
<h3 id="设置命名空间，创建仓库"><a href="#设置命名空间，创建仓库" class="headerlink" title="设置命名空间，创建仓库"></a>设置命名空间，创建仓库</h3><p>注意创建顺序，阿里的防呆设计做的挺好的，看一下基本就了解了。创建仓库时，代码源选择本地仓库。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407001951303.png"></p>
<h3 id="查看操作指南"><a href="#查看操作指南" class="headerlink" title="查看操作指南"></a>查看操作指南</h3><p>进入仓库的管理页面，查看对应的操作指南。</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407002056656.png"></p>
<h3 id="实操上手"><a href="#实操上手" class="headerlink" title="实操上手"></a>实操上手</h3><p>密码其实就是之前设置的访问凭证，其他的就按照教程来就行</p>
<blockquote>
<p>推送镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login --username=啊啊阿磊啊 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="comment"># docker tag [镜像号] registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本号]</span></span><br><span class="line">docker tag 07f05e531ec6 registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br><span class="line"><span class="comment"># docker push registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本号]</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407003606627.png"></p>
<blockquote>
<p>删除本地的镜像</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004058887.png"></p>
<blockquote>
<p>从阿里云拉取镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:[镜像版本及版本号]</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/zhanglei_0407/zhanglei_0407:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004419457.png"></p>
<blockquote>
<p>运行镜像，并查看 vim 版本</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407004544761.png"></p>
<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库</p>
<h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><ol>
<li>官方 Docker Hub 地址：<a href="https://hub.docker.com/%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2%E4%BA%86%E4%B8%94%E5%87%86%E5%A4%87%E8%A2%AB%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%96%E4%BB%A3%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%A4%AA%E4%B8%BB%E6%B5%81%E3%80%82">https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</a></li>
<li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</li>
</ol>
<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote>
<p><strong>目标：</strong> 搭建本地私有仓库，将本地镜像推送到私有库</p>
</blockquote>
<h4 id="下载-Docker-Registry-镜像"><a href="#下载-Docker-Registry-镜像" class="headerlink" title="下载 Docker Registry 镜像"></a>下载 Docker Registry 镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker registry</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407073209069.png"></p>
<h4 id="运行对应的容器"><a href="#运行对应的容器" class="headerlink" title="运行对应的容器"></a>运行对应的容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /app/myregistry/:/tmp/registry --privileged=<span class="literal">true</span> registry</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407073648139.png"></p>
<h4 id="创建带有安装-Ifconfig-命令的-Ubuntu-镜像"><a href="#创建带有安装-Ifconfig-命令的-Ubuntu-镜像" class="headerlink" title="创建带有安装 Ifconfig 命令的 Ubuntu 镜像"></a>创建带有安装 Ifconfig 命令的 Ubuntu 镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载ubuntu镜像</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -it  -name=withnettools ubuntu bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载nettools工具</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成镜像</span></span><br><span class="line">docker commit -m=<span class="string">&quot;带有ipconfig的镜像&quot;</span> -a=<span class="string">&quot;zhanglei&quot;</span> 473e414d8db9 myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p>生成镜像时有点奇怪，一开始预备的镜像名为 <code>withvnettoolsubuntu</code> ，一直显示格式错误……，不知道为什么</p>
<h4 id="查看私服库镜像"><a href="#查看私服库镜像" class="headerlink" title="查看私服库镜像"></a>查看私服库镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># curl -XGET 私服IP端口/v2/_catalog</span></span><br><span class="line">curl -XGET http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407080125965.png"></p>
<h4 id="修改镜像的-Tag"><a href="#修改镜像的-Tag" class="headerlink" title="修改镜像的 Tag"></a>修改镜像的 Tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker   tag   镜像:Tag   Host:Port/Repository:Tag</span></span><br><span class="line">docker tag myubuntu:1.0.1 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407080623663.png"></p>
<h4 id="修改配置，使私库支持-Http-协议"><a href="#修改配置，使私库支持-Http-协议" class="headerlink" title="修改配置，使私库支持 Http 协议"></a>修改配置，使私库支持 Http 协议</h4><blockquote>
<p>docker 默认不允许 http 方式推送镜像，通过配置选项来取消这个限制。  修改完后如果不生效，建议重启 docker</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件 (需要拥有写入权限)</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081139388.png"></p>
<h4 id="推送镜像到私库"><a href="#推送镜像到私库" class="headerlink" title="推送镜像到私库"></a>推送镜像到私库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker push IP:端口/目标镜像名称:版本号</span></span><br><span class="line">docker push 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081426537.png"></p>
<p>查看此时的私服库镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XGET http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407081732590.png"></p>
<h4 id="删除本地镜像，从私库拉入"><a href="#删除本地镜像，从私库拉入" class="headerlink" title="删除本地镜像，从私库拉入"></a>删除本地镜像，从私库拉入</h4><blockquote>
<p>删除指令不做重复</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker pull 私库IP:端口/镜像名称:版本号</span></span><br><span class="line">docker pull 127.0.0.1:5000/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407082244769.png"></p>
<p>运行镜像实例，并查看 ip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it 127.0.0.1:5000/myubuntu:1.0.1 bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407082457407.png"></p>
<h2 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以想象一下主机的一块磁盘，当做 U 盘插入 docker 的运行实例中。</p>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p><strong>为了能保存数据在 docker 中我们使用卷</strong>。将运行的环境打包镜像，run 后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接实时生效 (因为是同一块 U 盘)</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="宿主-Vs-容器之间映射添加容器卷"><a href="#宿主-Vs-容器之间映射添加容器卷" class="headerlink" title="宿主 Vs 容器之间映射添加容器卷"></a>宿主 Vs 容器之间映射添加容器卷</h4><blockquote>
<p>宿主机下的映射路径如果不存在，则会自动创建</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /app/myubuntu/tmp:/tmp ubuntu</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看运行情况</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker inspect 容器ID</span></span><br><span class="line">docker inspect 952c46cfdf8c</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407084858447.png"></p>
<blockquote>
<p>测试虚拟机与主机数据共享</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407085145676.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407085352209.png"></p>
<h4 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h4><blockquote>
<p>读写 (默认)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</span><br><span class="line"><span class="comment"># 或者 什么也不写</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只读 (Read Only)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>

<h4 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -it --privileged=true --volumes-from 父容器ID --name=容器名称 镜像:镜像版本</span></span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> --volumes-from jovial_mclaren --name=myubuntu2 ubuntu</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407090334433.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407090311022.png"></p>
<h2 id="Docker-常规安装"><a href="#Docker-常规安装" class="headerlink" title="Docker 常规安装"></a>Docker 常规安装</h2><ol>
<li>搜索镜像</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像：启动镜像时，进行服务端口映射，容器卷实例持久化，环境变量的注入</li>
<li>停止容器</li>
<li>移除容器</li>
</ol>
<h3 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h3><h4 id="Docker-Hub-上面查找-Tomcat-镜像"><a href="#Docker-Hub-上面查找-Tomcat-镜像" class="headerlink" title="Docker Hub 上面查找 Tomcat 镜像"></a>Docker Hub 上面查找 Tomcat 镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询前5个满够了</span></span><br><span class="line"> docker search tomcat --<span class="built_in">limit</span> 5</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407213929228.png"></p>
<h4 id="从-Docker-Hub-上拉取-Tomcat-镜像到本地"><a href="#从-Docker-Hub-上拉取-Tomcat-镜像到本地" class="headerlink" title="从 Docker Hub 上拉取 Tomcat 镜像到本地"></a>从 Docker Hub 上拉取 Tomcat 镜像到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407213959362.png"></p>
<h4 id="Docker-Images-查看是否有拉取到的-Tomcat"><a href="#Docker-Images-查看是否有拉取到的-Tomcat" class="headerlink" title="Docker Images 查看是否有拉取到的 Tomcat"></a>Docker Images 查看是否有拉取到的 Tomcat</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker images 指定镜像名</span></span><br><span class="line">docker images tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214258844.png"></p>
<h4 id="使用-Tomcat-镜像创建容器实例-也叫运行镜像"><a href="#使用-Tomcat-镜像创建容器实例-也叫运行镜像" class="headerlink" title="使用 Tomcat 镜像创建容器实例 (也叫运行镜像)"></a>使用 Tomcat 镜像创建容器实例 (也叫运行镜像)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214604564.png"></p>
<h4 id="访问首页"><a href="#访问首页" class="headerlink" title="访问首页"></a>访问首页</h4><blockquote>
<p>问题：阿偶，启动失败了，报 404</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407214500195.png"></p>
<blockquote>
<p>原因分析：</p>
</blockquote>
<ul>
<li>检查防火墙是否关闭，端口是否放开</li>
<li>新版的 <code>tomcat</code> 默认的 webapps 文件夹是空的，原来的 webapps 文件夹内容放入了 webapps.dist 下了</li>
</ul>
<blockquote>
<p>解决办法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407215913973.png"></p>
<h4 id="免修改版本"><a href="#免修改版本" class="headerlink" title="免修改版本"></a>免修改版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name tomcat8 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407215928883.png"></p>
<h3 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h3><blockquote>
<p>具体的版本需要到 dockerHub 上进行查询，此处按照 8.0.36 做演示</p>
</blockquote>
<h4 id="Docker-Hub-上面查找-Mysql-镜像"><a href="#Docker-Hub-上面查找-Mysql-镜像" class="headerlink" title="Docker Hub 上面查找 Mysql 镜像"></a>Docker Hub 上面查找 Mysql 镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search mysql --<span class="built_in">limit</span> 5</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407225210764.png"></p>
<h4 id="从-Docker-Hub-上-阿里云加速器-拉取-Mysql-镜像到本地"><a href="#从-Docker-Hub-上-阿里云加速器-拉取-Mysql-镜像到本地" class="headerlink" title="从 Docker Hub 上 (阿里云加速器) 拉取 Mysql 镜像到本地"></a>从 Docker Hub 上 (阿里云加速器) 拉取 Mysql 镜像到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker pull mysql:8.0.36</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407224909368.png"></p>
<h4 id="简单版安装"><a href="#简单版安装" class="headerlink" title="简单版安装"></a>简单版安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.36</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入容器，创建数据库</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407231902340.png"></p>
<blockquote>
<p>使用外部工具链接数据库，并插入中文数据</p>
</blockquote>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><blockquote>
<p>8 版本数据库链接数据库时报 <code>Public Key Retrieval is not allowed</code> 异常</p>
</blockquote>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407232301848.png"></p>
<p><strong>解决办法：</strong> 可参考该文章：<a href="https://blog.csdn.net/white0718/article/details/131790493">完美解决：MySQL8 报错：Public Key Retrieval is not allowed-CSDN 博客</a></p>
<p>问题的根本原因还是在于，mysql 8.0 默认使用 caching_sha2_password 身份验证机制，客户端默认不支持新的加密方式</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407232445789.png"></p>
<blockquote>
<p>8.0 版本插入中文数据在 docker 中查询乱码</p>
</blockquote>
<p><strong>问题：</strong> 参照下图，插入一条中文数据，并可在连接工具中正常查看，但是在 docker 容器实例下的控制台无法查看<br><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407233741906.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407233912940.png"></p>
<p><strong>现象原因：</strong> 该问题其实是由于 docker 容器中的系统不支持中文导致的，我们可以发现，docker 容器内部终端中，是无法输入中文的，因此会出现此现象</p>
<blockquote>
<p>5.7 版本插入中文会报异常</p>
</blockquote>
<p><strong>问题：</strong> 参照下图，插入中文会报异常</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407234802583.png"></p>
<p><strong>原因：</strong> mysql5.7 版本，数据库的默认字符集为拉丁文，导致的</p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240407235054575.png"></p>
<p><strong>解决办法</strong>：修改配置文件，重启 mysql 服务，可以参考实际应用安装</p>
<h4 id="实际应用安装"><a href="#实际应用安装" class="headerlink" title="实际应用安装"></a>实际应用安装</h4><p>实际应用安装，以 5.7 为例，-v 的数据，日志，配置所对应的容器卷映射按照实际配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 3306:3306 \</span></span><br><span class="line"><span class="comment">#           --privileged=true \</span></span><br><span class="line"><span class="comment">#           -v [主机日志存放路径]:/var/log/mysql \</span></span><br><span class="line"><span class="comment">#           -v [主机数据存放路径]:/var/lib/mysql \</span></span><br><span class="line"><span class="comment">#           -v [主机配置存放路径]:/etc/mysql/conf.d \</span></span><br><span class="line"><span class="comment">#           -e MYSQL_ROOT_PASSWORD=root \</span></span><br><span class="line"><span class="comment">#           --name [服务名] \</span></span><br><span class="line"><span class="comment">#           mysql[:版本号]</span></span><br><span class="line"></span><br><span class="line">docker run -d -p 3306:3306 \</span><br><span class="line">           --privileged=<span class="literal">true</span> \</span><br><span class="line">           -v /app/mysql/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">           --name mysql \</span><br><span class="line">           mysql:5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决中文插入报错问题：</p>
</blockquote>
<p>在 <code>/app/mysql/conf</code> 下新建 <code>my.cnf</code>，通过容器卷同步给 mysql 实例，解决中文乱码问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure>

<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><blockquote>
<p>不写废话，直接上指令</p>
</blockquote>
<h4 id="简单玩具版"><a href="#简单玩具版" class="headerlink" title="简单玩具版"></a>简单玩具版</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<h4 id="实际应用版"><a href="#实际应用版" class="headerlink" title="实际应用版"></a>实际应用版</h4><ol>
<li><p>宿主机创建目录 <code>/app/redis</code></p>
</li>
<li><p>修改配置文件，在 <code>/app/redis</code> 下创建文件 <code>redis.conf</code>，并修改</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启密码验证（可选）</span><br><span class="line">requirepass 123</span><br><span class="line"></span><br><span class="line"># 允许redis外地连接，需要注释掉绑定的IP</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 关闭保护模式（可选）</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># 注释掉daemonize yes，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 开启redis数据持久化， （可选）</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis --privileged=<span class="literal">true</span> \</span><br><span class="line">           -v /app/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">           -v /app/redis/data:/data \</span><br><span class="line">           redis:6.0.8 \</span><br><span class="line">           redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h3><h4 id="下载镜像并启动容器"><a href="#下载镜像并启动容器" class="headerlink" title="下载镜像并启动容器"></a>下载镜像并启动容器</h4><blockquote>
<p>宝塔需要的端口：8888、888、20、21、80、443 为了方便使用共享主机网络模式 <code>--net=host</code></p>
</blockquote>
<p><strong>参考文章</strong></p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1830313">Docker 安装配置宝塔面板-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a href="https://blog.csdn.net/qq_33420835/article/details/109013202">更改 Docker 的 shm（共享内存）大小_docker 修改 shm 大小-CSDN 博客</a></li>
<li><a href="https://www.cnblogs.com/freeaihub/p/13197292.html">Docker 网络:host 模式 - freeaihub - 博客园 (cnblogs.com)</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取centos7镜像</span></span><br><span class="line">docker pull centos:centos7</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -itd --name baota --net=host --privileged=<span class="literal">true</span> \</span><br><span class="line">                -v /app/baota/www:/www centos:centos7 /usr/sbin/init</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it baota /bin/bash</span><br><span class="line"><span class="comment"># 执行安装指令</span></span><br><span class="line">yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414125907052.png"></p>
<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414134349579.png"></p>
<ul>
<li>外网面板地址: <a href="http://144.255.7.111:13453/06288b4b">http://144.255.7.111:13453/06288b4b</a></li>
<li>内网面板地址: http:&#x2F;&#x2F;:13453&#x2F;06288b4b</li>
<li>username: rpa5wno8</li>
<li>password: b136dcbb</li>
</ul>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><blockquote>
<p>进入容器内部，执行 <code>bt</code> 命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it baota /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Docker%E5%B0%8F%E5%86%8C/image-20240414090247327.png"></p>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>待更新~~~~~~</p>
<h2 id="资源汇总"><a href="#资源汇总" class="headerlink" title="资源汇总"></a>资源汇总</h2><ul>
<li><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://www.yuque.com/tmfl/cloud/naxbau">大佬笔记</a></li>
</ul>
]]></content>
      <tags>
        <tag>数据/activemq</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMart开发文档</title>
    <url>/2024/12/10/archive/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><blockquote>
<p>推荐您使用宝塔搭建本系统，本系统也以宝塔为例演示如何搭建，其他环境，请根据您的实际情况自行安装。<br>宝塔环境的安装，请参考  <a href="https://bt.cn/new/download.html">https://bt.cn/new/download.html</a></p>
</blockquote>
<h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>服务器环境推荐使用 linux centos，版本任意。软件环境</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>PHP</td>
<td>7.2+</td>
</tr>
<tr>
<td>MySQL</td>
<td>5.7</td>
</tr>
<tr>
<td>Nginx</td>
<td>1.22.1(比较新的版本即可)</td>
</tr>
</tbody></table>
<p>PHP 扩展需要安装的有：<code>fileinfo</code>、<code>redis</code></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/89a314b662ce2038fd5cff4494c17979f6b5995103d2f5465d7a4cfa45c14700.png"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>下面是示例</p>
<table>
<thead>
<tr>
<th>域名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>demo.hashmart.com.cn</td>
<td>程序后台访问和接口层访问</td>
</tr>
</tbody></table>
<blockquote>
<p>解析域名指向需要安装的服务器</p>
</blockquote>
<p>前端环境准备</p>
<p>开发工具 HBuilder X 3.7.6 -alpha 微信开发者工具</p>
<p>前端 node 版本 v14.15.0</p>
<h2 id="2、安装后台程序"><a href="#2、安装后台程序" class="headerlink" title="2、安装后台程序"></a>2、安装后台程序</h2><p>1、访问码云 (gitee) 下载程序源码  <a href="https://gitee.com/kitego/hashmart">https://gitee.com/kitego/hashmart</a></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/ef7b5f6e59265760a0a6ab3853320df27f9f176f82427e5bd8778af5ff691139.png" alt="|490"></p>
<p>下载好源码解压好，备用</p>
<p>2、下面介绍一下每个目录的用途</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>api</td>
<td>整个系统的接口层源码</td>
</tr>
<tr>
<td>screenshoot</td>
<td>readme 数据的静态截图文件（与系统无关）</td>
</tr>
<tr>
<td>web&#x2F;admin</td>
<td>web 下的 admin 目录是放的管理端后台的 vue 源码</td>
</tr>
<tr>
<td>web&#x2F;uniapp</td>
<td>web 下的 uniapp 目录是放的移动端前端的 uniapp 源码</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、打开宝塔新建网站，输入域名 `demo.hashmart.com.cn`(示例域名，您的根据实际情况来)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/ed4e5ca44c14613b881b48f94e42305ea522dd2998545a88774380a2df1fee44.png"></p>
<p>4、上传源码包中的 <code>api</code>  目录中的内容到  <code>/www/wwwroot/demo.hashmart.com.cn</code>  下</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/135758e9ed66ba46161c5094289f84e174eaf8ffc082fea4a4dd2fafec7489b4.png"></p>
<p>点击网站后的设置</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/0d7c627eb55aae4c0da5b185e7f93f91115cc61bb495b5d4cac851cf9234bc9e.png"></p>
<p>配置网站的运行目录为  <code>public</code></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/65ae3f0fd958efedd64abf768b0012caad07a2ede68ab71b6026143a2c0a9eb0.png"></p>
<p>并且设置网站的伪静态</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/bbd8a6b80f92f16a024eaa1ebe1863130fa1a65032a099c16c01d501510d2fb4.png"></p>
<p>由于系统采用了三方字体，因此要配置这些字体可跨域，网站 –&gt; 设置中</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/3108d522e15e8d0d1f689b7662fa4fe3d8162491f766b3637046b84131e73b20.png"></p>
<p>添加如下的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~* .(eot|ttf|woff|woff2|svg)$ &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、打开浏览器访问  <code>demo.hashmart.com.cn</code>，进入安装页面</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/d7118892b0250b6944caa40d6437ad35590b8f7c8356ceda766c81bf94fb5383.png"></p>
<p>同意协议进入下一步</p>
<p>6、系统检测扩展环境以及目录读写权限，没问题点击下一步</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/3eee60a539200c854d05545d384eb3b1b3965cbcd3fe11719dda6952a2d733c3.png"></p>
<p>7、填写对应的数据库账号信息、管理员密码，点击下一步</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/af504fd6e23639cf132610bf45ad43e92210e2f940f2db5286918d482df86062.png"></p>
<p>8、等待数据库的安装</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/754409f05e60b8aa55c32bf22d2155f0d1ea98188233d0c467e69b59dcc0c7de.png"></p>
<p>9、安装成功</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/a2d7891df8156af46d8d3b87f660904ffef7ac9b4dad5da916add88d53f7b16e.png"></p>
<blockquote>
<p>建议您安装完成后，删除  <code>app/install</code>  目录，防止被别人重复安装。</p>
</blockquote>
<p>10、点击访问后台、输入刚才自己录入的 管理员密码，比如上例我们填写的  <code>admin123</code></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/5ded17548e54a5e502082a4d68407b7f36014abbe3ea17f7e79a62dd55ec0faa.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/4b0e7d8d4bf447424edf1617e9b675996215a52077997eda9f27425ee80a52bb.png"></p>
<blockquote>
<p>为了方便搭建的使用，本系统已经把 admin 管理后台的源码编译好后放在了  <code>api</code>  目录的 public 下的  <code>backend</code> 下。如果你想自己修改编译后台，可以参考  <code>常见问题 &gt;&gt; 如何自己编译后台</code></p>
</blockquote>
<p>配置定时任务</p>
<blockquote>
<p>定时任务主要是处理一些超时未支付的订单</p>
</blockquote>
<p>软件中心搜索 supervisor，并安装</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/f4188d7d144ec88d2b14a32f44cc984e14dd6f546caa8ad7a30dbfa8dc7a83e8.png"></p>
<p>点击配置</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/12788b754d58438239f1fe3c62b96755710b578bc3f187a91b22c8c0724df1be.png"></p>
<p>宝塔安装  <code>守护进程管理器</code>, 新建定时任务，目录选择 后台程序 所在目录，命令输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php think crontab start</span><br></pre></td></tr></table></figure>

<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/2e6430c948f1270ce3410b42d64a8a559c3f9fb90871a146903a69a2b832f6f5.png"></p>
<p>录入定时任务</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/f27da02625a616cf346794533529de5aa976f4fb175c714949a8fee761aeac0b.png"></p>
<p>录入如下的 2 条规则</p>
<table>
<thead>
<tr>
<th>规则名</th>
<th>命令</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>盲盒订单超时检测</td>
<td>php think blindboxOrder</td>
<td>每隔 N 分钟 – 10 分</td>
</tr>
<tr>
<td>余额充值订单超时检测</td>
<td>php think balanceOrder</td>
<td>每隔 N 分钟 – 10 分钟</td>
</tr>
</tbody></table>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/992bbcdfccd3a71cfb6bda3cfc1f67a640cc537ebd937de028887c234d55305d.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/330debd415e7ac21b76afe34d09575b2d228ebbe53b5aace5b0eaf00c9c65635.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/88e7499c39164f2820978734adb42dba5f5766cbfbed3e4583d47f607e374fbd.png"></p>
<h2 id="3、编译小程序"><a href="#3、编译小程序" class="headerlink" title="3、编译小程序"></a>3、编译小程序</h2><p>1、使用 hbuilderx 打开刚才下载的源码目录下的 uniapp 文件夹,或者进入文件夹直接拖动文件夹到 hbuilderx</p>
<p>目录地址 源码&gt;web&gt;uniapp</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/976909435dfd6501b19350a839e5aa5ebdbf6ee770c501ddb9eb337b8edc36d6.png"></p>
<p>2、 打开编辑器终端，输入命令行代码  <code>npm i</code>,输入后按回车键，终端开始下载项目所需依赖包</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/eeb143dbcaba2b7c5bdd4f125237fa7da83472535f1468b9b3275ae93bf57fcf.png"></p>
<p>3、进行相应的配置， 打开目录下的 <code>manifest.json</code>  文件 ,找到微信小程序配置，在微信小程序 AppID 内输入自己真实的微信小程序 AppID</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/21a98c630157f1beee04b82a8df7dc00b6976d081ba6d52faf3c2923e5084bad.png"></p>
<p>4、若找不到自己的微信小程序 AppID,打开浏览器，输入“微信公众平台”，进入官网，登录，找到‘开发&gt;开发管理’，点击 ‘开发设置’ ，下方显示 AppID ,复制粘贴。</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/961ce9d990398c9656750593b9316bfdc66c1ac8d16acd0ec158356e5d233a18.png"></p>
<p>5、请求接口地址修改 打开此文件修改为自己的请求接口地址, “apiroot” 是接口请求地址 “imgroot” 为静态图片地址</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/144f6b73051454e75bf836cd4f3d426021222bc93b59f5123a266a6b58ae9047.png"></p>
<p>6、运行到微信小程序，运行前将目录下的  <code>uniCloud</code>  文件夹删除 （注意：备份一下这个文件，运行 app 时要用到）</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/1e31abe3c6ce3c3026db55e3333c33ad3684f1e2b300710dc3d81e69c19c1e8d.png"></p>
<p>7、选中项目，点击上方 ‘’ 运行&gt;运行到小程序模拟器&gt;微信开发者工具</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/335cf0ad2ce83ca28d759e51658c501d64f1a52136f00dc0b474c3be560493fb.png"></p>
<p>8、运行成功，可选择不登录，点击红色框内按钮进入首页</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/66b3491923b18a1af576e32876875dfaeb21a5bc77081cdb3696993adbb2a635.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/4ecf1d6c25fcdeaaa6c9eee642adc08f1c962f705cde93e7c53801f598f9e25a.png"></p>
<p>9、微信一键登录，点击右上角详情，修改 appid（修改为自己的微信小程序 appid,若不知道看第 4 步），</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/03c0dffa5318f8c23e09408ad5085cb250071e90f96461f2ea00855f0065e38e.png"></p>
<p>此处若不填写或者填写不正确的 appid 直接登录会报错。填写正确的 appid 即可登录</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/2e8a1d8904ae9319d8fac91fd1434c76f25ea3c576d8baccaad437b00271b1f0.png"></p>
<p>10、发行小程序，编译完自己想要增加或者修改的页面后，保存文件，点击   <code>发行&gt;小程序-微信</code>,在弹框内填写相应的信息，小程序名称填自己的小程序名称，AppId 同第三条</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/6015d18e023dd85cfd36f4d0c1b10110ea49e9a9c01200fd4b4b9cdab596acc3.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/0a65a27130a0ea49ab0534ff841539c497d7f4feaf471cacf60d2763ac8e8fca.png"></p>
<p>11、信息填写完毕，点击“发行”，终端控制台执行编译发行，编译成功后会自动打开微信开发者工具，</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/c924c88fbf5fd5b4c3e3d17b818108591b48bab5dca18f9e05e707999879dd38.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/7a30ebdee04681301961139a836ac96de104e6184b3f5f6ac3ca222791771716.png"></p>
<p>12、在弹出的微信开发者工具中，点击“详情&gt;本地设置&gt;调试基础库”，选择版本（注意不要选择“灰度中”的版本号），然后点击“上传”，填写版本号，再点击上传即可上传体验版本</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/8b4d93dba3ad610c7fa39a25aab7301f5ab6f9c0279f0f470da1c45b7f927b5c.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/c9d192d6d11484b7381addccf8994344af7b8df86f91c7a18e144a08379a7ea1.png"></p>
<p>13、若需要上传正式版小程序，登录微信公众平台，提交审核即可</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/5380f3d48f2bf8056fbd8fee7694928ec4b0ded4e6177e59c17872bfa80e5174.png"></p>
<h2 id="4、编译-App"><a href="#4、编译-App" class="headerlink" title="4、编译 App"></a>4、编译 App</h2><p>1、将我们在小程序删除并备份的   <code>uniCloud</code> 文件夹放在项目的根目录下</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/91ed5dc6553e065fe6069f34d73c3f7097519e66cd6422b00a91deaaeaeedc8f.png"></p>
<p>2、打开 目录下的 ‘manifest.json’ 文件，点击“基础配置”，填写自己的 uni-app 应用标识，以及应用名称</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/55b7c11461b932f6c864974132ba5d160259916ddb88562e202bcb06c42eeecd.png"></p>
<p>3、点击 “app 图标配置”，配置自己的 app 图标,点击“浏览”，选择自己要设置的 app 图标，然后点击自动生成所有图标并替换即可</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/c1d61db96afb25abe3f495c04e5ed98e44c61a0a1684644beea5a515eb794a04.png"></p>
<p>4、打开 unCloud&gt;cloudfunctions&gt;getPhoneNumberHash&gt;index.js 配置相关信息，可从后台获取相应信息或者此文件内直接填写相应的值</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/94462b02a1dff78af9f61688bcf70cede71d134d45bd96c1f0e53329706ae5d7.png"></p>
<p>5、若 4 内相应参数在后台获取，则登录安装好的后台系统，点击菜单 ‘系统&gt;uniapp 配置’ 填写自己的 uniapp 的相应参数</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/f457567734d32df8d85673710a7150b819561b93b9d92ca5ddc267e8156f4497.png"></p>
<p>6、云函数 url 化，打开 unicloud 后台（<a href="https://unicloud.dcloud.net.cn/">https://unicloud.dcloud.net.cn/</a>），登录 uniapp 管理员账号</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/2b027c2e414908a7653b0366d1c526858374fd108f2745522f403c8549666c24.png"></p>
<p>7、找到相应的 app,然后点击“详情”进入此 app 的详情内容，在左侧菜单找到 “云函数&#x2F;云对象&gt;函数&#x2F;对象列表”，在右侧云函数列表找到相应的云函数</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/01623a8c0bf59d0e43ff30117a1fef48f0e091e31120908441c1fe52d26b385e.png"></p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/56ea76b7ac3626a8c350c471fdb5c0d015cb7f2b217f49ee7929ce1dcd09b462.png"></p>
<p>点击“详情”进入云函数详情页，在最下方找到云函数地址复制粘贴到后台 uniapp 配置内的云函数 url 化</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/5fd25ea7fab8f5a0ac2619cfd27f6efe9b5aee960ba3ec237be9c01819a14b4f.png"></p>
<p>8、unicloud 云函数关联云空间，右键项目下的 unicloud 文件</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/7e507b71ccee12cbeaee8243b95e780ce47e44e7807b11365a558ebc24346095.png"></p>
<p>9、弹框内选择自己的云空间，然后点击“关联”即可</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/3a5dffcdca5bba55b85ffae6d0b28e790a7128026b3f9762ac8dc4efd8f93469.png"></p>
<p>关联成功</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/9519ff23369e0947e53d3f5fd54b803c67f4a9e50427f756cae991075ce9bb19.png"></p>
<p>10、运行 app，选中项目，然后点击运行&gt;运行到手机或模拟器&gt;运行到 android app 基座</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/e3b913a09e25d4b4d03f5fae99e787635e31d073033d2b1eb5f6a86d8a5f2c36.png"></p>
<p>此时需要一台安卓手机并打开开发者模式，数据线连接电脑和手机，保证手机跟电脑处于同一局域网下</p>
<p>点击勾选基座，运行</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/744c2a18d4659921379cdb8701b7431a2ccf8809f863e68f5ede5ea0291f834a.png"></p>
<p>11、运行过程中终端状态</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/139b60debf1fdecf85c3ae2d94053d255a3cf67ad58e54680898f0e92bf836f7.png"></p>
<p>12、运行成功会在手机上自动安装一个调试基座 app,并打开</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/6bda15b701cff4f34b8ee9ba61ebb9f110900fd319d65c078fcfd480bcd55cde.png"></p>
<p>13、打包发行前配置，打开目录下的 ‘manifest.json’ 文件，填写相应参数，（注意：后续升级时所填写应用版本名称要大于上一次设置的值）</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/036730acbb677b1d599e723f70f26a148d72a63fc5e6fcb6fdd707f5998c6fbc.png"></p>
<p>14、发行 app,选中项目，点击上方“发行&gt;原生 App- 云打包”</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/536daba7005bc4defa241515e9088467072f6d3fdc24cb615d021dd2540a8e9b.png"></p>
<p>15、在弹出的云打包弹框内填写相应的信息，然后点击下方“打包按钮”</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/40475d8ad2b642196b692cc5cc23f8ee0460db013f29a66ff0ee9e2e0d4e1c69.png"></p>
<p>16、弹框打包校验，点击继续打包</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/29e5c0cb9193afdddc2339a72017d9ad9c9a330f4e67932c565f4c825fcc3c4e.png"></p>
<p>17、打包时终端状态，打包时间有时会稍长，请略微等待</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/8a9871ddcb2402f532cbff7aaed2fe45d9be5d6f571b34e3e28040fa56df961c.png"></p>
<p>打包成功状态</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/91fd6919b6fd1651e07a7ed841fef827b618994070ee81417d125c9176991566.png"></p>
<p>18、点击链接下载安装包，传到手机上即可安装下载</p>
<p>19、登录 uni-admin 后台，找到“系统管理&gt;app 升级中心”，选择对应的 app,点击发布新版，选择原生 app 安装包</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/1eeec26312b66ca4c2150ae8f7a25581786fd7ced7fc7bc70829259a7bc7ea47.png"></p>
<p>进入详情，更新标题及更新内容自行填写，版本号填写与 13 条内相同的应用版本名称，选择文件 选择刚才下载的安装包，强制更新打开则表示上线发行后，再次进入此 app 则必须更新下载新版本才可继续使用，上线发行打开则表示点击发布后立即替换为最新的版本。所有信息配置好后点击发布即可</p>
<p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/4b85dbc9f83fb20e624558caa575ba61fd6b0bc1265e99aad86988d25f24568d.png"></p>
<h2 id="5、基础配置"><a href="#5、基础配置" class="headerlink" title="5、基础配置"></a>5、基础配置</h2><blockquote>
<p>请务必配置好如下的项目，否则系统无法正常运行。</p>
</blockquote>
<h3 id="1、配置存储引擎"><a href="#1、配置存储引擎" class="headerlink" title="1、配置存储引擎"></a>1、配置存储引擎</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/82407025c5fd425e98e7973d9152e7da8f5f2ead22762764235def8da2758361.png"></p>
<blockquote>
<p>如果您不想配置这些账号，可以点击本地存储</p>
</blockquote>
<h3 id="2、配置支付参数"><a href="#2、配置支付参数" class="headerlink" title="2、配置支付参数"></a>2、配置支付参数</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/ad578d19a207a5b7920181793ac47c8a39fa50822f2d2e1f35ac449af0b43787.png"></p>
<blockquote>
<p>如果没有配置支付参数，则系统无法完成支付</p>
</blockquote>
<h3 id="3、小程序配置"><a href="#3、小程序配置" class="headerlink" title="3、小程序配置"></a>3、小程序配置</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/93756c25b55734a5cb738a359d419e8c67834835412362597a2aa766189d3cac.png"></p>
<h3 id="4、短信配置"><a href="#4、短信配置" class="headerlink" title="4、短信配置"></a>4、短信配置</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/baeb56251a4573cf0646b37acdb3290b04feb34d2284721d4c1ae87d5ba2b492.png"></p>
<h3 id="5、物流查询配置"><a href="#5、物流查询配置" class="headerlink" title="5、物流查询配置"></a>5、物流查询配置</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/e6d7b8e3eb28ec2222087c7e96febaded6d20871bb24f03cb20eca9eadedab90.png"></p>
<h3 id="6、uniapp-配置"><a href="#6、uniapp-配置" class="headerlink" title="6、uniapp 配置"></a>6、uniapp 配置</h3><p><img src="/assets/HashMart%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/4cc3fc937fd97be8973063d07bd677ad3bbcf5971085dfea219fd54146788113.png"></p>
<blockquote>
<p>此配置用于 app 端一键登录，如果您没有 app，可以不配置此项目</p>
</blockquote>
]]></content>
      <tags>
        <tag>其他/技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka常用命令总结</title>
    <url>/2024/12/09/archive/Kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="主题脚本命令及其参数"><a href="#主题脚本命令及其参数" class="headerlink" title="主题脚本命令及其参数"></a>主题脚本命令及其参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–bootstrap-server</td>
<td>连接的 Kafka Broker 主机名称和端口号</td>
</tr>
<tr>
<td>–topic</td>
<td>操作的 topic 名称</td>
</tr>
<tr>
<td>–create</td>
<td>创建主题</td>
</tr>
<tr>
<td>–delete</td>
<td>删除主题</td>
</tr>
<tr>
<td>–alter</td>
<td>修改主题</td>
</tr>
<tr>
<td>–list</td>
<td>查看所有主题</td>
</tr>
<tr>
<td>–describe</td>
<td>查看主题详细描述</td>
</tr>
<tr>
<td>–partitions <code>Integer</code></td>
<td>设置分区数</td>
</tr>
<tr>
<td>–replication-factor <code>Integer</code></td>
<td>设置分区副本</td>
</tr>
</tbody></table>
<p>这些参数可以与 <code>kafka-topics.sh</code>（Unix&#x2F;Linux）或 <code>kafka-topics.bat</code>（Windows）命令一起使用，用于管理 Kafka 主题。根据需要，选择使用适当的参数来执行相应的操作。</p>
<h2 id="消费者脚本命令参数："><a href="#消费者脚本命令参数：" class="headerlink" title="消费者脚本命令参数："></a>消费者脚本命令参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–bootstrap-server</td>
<td>连接的 Kafka Broker 主机名称和端口号</td>
</tr>
<tr>
<td>–topic</td>
<td>消费的 topic 名称</td>
</tr>
<tr>
<td>–group-id</td>
<td>消费者所属的消费者组 ID</td>
</tr>
<tr>
<td>–from-beginning</td>
<td>从最早的偏移量开始消费</td>
</tr>
<tr>
<td>–partition <code>Integer</code></td>
<td>指定要消费的分区</td>
</tr>
<tr>
<td>–offsets <code>String</code></td>
<td>指定要消费的分区的偏移量</td>
</tr>
<tr>
<td>–max-messages <code>Integer</code></td>
<td>指定要消费的最大消息数量</td>
</tr>
<tr>
<td>–timeout-ms <code>Integer</code></td>
<td>指定超时时间（毫秒），在等待新消息时使用</td>
</tr>
<tr>
<td>–property <code>String=String</code></td>
<td>设置其他的消费者属性</td>
</tr>
</tbody></table>
<h2 id="生成者脚本命令参数："><a href="#生成者脚本命令参数：" class="headerlink" title="生成者脚本命令参数："></a>生成者脚本命令参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–bootstrap-server</td>
<td>连接的 Kafka Broker 主机名称和端口号</td>
</tr>
<tr>
<td>–topic</td>
<td>发送消息的 topic 名称</td>
</tr>
<tr>
<td>–key</td>
<td>发送消息的键（可选）</td>
</tr>
<tr>
<td>–value</td>
<td>发送消息的值</td>
</tr>
<tr>
<td>–property <code>String=String</code></td>
<td>设置其他的生产者属性</td>
</tr>
</tbody></table>
<p>这些参数可以与 Kafka 提供的相应脚本命令一起使用，用于执行消费者和生产者的操作。根据需要，您可以选择使用适当的参数来配置消费者和生成者的行为。</p>
]]></content>
      <tags>
        <tag>数据/kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 卸载openjdk 安装oraclejdk</title>
    <url>/2024/12/09/archive/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>卸载 openjdk 并且安装 oracle 的 jdk</p>
<h2 id="卸载-Openjdk"><a href="#卸载-Openjdk" class="headerlink" title="卸载 Openjdk"></a>卸载 Openjdk</h2><blockquote>
<p>如果有项目在运行，请先停止项目</p>
</blockquote>
<h3 id="查看现有版本"><a href="#查看现有版本" class="headerlink" title="查看现有版本"></a>查看现有版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409005151150.png"></p>
<h3 id="查询所有跟-Java-相关的安装的-Rpm-包"><a href="#查询所有跟-Java-相关的安装的-Rpm-包" class="headerlink" title="查询所有跟 Java 相关的安装的 Rpm 包"></a>查询所有跟 Java 相关的安装的 Rpm 包</h3><blockquote>
<p>查询 Java 相关的软件包，并过滤掉 noarch 结尾的软件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java |grep -v noarch</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409005937120.png"></p>
<h3 id="卸载所有跟-Openjdk-相关的包"><a href="#卸载所有跟-Openjdk-相关的包" class="headerlink" title="卸载所有跟 Openjdk 相关的包"></a>卸载所有跟 Openjdk 相关的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpm -e --nodeps 需要删除的软件</span></span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.262.b10-1.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.261-2.6.22.2.el7_8.x86_64</span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查是否卸载成功"><a href="#检查是否卸载成功" class="headerlink" title="检查是否卸载成功"></a>检查是否卸载成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409010349617.png"></p>
<h2 id="安装-OracleJDK"><a href="#安装-OracleJDK" class="headerlink" title="安装 OracleJDK"></a>安装 OracleJDK</h2><p>下载地址：<a href="https://www.oracle.com/cn/java/technologies/javase/javase8u211-later-archive-downloads.html">Java Archive Downloads - Java SE 8u211 and later | Oracle 中国</a></p>
<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409010811448.png"></p>
<h3 id="文件上传服务器"><a href="#文件上传服务器" class="headerlink" title="文件上传服务器"></a>文件上传服务器</h3><blockquote>
<p>上传到 opt 路径下</p>
</blockquote>
<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409011203319.png"></p>
<h3 id="创建-Jdk-安装文件夹"><a href="#创建-Jdk-安装文件夹" class="headerlink" title="创建 Jdk 安装文件夹"></a>创建 Jdk 安装文件夹</h3><blockquote>
<p>安装路径不做要求，因此文件夹也不做要求</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /software/jdk/</span><br></pre></td></tr></table></figure>

<h3 id="解压文件夹到指定路径"><a href="#解压文件夹到指定路径" class="headerlink" title="解压文件夹到指定路径"></a>解压文件夹到指定路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar -zxvf jdk-8u391-linux-x64.tar.gz -C 指定路径</span></span><br><span class="line">tar -zxvf jdk-8u391-linux-x64.tar.gz -C /software/jdk/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409011657801.png"></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><code>vim /etc/profile</code> 添加如下内容：</p>
<p>其中 <code>/software/jdk/jdk1.8.0_391/</code> 需要按照实际路径填写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/software/jdk/jdk1.8.0_391</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409012117509.png"></p>
<h3 id="使是配置生效"><a href="#使是配置生效" class="headerlink" title="使是配置生效"></a>使是配置生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h3><p>依次执行如下指令，需要注意&#x2F;software&#x2F;jdk&#x2F;jdk1.8.0_391 为实际目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sbin/</span><br><span class="line"><span class="built_in">ln</span> -s -f /software/jdk/jdk1.8.0_391/jre/bin/java</span><br><span class="line"><span class="built_in">ln</span> -s -f /software/jdk/jdk1.8.0_391/jre/bin/javac</span><br></pre></td></tr></table></figure>

<h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%20%E5%8D%B8%E8%BD%BDopenjdk%20%E5%AE%89%E8%A3%85oraclejdk/image-20240409012712181.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/luChenH/article/details/106940652">linux 卸载 openjdk 安装 jdk_linux 删除 openjdk 重新安装-CSDN 博客</a></li>
</ul>
]]></content>
      <tags>
        <tag>运维/linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令汇总</title>
    <url>/2024/12/09/archive/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>👍 本篇文章是为了巩固和记录一些 linux 下的常用指令，相当于是自己的一本工具书。本文参考以下网站</p>
</blockquote>
<ul>
<li><a href="https://www.linuxcool.com/">Linux 命令大全(手册) – 真正好用的 Linux 命令在线查询网站 (linuxcool.com)</a></li>
<li><a href="https://www.linuxprobe.com/basic-learning-00.html">第 0 章 咱们先来谈谈为什么要学习 Linux 系统 | 《Linux 就该这么学》 (linuxprobe.com)</a></li>
</ul>
<h2 id="修改-Hosts-文件"><a href="#修改-Hosts-文件" class="headerlink" title="修改 Hosts 文件"></a>修改 Hosts 文件</h2><blockquote>
<p>修改 hosts 文件需要拥有对该文件的读写权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/hosts</span><br></pre></td></tr></table></figure>

<blockquote>
<p>刷新 DNS 缓存, 使其立即生效。额，当前步骤好像不做也不会失败。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> /etc/init.d/network restart    <span class="comment"># 重启网络</span></span><br><span class="line"> </span><br><span class="line"> or</span><br><span class="line"> </span><br><span class="line"> /etc/init.d/net.eth0 restart   <span class="comment"># 这个就是重启网卡了</span></span><br></pre></td></tr></table></figure>

<h2 id="查看-Jdk-版本，路径及配置环境变量"><a href="#查看-Jdk-版本，路径及配置环境变量" class="headerlink" title="查看 Jdk 版本，路径及配置环境变量"></a>查看 Jdk 版本，路径及配置环境变量</h2><h3 id="查看-JDK-版本"><a href="#查看-JDK-版本" class="headerlink" title="查看 JDK 版本"></a>查看 JDK 版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/image-20240112222910749.png"></p>
<h3 id="查看-JDK-安装目录"><a href="#查看-JDK-安装目录" class="headerlink" title="查看 JDK 安装目录"></a>查看 JDK 安装目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/image-20240112223413446.png"></p>
<h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><blockquote>
<p>进入环境变量的文件, 需要 <code>sudo</code> 或者 <code>root</code> 用户来执行, 普通用户如何添加 <code>sudo</code> 可参考 <a href="#sudo%E5%91%BD%E4%BB%A4">sudo 命令的使用</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改文件,底部添加如下代码,可参考 <a href="#Vim%E7%9A%84%E4%BD%BF%E7%94%A8">Vim 的使用</a>, <code>JAVA_HOME</code> 的参数值来源于 <a href="#%E6%9F%A5%E7%9C%8BJDK%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95">查看 JDK 安装目录</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/bin/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/image-20240112223931855.png"></p>
<blockquote>
<p>重新加载配置文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="设置-Sudo-用户"><a href="#设置-Sudo-用户" class="headerlink" title="设置 Sudo 用户"></a>设置 Sudo 用户</h2><blockquote>
<p>你不知道 root 账号的密码，但是你需要 root 账号的权限来完成一些命令, 当然不是所有用户都用利用 sudo 使用 root 权限的资格，必须是添加在 <code>/etc/sudoers</code> 文件下用户</p>
</blockquote>
<h3 id="切换到-Root-用户"><a href="#切换到-Root-用户" class="headerlink" title="切换到 Root 用户"></a>切换到 Root 用户</h3><blockquote>
<p>这一步需要 root 用户操作,</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/image-20240112225016655.png"></p>
<h3 id="给-etc-sudoers-文件添加写权限"><a href="#给-etc-sudoers-文件添加写权限" class="headerlink" title="给&#x2F;etc&#x2F;sudoers 文件添加写权限"></a>给&#x2F;etc&#x2F;sudoers 文件添加写权限</h3><blockquote>
<p><a href="https://www.linuxcool.com/chmod">chmod 命令 – 改变文件或目录权限 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+w /etc/sudoers</span><br></pre></td></tr></table></figure>

<h3 id="修改-sudoers-文件"><a href="#修改-sudoers-文件" class="headerlink" title="修改 sudoers 文件"></a>修改 <code>sudoers</code> 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到这行：root ALL&#x3D;(ALL) ALL, 在这行下面添加 <code>&#123;需要添加的用户名&#125;</code> ALL&#x3D;(ALL) ALL</p>
</blockquote>
<p><img src="/assets/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/image-20240112225904580.png"></p>
<blockquote>
<p>sudoers 下面添加普通用户可以使用 <code>sudo</code> 命令的格式 <code>xxx</code> 代表用户名称或者组名称，注意大小写。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx ALL=(ALL) ALL <span class="comment"># 普通用户可以使用sudo命令，但是需要密码</span></span><br><span class="line">%xxx ALL=(ALL) ALL <span class="comment"># 用户组xxx的用户可以使用sudo命令，但是需要密码</span></span><br><span class="line"></span><br><span class="line">xxx ALL=(ALL) NOPASSWD:ALL <span class="comment"># 普通 用户可以使用sudo命令，不需要密码</span></span><br><span class="line"></span><br><span class="line">%xxx ALL=(ALL) NOPASSWD:ALL <span class="comment"># 用户组xxx的用户可以使用sudo命令，不需要密码</span></span><br></pre></td></tr></table></figure>

<h3 id="去除-Root-用户对-Sudoers-文件的写权限"><a href="#去除-Root-用户对-Sudoers-文件的写权限" class="headerlink" title="去除 Root 用户对 Sudoers 文件的写权限"></a>去除 Root 用户对 Sudoers 文件的写权限</h3><blockquote>
<p><a href="https://www.linuxcool.com/chmod">chmod 命令 – 改变文件或目录权限 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u-w /etc/sudoers</span><br></pre></td></tr></table></figure>

<h2 id="设置静态-IP"><a href="#设置静态-IP" class="headerlink" title="设置静态 IP"></a>设置静态 IP</h2><h3 id="切换至-Root-用户-非必须"><a href="#切换至-Root-用户-非必须" class="headerlink" title="切换至 Root 用户 (非必须)"></a>切换至 Root 用户 (非必须)</h3><p>切换成 root 用户，或者后续指令一直使用 sudo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>

<h3 id="修改网卡的配置文件"><a href="#修改网卡的配置文件" class="headerlink" title="修改网卡的配置文件"></a>修改网卡的配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ifconfig查看网卡信息，确认网卡名 ifcfg-enp0s3</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TYPE=<span class="string">&quot;Ethernet&quot;</span></span><br><span class="line">PROXY_METHOD=<span class="string">&quot;none&quot;</span></span><br><span class="line">BROWSER_ONLY=<span class="string">&quot;no&quot;</span></span><br><span class="line"><span class="comment"># BOOTPROTO=&quot;dhcp&quot;   将ip由动态分配改为静态</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">DEFROUTE=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV4_FAILURE_FATAL=<span class="string">&quot;no&quot;</span></span><br><span class="line">IPV6INIT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_AUTOCONF=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_DEFROUTE=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_FAILURE_FATAL=<span class="string">&quot;no&quot;</span></span><br><span class="line">IPV6_ADDR_GEN_MODE=<span class="string">&quot;stable-privacy&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;enp0s3&quot;</span></span><br><span class="line">UUID=<span class="string">&quot;243e2c84-cfa3-4a59-ba16-c656e69058c0&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;enp0s3&quot;</span></span><br><span class="line"><span class="comment"># 网卡开机自启</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置静态IP地址</span></span><br><span class="line">ADDR=<span class="string">&quot;192.168.0.120&quot;</span></span><br><span class="line"><span class="comment"># 配置子网掩码</span></span><br><span class="line">NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line"><span class="comment"># 配置网关</span></span><br><span class="line">GATEWAY=<span class="string">&quot;192.168.0.1&quot;</span> </span><br><span class="line"><span class="comment"># 配置谷歌DNS解析</span></span><br><span class="line">DNS1=<span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line"><span class="comment"># 配置电信的DNS解析</span></span><br><span class="line">DNS2=<span class="string">&quot;114.114.114.114&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>运维/linux</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖管理项目构建工具</title>
    <url>/2024/12/09/archive/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、Maven-简介"><a href="#一、Maven-简介" class="headerlink" title="一、Maven 简介"></a>一、Maven 简介</h2><h3 id="1、为什么学习-Maven"><a href="#1、为什么学习-Maven" class="headerlink" title="1、为什么学习 Maven"></a>1、为什么学习 Maven</h3><h4 id="1-1、Maven-是一个依赖管理工具"><a href="#1-1、Maven-是一个依赖管理工具" class="headerlink" title="1.1、Maven 是一个依赖管理工具"></a>1.1、Maven 是一个依赖管理工具</h4><p><strong>jar 包的规模</strong></p>
<p>随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的 jar 包也越来越多。项目中，一个模块里面用到上百个 jar 包是非常正常的。</p>
<p>比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：</p>
<ul>
<li>Nacos 服务注册发现</li>
<li>Web 框架环境</li>
<li>视图模板技术 Thymeleaf</li>
</ul>
<p>最终却导入了 106 个 jar 包：</p>
<blockquote>
<p>org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile<br>com.netflix.ribbon: ribbon:jar:2.3.0:compile<br>org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile<br>commons-configuration:commons-configuration:jar:1.8:compile<br>org.apache.logging.log4j:log4j-api:jar:2.13.3:compile<br>org.springframework:spring-beans:jar:5.2.11.RELEASE:compile<br>org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile<br>org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile<br>com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile<br>org.bouncycastle:bcprov-jdk15on:jar:1.64:compile<br>org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile<br>org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile<br>com.google.j2objc:j2objc-annotations:jar:1.3:compile<br>com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile<br>io.reactivex:rxjava:jar:1.3.8:compile<br>ch.qos.logback:logback-classic:jar:1.2.3:compile<br>org.springframework:spring-web:jar:5.2.11.RELEASE:compile<br>io.reactivex:rxnetty-servo:jar:0.4.9:runtime<br>org.springframework:spring-core:jar:5.2.11.RELEASE:compile<br>io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile<br>io.github.openfeign.form:feign-form:jar:3.8.0:compile<br>com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile<br>org.apache.httpcomponents:httpcore:jar:4.4.13:compile<br>org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile<br>org.slf4j:jul-to-slf4j:jar:1.7.30:compile<br>com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile<br>org.yaml:snakeyaml:jar:1.26:compile<br>org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile<br>io.reactivex:rxnetty-contexts:jar:0.4.9:runtime<br>org.apache.httpcomponents:httpclient:jar:4.5.13:compile<br>io.github.openfeign:feign-core:jar:10.10.1:compile<br>org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile<br>org.hdrhistogram:HdrHistogram:jar:2.1.9:compile<br>org.springframework:spring-context:jar:5.2.11.RELEASE:compile<br>commons-lang:commons-lang:jar:2.6:compile<br>io.prometheus:simpleclient:jar:0.5.0:compile<br>ch.qos.logback:logback-core:jar:1.2.3:compile<br>org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile<br>com.sun.jersey:jersey-core:jar:1.19.1:runtime<br>javax.ws.rs:jsr311-api:jar:1.1.1:runtime<br>javax.inject:javax.inject:jar:1:runtime<br>org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile<br>com.netflix.ribbon:ribbon-core:jar:2.3.0:compile<br>com.netflix.hystrix:hystrix-core:jar:1.5.18:compile<br>com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime<br>org.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compile<br>org.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compile<br>com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile<br>com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime<br>io.github.openfeign:feign-hystrix:jar:10.10.1:compile<br>io.github.openfeign:feign-slf4j:jar:10.10.1:compile<br>com.alibaba.nacos:nacos-client:jar:1.4.2:compile<br>org.apache.httpcomponents:httpcore-nio:jar:4.4.13:compile<br>com.sun.jersey:jersey-client:jar:1.19.1:runtime<br>org.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compile<br>org.glassfish:jakarta.el:jar:3.0.3:compile<br>org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile<br>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile<br>org.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compile<br>org.aspectj:aspectjweaver:jar:1.9.6:compile<br>com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compile<br>com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile<br>com.alibaba.spring:spring-context-support:jar:1.0.10:compile<br>jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile<br>org.bouncycastle:bcpkix-jdk15on:jar:1.64:compile<br>com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtime<br>com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile<br>com.google.guava:guava:jar:29.0-jre:compile<br>com.google.guava:failureaccess:jar:1.0.1:compile<br>org.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compile<br>com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile<br>com.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compile<br>org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compile<br>org.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compile<br>org.slf4j:slf4j-api:jar:1.7.30:compile<br>commons-io:commons-io:jar:2.7:compile<br>org.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compile<br>org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compile<br>io.reactivex:rxnetty:jar:0.4.9:runtime<br>com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile<br>com.google.code.findbugs:jsr305:jar:3.0.2:compile<br>com.netflix.archaius:archaius-core:jar:0.7.6:compile<br>org.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compile<br>commons-codec:commons-codec:jar:1.14:compile<br>com.netflix.servo:servo-core:jar:0.12.21:runtime<br>com.google.error-prone:error_prone_annotations:jar:2.3.4:compile<br>org.attoparser:attoparser:jar:2.0.5.RELEASE:compile<br>com.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compile<br>org.checkerframework:checker-qual:jar:2.11.1:compile<br>org.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compile<br>commons-fileupload:commons-fileupload:jar:1.4:compile<br>com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile<br>com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime<br>org.unbescape:unbescape:jar:1.1.6.RELEASE:compile<br>org.springframework:spring-jcl:jar:5.2.11.RELEASE:compile<br>com.alibaba.nacos:nacos-common:jar:1.4.2:compile<br>commons-collections:commons-collections:jar:3.2.2:runtime<br>javax.persistence:persistence-api:jar:1.0:compile<br>com.alibaba.nacos:nacos-api:jar:1.4.2:compile<br>org.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compile<br>org.springframework:spring-aop:jar:5.2.11.RELEASE:compile<br>org.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compile<br>org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compile<br>org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compile<br>org.springframework:spring-expression:jar:5.2.11.RELEASE:compile<br>org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile</p>
</blockquote>
<p>而如果使用 Maven 来引入这些 jar 包只需要配置三个『<strong>依赖</strong>』：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- web启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>jar 包的来源问题</strong></p>
<ul>
<li>这个 jar 包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。</li>
<li>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。<ul>
<li>jar 包的名称</li>
<li>jar 包的版本</li>
<li>jar 包内的具体细节</li>
</ul>
</li>
<li>而使用 Maven 后，依赖对应的 jar 包能够<strong>自动下载</strong>，方便、快捷又规范。</li>
</ul>
<p><strong>jar 包的导入问题</strong></p>
<p>在 web 工程中，jar 包必须存放在指定位置：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021101825708.png" alt="image-20231021101825708"></p>
<p>在使用 Maven 之后，通过配置依赖 (jar 包) 的坐标，查找本地仓库中相应 jar 包，若本地仓库没有，则统一从镜像网站或中央仓库中下载：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021102831531.png" alt="image-20231021102831531"></p>
<p><strong>jar 包之间的依赖</strong></p>
<p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p>
<p>下面是前面例子中 jar 包之间的依赖关系：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img006.ab4f2e31.png" alt="images|600"></p>
<p>而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p>
<p>而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。</p>
<h4 id="1-2、Maven-是一个构建工具"><a href="#1-2、Maven-是一个构建工具" class="headerlink" title="1.2、Maven 是一个构建工具"></a>1.2、Maven 是一个构建工具</h4><p><strong>你没有注意过的构建</strong></p>
<p>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021103758624.png" alt="image-20231021103758624|500"></p>
<p><strong>脱离 IDE 环境仍需构建</strong></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image.png" alt="img|490"></p>
<h4 id="1-3、结论"><a href="#1-3、结论" class="headerlink" title="1.3、结论"></a>1.3、结论</h4><ul>
<li><strong>管理规模庞大的 jar 包，需要专门工具。</strong></li>
<li><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></li>
</ul>
<h3 id="2-Maven-介绍"><a href="#2-Maven-介绍" class="headerlink" title="2. Maven 介绍"></a>2. Maven 介绍</h3><p><a href="https://maven.apache.org/what-is-maven.html">https://maven.apache.org/what-is-maven.html</a></p>
<p>Maven 是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。</p>
<p>Maven 就是一个软件，掌握安装、配置、以及基本功能 <strong>（项目构建、依赖管理）</strong> 的理解和使用即可！</p>
<ol>
<li><p><strong>依赖管理：</strong></p>
<p>Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。</p>
</li>
<li><p><strong>构建管理：</strong></p>
<p>项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程</p>
<p>Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_OSOE45UACw.png"></p>
</li>
</ol>
<p><strong>场景 1：</strong> 例如我们项目需要第三方依赖如：Druid 连接池、MySQL 数据库驱动和 Jackson JSON 等处理。那么我们可以将想要的依赖项的信息编写到 Maven 工程的配置文件，Maven 就会自动下载并复制这些依赖项到项目中，无需自己导入 jar 包，管理 jar!</p>
<p><strong>场景 2：</strong> 项目完成开发，我们想要打成 war 部署到服务器中，使用 maven 的构建命令可以快速打包！节省大量时间！</p>
<h3 id="3-Maven-软件工作原理模型图（了解）"><a href="#3-Maven-软件工作原理模型图（了解）" class="headerlink" title="3. Maven 软件工作原理模型图（了解）"></a>3. Maven 软件工作原理模型图（了解）</h3><p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_6AVFQbaXLj.png"></p>
<h2 id="二、Maven-安装和配置"><a href="#二、Maven-安装和配置" class="headerlink" title="二、Maven 安装和配置"></a>二、Maven 安装和配置</h2><h3 id="1-Maven-安装"><a href="#1-Maven-安装" class="headerlink" title="1. Maven 安装"></a>1. Maven 安装</h3><p><a href="https://maven.apache.org/docs/history.html">https://maven.apache.org/docs/history.html</a></p>
<p>各个工具选用版本：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Maven</td>
<td>3.8.8</td>
</tr>
<tr>
<td>JDK</td>
<td>17</td>
</tr>
<tr>
<td>IDEA</td>
<td>2022.2</td>
</tr>
</tbody></table>
<p><strong>安装条件：</strong> maven 需要本机安装 java 环境、必需包含 java_home 环境变量！</p>
<p><strong>软件安装：</strong> 右键解压即可（绿色免安装）</p>
<p><strong>软件结构：</strong></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021110800113.png" alt="image-20231021110800113"></p>
<p><strong>bin</strong>：含有 Maven 的运行脚本</p>
<p>boot：含有 plexus-classworlds 类加载器框架</p>
<p><strong>conf</strong>：含有 Maven 的核心配置文件</p>
<p>lib：含有 Maven 运行时所需要的 Java 类库</p>
<p>LICENSE、NOTICE、README.txt：针对 Maven 版本，第三方软件等简要介绍</p>
<h3 id="2-Maven-环境配置"><a href="#2-Maven-环境配置" class="headerlink" title="2. Maven 环境配置"></a>2. Maven 环境配置</h3><ol>
<li><p>配置 MAVEN_HOME</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021110938230.png" alt="image-20231021110938230"></p>
</li>
<li><p>配置 Path</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_xNL5Fg_ucf.png"></p>
</li>
<li><p>命令测试（cmd 窗口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -v </span><br><span class="line"><span class="comment"># 输出版本信息即可，如果错误，请仔细检查环境变量即可！</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-Maven-功能配置"><a href="#3-Maven-功能配置" class="headerlink" title="3. Maven 功能配置"></a>3. Maven 功能配置</h3><blockquote>
<p>我们需要需改<strong>maven&#x2F;conf&#x2F;settings.xml</strong>配置文件，来修改 maven 的一些默认配置。我们主要休要修改的有三个配置：</p>
<p>1.依赖本地缓存位置（本地仓库位置）</p>
<p>2.maven 下载镜像</p>
<p>3.maven 选用编译项目的 jdk 版本</p>
</blockquote>
<ol>
<li><p>配置本地仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">  | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">  | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment"> &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- conf/settings.xml 55行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置国内阿里镜像</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 jdk17 版本项目构建及功能使用场景</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-17<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>17<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-IDEA-配置本地-Maven-软件"><a href="#4-IDEA-配置本地-Maven-软件" class="headerlink" title="4. IDEA 配置本地 Maven 软件"></a>4. IDEA 配置本地 Maven 软件</h3><blockquote>
<p>我们需要将配置好的 maven 软件，配置到 idea 开发工具中即可！ 注意：idea 工具默认自带 maven 配置软件，但是因为没有修改配置，建议替换成本地配置好的 maven！</p>
</blockquote>
<p>选择本地 maven 软件</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021112046512.png" alt="image-20231021112046512"></p>
<p><strong>注意</strong>：</p>
<p>1、如果本地仓库地址不变化，只有一个原因，就是 maven&#x2F;conf&#x2F;settings.xml 配置文件编写错误！仔细检查即可！</p>
<p>2、一定保证 User settings file 对应之前修改的 settings.xml 的路径，若 不一致，选中 Override 复选框，手动选择配置文件</p>
<h2 id="三、基于-IDEA-创建-Maven-工程"><a href="#三、基于-IDEA-创建-Maven-工程" class="headerlink" title="三、基于 IDEA 创建 Maven 工程"></a>三、基于 IDEA 创建 Maven 工程</h2><h3 id="1-概念梳理-Maven-工程的-GAVP"><a href="#1-概念梳理-Maven-工程的-GAVP" class="headerlink" title="1. 概念梳理 Maven 工程的 GAVP"></a>1. 概念梳理 Maven 工程的 GAVP</h3><p>Maven 工程相对之前的项目，多出一组 gavp 属性，gav 需要我们在创建项目的时候指定，p 有默认值，我们先行了解下这组属性的含义：</p>
<p>Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在 maven 仓库中做一个标识，类似人的姓 - 名！有了具体标识，方便后期项目之间相互引用依赖等！</p>
<p>GAV 遵循一下规则：</p>
<p>​	1） <strong>GroupID 格式</strong>：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。</p>
<p>​		说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。</p>
<p>​		正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang</p>
<p>​	2） <strong>ArtifactID 格式</strong>：产品线名 - 模块名。语义不重复不遗漏，先到仓库中心去查证一下。</p>
<p>​		正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore</p>
<p>​	3） <strong>Version 版本号格式推荐</strong>：主版本号.次版本号.修订号</p>
<p>​		1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。</p>
<p>​		2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。</p>
<p>​		3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。</p>
<p>​		例如： 初始→1.0.0 修改 bug → 1.0.1 功能调整 → 1.1.1 等</p>
<p><strong>Packaging 定义规则：</strong></p>
<p>​	指示将项目打包为什么类型的文件，idea 根据 packaging 值，识别 maven 项目类型！</p>
<p>​	packaging 属性为 jar（默认值），代表普通的 Java 工程，打包以后是.jar 结尾的文件。</p>
<p>​	packaging 属性为 war，代表 Java 的 web 工程，打包以后.war 结尾的文件。</p>
<p>​	packaging 属性为 pom，代表不会打包，用来做继承的父工程。</p>
<h3 id="2-Idea-构建-Maven-Java-SE-工程"><a href="#2-Idea-构建-Maven-Java-SE-工程" class="headerlink" title="2. Idea 构建 Maven Java SE 工程"></a>2. Idea 构建 Maven Java SE 工程</h3><p>注意：此处省略了 version，直接给了一个默认值：<strong>1.0-SNAPSHOT</strong></p>
<p>自己后期可以在项目中随意修改！</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021143559114.png" alt="image-20231021143559114"></p>
<p>创建工程之后，若第一次使用 maven，或者使用的是新的<strong>本地仓库</strong>，idea 右下角会出现以下进度条，表示 maven 正在下载相关插件，等待下载完毕，进度条消失即可</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021145024505.png" alt="image-20231021145024505"></p>
<p>验证 maven 工程是否创建成功，当创建完毕 maven 工程之后，idea 中会自动打开 Maven 视图，如下图：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021145713433.png" alt="image-20231021145713433"></p>
<h3 id="3-Idea-构建-Maven-Java-Web-工程"><a href="#3-Idea-构建-Maven-Java-Web-工程" class="headerlink" title="3. Idea 构建 Maven Java Web 工程"></a>3. Idea 构建 Maven Java Web 工程</h3><ol>
<li><p>手动创建</p>
<ol>
<li><p>创建一个 maven 的 javase 工程</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021150134082.png" alt="image-20231021150134082"></p>
</li>
<li><p>修改 pom.xml 文件打包方式</p>
<p>修改位置：项目下&#x2F;pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 新增一列打包方式packaging --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<strong>web 资源路径</strong>和<strong>web.xml 路径</strong></p>
<p>点击 File–&gt;Project Structure</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021151040531.png" alt="image-20231021151040531"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021151627161.png" alt="image-20231021151627161"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021151753318.png" alt="image-20231021151753318"></p>
</li>
<li><p>刷新和校验</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021152310802.png" alt="image-20231021152310802"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021151921943.png" alt="image-20231021151921943"></p>
</li>
</ol>
</li>
<li><p>插件创建</p>
<ol>
<li><p>安装插件 JBLJavaToWeb</p>
<p>file &#x2F; settings &#x2F; plugins &#x2F; marketplace</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_cHUU_rABB6.png"></p>
</li>
<li><p>创建一个 javasemaven 工程</p>
</li>
<li><p>右键、使用插件快速补全 web 项目</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_ZAPkM7VLgJ.png"></p>
</li>
</ol>
</li>
</ol>
<h3 id="4-Maven-工程项目结构说明"><a href="#4-Maven-工程项目结构说明" class="headerlink" title="4. Maven 工程项目结构说明"></a>4. Maven 工程项目结构说明</h3><p>Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- pom.xml                               # Maven 项目管理文件 </span><br><span class="line">|-- src</span><br><span class="line">    |-- main                              # 项目主要代码</span><br><span class="line">    |   |-- java                          # Java 源代码目录</span><br><span class="line">    |   |   `-- com/example/myapp         # 开发者代码主目录</span><br><span class="line">    |   |       |-- controller            # 存放 Controller 层代码的目录</span><br><span class="line">    |   |       |-- service               # 存放 Service 层代码的目录</span><br><span class="line">    |   |       |-- dao                   # 存放 DAO 层代码的目录</span><br><span class="line">    |   |       `-- model                 # 存放数据模型的目录</span><br><span class="line">    |   |-- resources                     # 资源目录，存放配置文件、静态资源等</span><br><span class="line">    |   |   |-- log4j.properties          # 日志配置文件</span><br><span class="line">    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件</span><br><span class="line">    |   |   `-- static                    # 存放静态资源的目录</span><br><span class="line">    |   |       |-- css                   # 存放 CSS 文件的目录</span><br><span class="line">    |   |       |-- js                    # 存放 JavaScript 文件的目录</span><br><span class="line">    |   |       `-- images                # 存放图片资源的目录</span><br><span class="line">    |   `-- webapp                        # 存放 WEB 相关配置和资源</span><br><span class="line">    |       |-- WEB-INF                   # 存放 WEB 应用配置文件</span><br><span class="line">    |       |   |-- web.xml               # Web 应用的部署描述文件</span><br><span class="line">    |       |   `-- classes               # 存放编译后的 class 文件</span><br><span class="line">    |       `-- index.html                # Web 应用入口页面</span><br><span class="line">    `-- test                              # 项目测试代码</span><br><span class="line">        |-- java                          # 单元测试目录</span><br><span class="line">        `-- resources                     # 测试资源目录</span><br></pre></td></tr></table></figure>

<ul>
<li>pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。</li>
<li>src&#x2F;main&#x2F;java：存放项目的 Java 源代码。</li>
<li>src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;index.jsp：Web 应用的入口页面。</li>
<li>src&#x2F;test&#x2F;java：存放项目的测试代码。</li>
<li>src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。</li>
</ul>
<h2 id="四、基于-IDEA-进行-Maven-工程构建"><a href="#四、基于-IDEA-进行-Maven-工程构建" class="headerlink" title="四、基于 IDEA 进行 Maven 工程构建"></a>四、基于 IDEA 进行 Maven 工程构建</h2><h3 id="1-构建概念和构建过程"><a href="#1-构建概念和构建过程" class="headerlink" title="1. 构建概念和构建过程"></a>1. 构建概念和构建过程</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p>
<p>项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。</p>
<p>同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_REm5kk7DnX.png"></p>
<h3 id="2-命令方式项目构建"><a href="#2-命令方式项目构建" class="headerlink" title="2. 命令方式项目构建"></a>2. 命令方式项目构建</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mvn compile</td>
<td>编译项目，生成 target 文件</td>
</tr>
<tr>
<td>mvn package</td>
<td>打包项目，生成 jar 或 war 文件</td>
</tr>
<tr>
<td>mvn clean</td>
<td>清理编译或打包后的项目结构</td>
</tr>
<tr>
<td>mvn install</td>
<td>打包后上传到 maven 本地仓库</td>
</tr>
<tr>
<td>mvn deploy</td>
<td>只打包，上传到 maven 私服仓库</td>
</tr>
<tr>
<td>mvn site</td>
<td>生成站点</td>
</tr>
<tr>
<td>mvn test</td>
<td>执行测试源码</td>
</tr>
</tbody></table>
<p>war 包打包插件和 jdk 版本不匹配：pom.xml 添加以下代码即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命令触发练习：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn 命令 命令</span><br><span class="line"></span><br><span class="line"><span class="comment">#清理</span></span><br><span class="line">mvn clean</span><br><span class="line"><span class="comment">#清理，并重新打包</span></span><br><span class="line">mvn clean package</span><br><span class="line"><span class="comment">#执行测试代码</span></span><br><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="3-可视化方式项目构建"><a href="#3-可视化方式项目构建" class="headerlink" title="3. 可视化方式项目构建"></a>3. 可视化方式项目构建</h3><p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021153444864.png" alt="image-20231021153444864"></p>
<p>注意：打包（package）和安装（install）的区别是什么</p>
<p>打包是将工程打成 jar 或 war 文件，保存在 target 目录下</p>
<p>安装是将当前工程所生成的 jar 或 war 文件，安装到本地仓库，会按照坐标保存到指定位置</p>
<h3 id="4-构建插件、命令、生命周期命令之间关系"><a href="#4-构建插件、命令、生命周期命令之间关系" class="headerlink" title="4. 构建插件、命令、生命周期命令之间关系"></a>4. 构建插件、命令、生命周期命令之间关系</h3><ul>
<li><p><strong>构建生命周期</strong></p>
<p>我们发现一个情况！当我们执行 package 命令也会自动执行 compile 命令！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ mybatis-base-curd ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ mybatis-base-curd ---</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ mybatis-base-curd ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ mybatis-base-curd ---</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ mybatis-base-curd ---</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ mybatis-base-curd ---</span><br><span class="line">[INFO] Building jar: D:\javaprojects\backend-engineering\part03-mybatis\mybatis-base-curd\target\mybatis-base-curd-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  5.013 s</span><br><span class="line">[INFO] Finished at: 2023-06-05T10:03:47+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>这种行为就是因为构建生命周期产生的！构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！！！</p>
<p><strong>构建周期作用：会简化构建过程</strong></p>
<p>例如：项目打包 mvn clean package 即可。&#x20;</p>
<p>主要两个构建生命周期：</p>
<ul>
<li><p>清理周期：主要是对项目编译生成文件进行清理</p>
<p>  包含命令：clean&#x20;</p>
</li>
</ul>
</li>
<li><p>默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</p>
<pre><code>  包含命令：compile -  test - package - install - deploy
</code></pre>
</li>
<li><p><strong>插件、命令、周期三者关系（了解）</strong></p>
<p>周期→包含若干命令→包含若干插件</p>
<p>使用周期命令构建，简化构建过程！</p>
<p>最终进行构建的是插件！</p>
</li>
</ul>
<h2 id="五、基于-IDEA-进行-Maven-依赖管理"><a href="#五、基于-IDEA-进行-Maven-依赖管理" class="headerlink" title="五、基于 IDEA 进行 Maven 依赖管理"></a>五、基于 IDEA 进行 Maven 依赖管理</h2><h3 id="1-依赖管理概念"><a href="#1-依赖管理概念" class="headerlink" title="1. 依赖管理概念"></a>1. 依赖管理概念</h3><p>Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。</p>
<p>我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven <strong>仓库自动</strong>下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。</p>
<p>总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。</p>
<h3 id="2-Maven-工程核心信息配置和解读（GAVP）"><a href="#2-Maven-工程核心信息配置和解读（GAVP）" class="headerlink" title="2. Maven 工程核心信息配置和解读（GAVP）"></a>2. Maven 工程核心信息配置和解读（GAVP）</h3><p>位置：pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--打包方式</span></span><br><span class="line"><span class="comment">    默认：jar</span></span><br><span class="line"><span class="comment">    jar指的是普通的java项目打包方式！ 项目打成jar包！</span></span><br><span class="line"><span class="comment">    war指的是web项目打包方式！项目打成war包！</span></span><br><span class="line"><span class="comment">    pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar/pom/war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Maven-工程依赖管理配置"><a href="#3-Maven-工程依赖管理配置" class="headerlink" title="3. Maven 工程依赖管理配置"></a>3. Maven 工程依赖管理配置</h3><p>位置：pom.xml</p>
<p>依赖管理和依赖添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   通过编写依赖jar包的gav必要属性，引入第三方依赖！</span></span><br><span class="line"><span class="comment">   scope属性是可选的，可以指定依赖生效范围！</span></span><br><span class="line"><span class="comment">   依赖信息查询方式：</span></span><br><span class="line"><span class="comment">      1. maven仓库信息官网 https://mvnrepository.com/</span></span><br><span class="line"><span class="comment">      2. mavensearch插件搜索</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入具体的依赖包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖范围 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖版本统一提取和维护</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--命名随便,内部制定版本号即可！--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用properties声明版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-依赖范围"><a href="#4-依赖范围" class="headerlink" title="4. 依赖范围"></a>4. 依赖范围</h3><p>通过设置坐标的依赖范围 (scope)，可以设置 对应 jar 包的作用范围：编译环境、测试环境、运行环境</p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>compile</strong></td>
<td>编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。</td>
</tr>
<tr>
<td><strong>provided</strong></td>
<td>已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。</td>
</tr>
<tr>
<td>runtime</td>
<td>运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。</td>
</tr>
<tr>
<td>system</td>
<td>系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。</td>
</tr>
<tr>
<td>import</td>
<td>导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。</td>
</tr>
</tbody></table>
<h3 id="5-Maven-工程依赖下载失败错误解决（重点）"><a href="#5-Maven-工程依赖下载失败错误解决（重点）" class="headerlink" title="5. Maven 工程依赖下载失败错误解决（重点）"></a>5. Maven 工程依赖下载失败错误解决（重点）</h3><p>在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：</p>
<ol>
<li>下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。</li>
<li>依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。</li>
<li>本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>检查网络连接和 Maven 仓库服务器状态。</p>
</li>
<li><p>确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。</p>
</li>
<li><p>清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在 lastupdated 缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的 gav 属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！</p>
<p>例如： pom.xml 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_m3iQtBLARz.png"></p>
</li>
<li><p>或者可以将清除<strong>lastUpdated 文件</strong>的操作写在一个脚本文件中，手动创建文件 “clearLastUpdated.bat”，名字任意，但是后缀必须是 bat，将以下内容复制到文件中</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cls</span> </span><br><span class="line">@<span class="built_in">ECHO</span> OFF </span><br><span class="line"><span class="built_in">SET</span> CLEAR_PATH=D: </span><br><span class="line"><span class="built_in">SET</span> CLEAR_DIR=D:\maven-repository(本地仓库路径)</span><br><span class="line"><span class="built_in">color</span> <span class="number">0</span>a </span><br><span class="line"><span class="built_in">TITLE</span> ClearLastUpdated <span class="keyword">For</span> Windows </span><br><span class="line"><span class="keyword">GOTO</span> MENU </span><br><span class="line">:MENU </span><br><span class="line"><span class="built_in">CLS</span></span><br><span class="line"><span class="built_in">ECHO</span>. </span><br><span class="line"><span class="built_in">ECHO</span>. * * * *  ClearLastUpdated <span class="keyword">For</span> Windows  * * * * </span><br><span class="line"><span class="built_in">ECHO</span>. * * </span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">1</span> 清理*.lastUpdated * </span><br><span class="line"><span class="built_in">ECHO</span>. * * </span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">2</span> 查看*.lastUpdated * </span><br><span class="line"><span class="built_in">ECHO</span>. * * </span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">3</span> 退 出 * </span><br><span class="line"><span class="built_in">ECHO</span>. * * </span><br><span class="line"><span class="built_in">ECHO</span>. * * * * * * * * * * * * * * * * * * * * * * * * </span><br><span class="line"><span class="built_in">ECHO</span>. </span><br><span class="line"><span class="built_in">ECHO</span>.请输入选择项目的序号： </span><br><span class="line"><span class="built_in">set</span> /p ID= </span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">1</span>&quot; <span class="keyword">GOTO</span> cmd1 </span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">2</span>&quot; <span class="keyword">GOTO</span> cmd2 </span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">3</span>&quot; <span class="keyword">EXIT</span> </span><br><span class="line"><span class="built_in">PAUSE</span> </span><br><span class="line">:cmd1 </span><br><span class="line"><span class="built_in">ECHO</span>. 开始清理</span><br><span class="line"><span class="variable">%CLEAR_PATH%</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">%CLEAR_DIR%</span></span><br><span class="line"><span class="keyword">for</span> /r <span class="variable">%%i</span> <span class="keyword">in</span> (*.lastUpdated) <span class="keyword">do</span> <span class="built_in">del</span> <span class="variable">%%i</span></span><br><span class="line"><span class="built_in">ECHO</span>.OK </span><br><span class="line"><span class="built_in">PAUSE</span> </span><br><span class="line"><span class="keyword">GOTO</span> MENU </span><br><span class="line">:cmd2 </span><br><span class="line"><span class="built_in">ECHO</span>. 查看*.lastUpdated文件</span><br><span class="line"><span class="variable">%CLEAR_PATH%</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">%CLEAR_DIR%</span></span><br><span class="line"><span class="keyword">for</span> /r <span class="variable">%%i</span> <span class="keyword">in</span> (*.lastUpdated) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%i</span></span><br><span class="line"><span class="built_in">ECHO</span>.OK </span><br><span class="line"><span class="built_in">PAUSE</span> </span><br><span class="line"><span class="keyword">GOTO</span> MENU </span><br></pre></td></tr></table></figure>

<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021161615994.png" alt="image-20231021161615994"></p>
</li>
</ol>
<h3 id="6-Maven-工程-Build-构建配置"><a href="#6-Maven-工程-Build-构建配置" class="headerlink" title="6. Maven 工程 Build 构建配置"></a>6. Maven 工程 Build 构建配置</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p>
<p>默认情况下，构建不需要额外配置，都有对应的缺省配置。当然了，我们也可以在 pom.xml 定制一些配置，来修改默认构建的行为和产物！</p>
<p>例如：</p>
<ol>
<li>指定构建打包文件的名称，非默认名称</li>
<li>制定构建打包时，指定包含文件格式和排除文件</li>
<li>打包插件版本过低，配置更高版本插件</li>
</ol>
<p>构建配置是在 pom.xml &#x2F; build 标签中指定！</p>
<p><strong>指定打包命名</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认的打包名称：artifactid+verson.打包方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>定义打包名称<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><strong>指定打包文件</strong></p>
<p>如果在 java 文件夹中添加 java 类，会自动打包编译到 classes 文件夹下！</p>
<p>但是在 java 文件夹中添加 xml 文件，默认不会被打包！</p>
<p>默认情况下，按照 maven 工程结构放置的文件会默认被编译和打包！</p>
<p>除此之外、我们可以使用 resources 标签，指定要打包资源的文件夹要把哪些静态资源打包到 classes 根目录下！</p>
<p>应用场景：mybatis 中有时会将用于编写 SQL 语句的映射文件和 mapper 接口都写在 src&#x2F;main&#x2F;java 下的某个包中，此时映射文件就不会被打包，如何解决</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置要打包的资源位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置资源所在目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置包含的资源类型--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置依赖插件</strong></p>
<p>dependencies 标签下引入开发需要的 jar 包！我们可以在 build&#x2F;plugins&#x2F;plugin 标签引入插件！</p>
<p>常用的插件：修改 jdk 版本、tomcat 插件、mybatis 分页插件、mybatis 逆向工程插件等等！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- java编译插件，配jdk的编译版本 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- tomcat插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>8090<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">server</span>&gt;</span>tomcat7<span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Maven-依赖传递和依赖冲突"><a href="#六、Maven-依赖传递和依赖冲突" class="headerlink" title="六、Maven 依赖传递和依赖冲突"></a>六、Maven 依赖传递和依赖冲突</h2><h3 id="1-Maven-依赖传递特性"><a href="#1-Maven-依赖传递特性" class="headerlink" title="1. Maven 依赖传递特性"></a>1. Maven 依赖传递特性</h3><p><strong>概念</strong></p>
<p>假如有 Maven 项目 A，项目 B 依赖 A，项目 C 依赖 B。那么我们可以说 C 依赖 A。也就是说，依赖的关系为：C—&gt;B—&gt;A， 那么我们执行项目 C 时，会自动把 B、A 都下载导入到 C 项目的 jar 包文件夹中，这就是依赖的传递性。</p>
<p><strong>作用</strong></p>
<ul>
<li>简化依赖导入过程</li>
<li>确保依赖版本正确</li>
</ul>
<p><strong>传递的原则</strong></p>
<p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围以及配置</p>
<ul>
<li><p>B 依赖 C 时使用 compile 范围：可以传递</p>
</li>
<li><p>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</p>
</li>
<li><p>B 依赖 C 时，若配置了以下标签，则不能传递</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>依赖传递终止</strong></p>
<ul>
<li>非 compile 范围进行依赖传递</li>
<li>使用 optional 配置终止传递</li>
<li>依赖冲突（传递的依赖已经存在）</li>
</ul>
<p><strong>案例：导入 jackson 依赖</strong></p>
<p>分析：jackson 需要三个依赖</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_9ViibmeAvU.png"></p>
<p>依赖传递关系：data-bind 中，依赖其他两个依赖</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_Wl0Lsj_BLk.png"></p>
<p>最佳导入：直接可以导入 data-bind，自动依赖传递需要的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Maven-依赖冲突特性"><a href="#2-Maven-依赖冲突特性" class="headerlink" title="2. Maven 依赖冲突特性"></a>2. Maven 依赖冲突特性</h3><p>当直接引用或者间接引用出现了相同的 jar 包! 这时呢，一个项目就会出现相同的重复 jar 包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image_km7_szBRUw.png"></p>
<p>maven 自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！</p>
<p><strong>解决依赖冲突（如何选择重复依赖）方式：</strong></p>
<ol>
<li><p>自动选择原则</p>
<ul>
<li><p>短路优先原则（第一原则）</p>
<p>  A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)</p>
<p>  A—&gt;F—&gt;X(version 0.0.2)</p>
<p>  则 A 依赖于 X(version 0.0.2)。</p>
</li>
<li><p>依赖路径长度相同情况下，则“先声明优先”（第二原则）</p>
<p>  A—&gt;E—&gt;X(version 0.0.1)</p>
<p>  A—&gt;F—&gt;X(version 0.0.2)</p>
<p>  在&lt;dependencies&gt;&lt;&#x2F;dependencies&gt;中，先声明的，路径相同，会优先选择！</p>
</li>
</ul>
</li>
<li><p>手动排除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用excludes标签配置依赖的排除  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小案例</p>
<p>伪代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">前提：</span><br><span class="line">   A 1.1 -&gt; B 1.1 -&gt; C 1.1 </span><br><span class="line">   F 2.2 -&gt; B 2.2 </span><br><span class="line">   </span><br><span class="line">pom声明：</span><br><span class="line">   F 2.2</span><br><span class="line">   A 1.1 </span><br></pre></td></tr></table></figure>

<p>请问最终会导入哪些依赖和对应版本？</p>
<p>F2.2  A1.1 B2.2 C1.1</p>
</li>
</ol>
<h2 id="七、Maven-工程继承和聚合关系"><a href="#七、Maven-工程继承和聚合关系" class="headerlink" title="七、Maven 工程继承和聚合关系"></a>七、Maven 工程继承和聚合关系</h2><h3 id="1-Maven-工程继承关系"><a href="#1-Maven-工程继承关系" class="headerlink" title="1. Maven 工程继承关系"></a>1. Maven 工程继承关系</h3><ol>
<li><p>继承概念</p>
<p>Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。</p>
</li>
<li><p>继承作用</p>
<p>在父工程中统一管理项目中的依赖信息。</p>
<p>它的背景是：</p>
<ul>
<li>对一个比较大型的项目进行了模块拆分。</li>
<li>一个 project 下面，创建了很多个 module。</li>
<li>每一个 module 都需要配置自己的依赖信息。</li>
</ul>
<p>它背后的需求是：</p>
<ul>
<li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li>
<li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。<br>  通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。</li>
</ul>
</li>
<li><p>继承语法</p>
<ul>
<li><p>父工程</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
</li>
<li><p>子工程</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>父工程依赖统一管理</p>
<ul>
<li><p>父工程声明版本</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子工程引用版本</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="2-Maven-工程聚合关系"><a href="#2-Maven-工程聚合关系" class="headerlink" title="2. Maven 工程聚合关系"></a>2. Maven 工程聚合关系</h3><ol>
<li><p>聚合概念</p>
<p>Maven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。</p>
</li>
<li><p>聚合作用</p>
<ol>
<li>管理多个子项目：通过聚合，可以将多个子项目组织在一起，方便管理和维护。</li>
<li>构建和发布一组相关的项目：通过聚合，可以在一个命令中构建和发布多个相关的项目，简化了部署和维护工作。</li>
<li>优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</li>
<li>统一管理依赖项：通过聚合，可以在父项目中管理公共依赖项和插件，避免重复定义。</li>
</ol>
</li>
<li><p>聚合语法</p>
<p>父项目中包含的子项目列表。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合演示</p>
<p>通过触发父工程构建命令、引发所有子模块构建！产生反应堆！</p>
</li>
</ol>
<h2 id="八、Maven-私服"><a href="#八、Maven-私服" class="headerlink" title="八、Maven 私服"></a>八、Maven 私服</h2><h3 id="1-Maven-私服简介"><a href="#1-Maven-私服简介" class="headerlink" title="1. Maven 私服简介"></a>1. Maven 私服简介</h3><p>①私服简介</p>
<p>Maven 私服是一种特殊的 Maven 远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）。</p>
<blockquote>
<p>当然也并不是说私服只能建立在局域网，也有很多公司会直接把私服部署到公网，具体还是得看公司业务的性质是否是保密的等等，因为局域网的话只能在公司用，部署到公网的话员工在家里也可以办公使用。</p>
</blockquote>
<p>建立了 Maven 私服后，当局域网内的用户需要某个构件时，会按照如下顺序进行请求和下载。</p>
<p>请求本地仓库，若本地仓库不存在所需构件，则跳转到第 2 步；</p>
<p>请求 Maven 私服，将所需构件下载到本地仓库，若私服中不存在所需构件，则跳转到第 3 步。</p>
<p>请求外部的远程仓库，将所需构件下载并缓存到 Maven 私服，若外部远程仓库不存在所需构件，则 Maven 直接报错。</p>
<p>此外，一些无法从外部仓库下载到的构件，也能从本地上传到私服供其他人使用。</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231021164631791.png" alt="image-20231021164631791"></p>
<p>②Maven 私服的优势</p>
<ol>
<li><p>节省外网带宽<br>消除对外部远程仓库的大量重复请求（会消耗很大量的带宽），降低外网带宽压力。</p>
</li>
<li><p>下载速度更快<br>Maven 私服位于局域网内，从私服下载构建更快更稳定。</p>
</li>
<li><p>便于部署第三方构件<br>有些构件无法从任何一个远程仓库中获得（如：公司或组织内部的私有构件、Oracle 的 JDBC 驱动等），建立私服之后，就可以将这些构件部署到私服中，供内部 Maven 项目使用。</p>
</li>
<li><p>提高项目的稳定性，增强对项目的控制<br>如果不建立私服，那么 Maven 项目的构件就高度依赖外部的远程仓库，若外部网络不稳定，则项目的构建过程也会变得不稳定。建立私服后，即使外部网络状况不佳甚至中断，只要私服中已经缓存了所需的构件，Maven 也能够正常运行。私服软件（如：Nexus）提供了很多控制功能（如：权限管理、RELEASE&#x2F;SNAPSHOT 版本控制等），可以对仓库进行一些更加高级的控制。</p>
</li>
<li><p>降低中央仓库得负荷压力<br>由于私服会缓存中央仓库得构件，避免了很多对中央仓库的重复下载，降低了中央仓库的负荷。</p>
</li>
</ol>
<p>③常见的 Maven 私服产品</p>
<ol>
<li>Apache 的 Archiva</li>
<li>JFrog 的 Artifactory</li>
<li>Sonatype 的 Nexus（[ˈneksəs]）（当前最流行、使用最广泛）</li>
</ol>
<h3 id="2-Nexus-下载安装"><a href="#2-Nexus-下载安装" class="headerlink" title="2. Nexus 下载安装"></a>2. Nexus 下载安装</h3><p>下载地址：<a href="https://help.sonatype.com/repomanager3/product-information/download">https://help.sonatype.com/repomanager3/product-information/download</a></p>
<p>解压，以管理员身份打开 CMD，进入 bin 目录下，执行.&#x2F;nexus &#x2F;run 命令启动</p>
<p>访问 Nexus 首页</p>
<p>首页地址：<a href="http://localhost:8081/%EF%BC%8C8081">http://localhost:8081/，8081</a> 为默认端口号</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img001.612496a3.png" alt="images"></p>
<h3 id="3-初始设置"><a href="#3-初始设置" class="headerlink" title="3. 初始设置"></a>3. 初始设置</h3><p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img002.e1ac8197.png" alt="images"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031171116756.png" alt="image-20231031171116756"></p>
<p>这里参考提示：</p>
<ul>
<li>用户名：admin</li>
<li>密码：查看 <strong>E:\Server\nexus-3.61.0-02-win64\sonatype-work\nexus3\admin.password</strong> 文件</li>
</ul>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031171242874.png" alt="image-20231031171242874"></p>
<p>继续执行初始化：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img005.4b81e5ab.png" alt="images"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img006.43ebb0ac.png" alt="images"></p>
<p>匿名登录，启用还是禁用？由于启用匿名登录后，后续操作比较简单，这里我们演示禁用匿名登录的操作：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031171607378.png" alt="image-20231031171607378"></p>
<p>初始化完毕：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031171708085.png" alt="image-20231031171708085"></p>
<h3 id="4-Nexus-上的各种仓库"><a href="#4-Nexus-上的各种仓库" class="headerlink" title="4. Nexus 上的各种仓库"></a>4. Nexus 上的各种仓库</h3><p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img009.7f737ed7.png" alt="images"></p>
<table>
<thead>
<tr>
<th>仓库类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>proxy</td>
<td>某个远程仓库的代理</td>
</tr>
<tr>
<td>group</td>
<td>存放：通过 Nexus 获取的第三方 jar 包</td>
</tr>
<tr>
<td>hosted</td>
<td>存放：本团队其他开发人员部署到 Nexus 的 jar 包</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>仓库名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>maven-central</td>
<td>Nexus 对 Maven 中央仓库的代理</td>
</tr>
<tr>
<td>maven-public</td>
<td>Nexus 默认创建，供开发人员下载使用的组仓库</td>
</tr>
<tr>
<td>maven-releases</td>
<td>Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 releases 版本</td>
</tr>
<tr>
<td>maven-snapshots</td>
<td>Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 snapshots 版本</td>
</tr>
</tbody></table>
<p>初始状态下，这几个仓库都没有内容：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img010.e3573d0b.png" alt="images"></p>
<h3 id="5-通过-Nexus-下载-Jar-包"><a href="#5-通过-Nexus-下载-Jar-包" class="headerlink" title="5. 通过 Nexus 下载 Jar 包"></a>5. 通过 Nexus 下载 Jar 包</h3><p>修改本地 maven 的核心配置文件 settings.xml，设置新的本地仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个新的 Maven 本地仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/maven-repository-new<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把我们原来配置阿里云仓库地址的 mirror 标签改成下面这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus mine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 url 标签是这么来的：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img012.5a3b1f11.png" alt="images"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031172137288.png" alt="image-20231031172137288"></p>
<p>把上图中看到的地址复制出来即可。如果我们在前面允许了匿名访问，到这里就够了。但如果我们禁用了匿名访问，那么接下来我们还要继续配置 settings.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>atguigu<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里需要<strong>格外注意</strong>：server 标签内的 id 标签值必须和 mirror 标签中的 id 值一样。</p>
<p>找一个用到框架的 Maven 工程，执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn clean compile</span><br></pre></td></tr></table></figure>

<p>下载过程日志：</p>
<blockquote>
<p>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom">http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom</a><br>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom">http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom</a> (2.6 kB at 110 kB&#x2F;s)<br>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom</a><br>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom</a> (9.0 kB at 376 kB&#x2F;s)<br>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom</a><br>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom</a> (8.5 kB at 404 kB&#x2F;s)<br>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom">http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom</a><br>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom">http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom</a> (12 kB at 463 kB&#x2F;s)</p>
</blockquote>
<p>下载后，Nexus 服务器上就有了 jar 包：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img014.cc0e87c3.png" alt="images"></p>
<p>若下载速度太慢，可以设置私服中中央仓库的地址为阿里云仓库地址</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031175035345.png" alt="image-20231031175035345"></p>
<p>修改为：<a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231031175134745.png" alt="image-20231031175134745"></p>
<h3 id="6-将-Jar-包部署到-Nexus"><a href="#6-将-Jar-包部署到-Nexus" class="headerlink" title="6. 将 Jar 包部署到 Nexus"></a>6. 将 Jar 包部署到 Nexus</h3><p>maven 工程中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：这里 snapshotRepository 的 id 标签必须和 settings.xml 中指定的 mirror 标签的 id 属性一致。</p>
<p>执行部署命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Uploading to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml</a><br>Uploaded to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml</a> (786 B at 19 kB&#x2F;s)<br>Uploading to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml</a><br>Uploaded to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml</a> (300 B at 6.5 kB&#x2F;s)<br>[INFO] ————————————————————————<br>[INFO] Reactor Summary:<br>[INFO]<br>[INFO] demo-imperial-court-ms-show 1.0-SNAPSHOT ……….. SUCCESS [ 1.875 s]<br>[INFO] demo09-base-entity …………………………… SUCCESS [ 21.883 s]<br>[INFO] demo10-base-util …………………………….. SUCCESS [ 0.324 s]<br>[INFO] demo08-base-api ……………………………… SUCCESS [ 1.171 s]<br>[INFO] demo01-imperial-court-gateway …………………. SUCCESS [ 0.403 s]<br>[INFO] demo02-user-auth-center ………………………. SUCCESS [ 2.932 s]<br>[INFO] demo03-emp-manager-center …………………….. SUCCESS [ 0.312 s]<br>[INFO] demo04-memorials-manager-center ……………….. SUCCESS [ 0.362 s]<br>[INFO] demo05-working-manager-center …………………. SUCCESS [ 0.371 s]<br>[INFO] demo06-mysql-data-provider ……………………. SUCCESS [ 6.779 s]<br>[INFO] demo07-redis-data-provider 1.0-SNAPSHOT ………… SUCCESS [ 0.273 s]</p>
</blockquote>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/img015.b413af9d.png" alt="images"></p>
<h3 id="7-引用别人部署的-Jar-包"><a href="#7-引用别人部署的-Jar-包" class="headerlink" title="7. 引用别人部署的 Jar 包"></a>7. 引用别人部署的 Jar 包</h3><p>maven 工程中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="九、Maven-综合案例"><a href="#九、Maven-综合案例" class="headerlink" title="九、Maven 综合案例"></a>九、Maven 综合案例</h2><h3 id="1-项目需求和结构分析"><a href="#1-项目需求和结构分析" class="headerlink" title="1. 项目需求和结构分析"></a>1. 项目需求和结构分析</h3><p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image123.png" alt="img"></p>
<p>需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。</p>
<p>项目架构：</p>
<ol>
<li>用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。<ul>
<li>spring-context 6.0.6</li>
<li>spring-core 6.0.6</li>
<li>spring-beans 6.0.6</li>
<li>common-service</li>
</ul>
</li>
<li>订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。<ul>
<li>spring-context 6.0.6</li>
<li>spring-core 6.0.6</li>
<li>spring-beans 6.0.6</li>
<li>spring-security 6.0.6</li>
<li>common-service</li>
</ul>
</li>
<li>通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。<ul>
<li>commons-io 2.11.0</li>
<li>junit 5.9.2</li>
</ul>
</li>
</ol>
<h3 id="2-项目搭建和统一构建"><a href="#2-项目搭建和统一构建" class="headerlink" title="2. 项目搭建和统一构建"></a>2. 项目搭建和统一构建</h3><h4 id="①父模块-micro-shop"><a href="#①父模块-micro-shop" class="headerlink" title="①父模块 (micro-shop)"></a>①父模块 (micro-shop)</h4><p>创建工程：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023112630117.png" alt="image-20231023112630117"></p>
<p>pom.xml 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micro-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--知识点：父工程的打包方式为pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commons.version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">commons.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>5.9.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- spring-context会依赖传递core/beans --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- jackson-databind会依赖传递core/annotations --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- commons-io --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 统一更新子工程打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可选操作：删除 src 目录</p>
<h4 id="②通用模块-common-service"><a href="#②通用模块-common-service" class="headerlink" title="②通用模块 (common-service)"></a>②通用模块 (common-service)</h4><p>创建工程：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023114531521.png" alt="image-20231023114531521"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023114649705.png" alt="image-20231023114649705"></p>
<p>pom.xml 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micro-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--知识点：打包方式默认就是jar，因此可以省略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置spring-context，继承父工程版本，自动传递 core / beans --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置jackson-databind，继承父工程版本，自动传递 core / annotations --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置commons-io，继承父工程版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置junit，继承父工程版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="③用户模块-user-service"><a href="#③用户模块-user-service" class="headerlink" title="③用户模块 (user-service)"></a>③用户模块 (user-service)</h4><p>创建工程：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023115404302.png" alt="image-20231023115404302"></p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023115707282.png" alt="image-20231023115707282"></p>
<p>pom.xml 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micro-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web工程打包方式为war --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖传递结果：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023120621402.png" alt="image-20231023120621402"></p>
<h4 id="④订单模块-order-service"><a href="#④订单模块-order-service" class="headerlink" title="④订单模块 (order-service)"></a>④订单模块 (order-service)</h4><p>创建工程，并使用插件转为 web 工程：</p>
<p><img src="/assets/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/image-20231023120733029.png" alt="image-20231023120733029"></p>
<p>pom.xml 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micro-shop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web工程打包方式为war --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时，查看父工程的 pom.xml，会发现其中已经自动聚合了子工程：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>common-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>order-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>后端/Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>ORECAL19C安装</title>
    <url>/2024/12/09/archive/ORECAL19C%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载了不会使用气死了, 气死了</span><br></pre></td></tr></table></figure>

<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107104952.png"></p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107104939.png"></p>
<p>🌯 注意此处创建新的 windows 用户，不然会导致后续安装没有权限的问题。</p>
<p>🔑 admin!@#456</p>
<p>🔒 orecal</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107105313.png"></p>
<p>此处的密码设置的 1234，要求不能设置简单密码</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107114134.png"></p>
<p>要求不能设置简单密码，非要用简单密码，会出现提示， 点击继续即可</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107114406.png"></p>
<p>先决条件检查这一步等待即可，不满足安装条件的话就木有啥办法了。</p>
<p>查看概要之后，点击安装</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107114723.png"></p>
<p>这一步就只剩下漫长的等待了</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107115140.png"></p>
<p>安装过程中会出现网络权限的获取，直接给权限即可</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107115157.png"></p>
<p>%42 的时候，进度很慢，耐心，耐心即可</p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107115629.png"></p>
<p><img src="/assets/ORECAL19C%E5%AE%89%E8%A3%85/Pasted%20image%2020231107130049.png"></p>
]]></content>
      <tags>
        <tag>数据/oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian插件汇总</title>
    <url>/2024/12/09/archive/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Webpage-HTML-Export"><a href="#Webpage-HTML-Export" class="headerlink" title="Webpage HTML Export"></a>Webpage HTML Export</h2><blockquote>
<p>❗❗❗ 该插件必须置顶, 强烈推荐</p>
</blockquote>
<h3 id="插件简介"><a href="#插件简介" class="headerlink" title="插件简介"></a>插件简介</h3><p>导出你的 markdown 文档成 HTML，毕竟不是所有人的电脑上都有 typora 或者 obsidian 这类的 markdown 编辑器, 但是所有人的电脑上都有浏览器呀 🎣</p>
<h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><blockquote>
<p>该插件配置项较多，但大部分参数均可按照默认值设置。我本人在使用时仅调整了了 <a href="#%E5%B5%8C%E5%85%A5%E9%85%8D%E7%BD%AE">嵌入配置</a>，仅在此处列举比较关键的几项配置</p>
</blockquote>
<h4 id="页面功能配置"><a href="#页面功能配置" class="headerlink" title="页面功能配置"></a>页面功能配置</h4><blockquote>
<p>Page Feature 英文配置截图</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108220206502.png"></p>
<blockquote>
<p>Page Feature 中文配置截图</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108220512903.png"></p>
<h4 id="页面行为配置"><a href="#页面行为配置" class="headerlink" title="页面行为配置"></a>页面行为配置</h4><blockquote>
<p>Page Behaviors 英文配置截图</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108144339762.png"></p>
<blockquote>
<p>Page Behaviors 中文配置截图</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108144502706.png"></p>
<h4 id="嵌入配置"><a href="#嵌入配置" class="headerlink" title="嵌入配置"></a>嵌入配置</h4><p>简单在这讲一下嵌入配置是个什么东西，先说结论，再讲原理</p>
<ul>
<li>结论：下图中的三个配置全部打开，导出文件时就会仅导出一个 html 文件，否则将会多导出一个依赖文件。</li>
<li>原理：该插件在生成 <code>html</code> 时，会根据下面的参数来判断是否把 <code>js</code> 和 <code>css</code> 代码导入到 <code>html</code>。这些 <code>js</code> 和 <code>css</code> 配置可能是有很大一部分是重复的，也就是说不一样的文章可以复用同一个 <code>js</code> 和 <code>css</code>。因此插件作者贴心的给你了是否选择代码复用的权利。不过，强烈建议按照我的配置来，毕竟你的存储内存不值钱。。。。。。</li>
</ul>
<blockquote>
<p>Embedding options 英文配置</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108144554664.png"></p>
<blockquote>
<p>Embedding options 中文配置</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108145111699.png"></p>
<h3 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h3><blockquote>
<p>插件的使用可以参考下 GIF</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/recording.gif"></p>
<p>😀 导出时建议选择独立文档</p>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108220740346.png"></p>
<h2 id="Clear-Images-Settings"><a href="#Clear-Images-Settings" class="headerlink" title="Clear Images Settings"></a>Clear Images Settings</h2><h3 id="插件简介-1"><a href="#插件简介-1" class="headerlink" title="插件简介"></a>插件简介</h3><p>我们在进行 markdown 写作时, 通常会粘贴一些截图. 但是有的时候, 我们对于截图中的某些内容进行了修改, 我们通常是截取新的截图, 而不是替换旧图片, 因此我们的附件文件夹会存在很多没有引用的文件, 该插件就是为了解决该问题</p>
<h3 id="插件配置-1"><a href="#插件配置-1" class="headerlink" title="插件配置"></a>插件配置</h3><blockquote>
<p>英文配置截图</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226132337125.png"></p>
<blockquote>
<p>中文配置对照</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240108144104191.png"></p>
<h3 id="插件使用-1"><a href="#插件使用-1" class="headerlink" title="插件使用"></a>插件使用</h3><blockquote>
<p><code>ctrl</code> + <code>p</code> 打开对话面板, 输入 <code>clear</code>, 参考下图, 按需清除</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226132651095.png"></p>
<blockquote>
<p>开启了删除日志, 成功删除后会有如下界面</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226132825609.png"></p>
<h2 id="Custom-Attachment-Location"><a href="#Custom-Attachment-Location" class="headerlink" title="Custom Attachment Location"></a>Custom Attachment Location</h2><h3 id="插件简介-2"><a href="#插件简介-2" class="headerlink" title="插件简介"></a>插件简介</h3><blockquote>
<p>在以前写使用 typora 写文档时, 截图喜欢按照一个 md 文件对应一个附件文件夹的方式设置, 不过 Obsidian 不支持, 仅能选择一个固定的文件夹作为附件文件夹, 该插件就是为了解决该问题</p>
</blockquote>
<h3 id="插件配置-2"><a href="#插件配置-2" class="headerlink" title="插件配置"></a>插件配置</h3><blockquote>
<p>英文配置</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226133823731.png"></p>
<blockquote>
<p>中文配置对照</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226133952006.png"></p>
<h3 id="插件使用-2"><a href="#插件使用-2" class="headerlink" title="插件使用"></a>插件使用</h3><blockquote>
<p>复制图片后直接粘贴, 图片会放入按照规则放入对应的文件夹, 如果该文件夹不存在则自动生成,. 举个例子: 附件位置为 <code>./assets/$&#123;filename&#125;</code> , 文章为 <code>Obsidian插件汇总</code> , 则该文章下的所有图片均放在了 <code>./assets/Obsidian插件汇总</code> 文件夹下, 如下图所示</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20231226134708247.png"></p>
<h2 id="Advanced-Tables-Plugin"><a href="#Advanced-Tables-Plugin" class="headerlink" title="Advanced Tables Plugin"></a>Advanced Tables Plugin</h2><h3 id="插件简介-3"><a href="#插件简介-3" class="headerlink" title="插件简介"></a>插件简介</h3><blockquote>
<p>markdown 写作时, 关于表格的使用也是一大难题, 该插件可以极大的方便了使用, Obsidian 的 15.13 版本提供了实施预览模式下的对表格的编辑功能。不过再源码模式下使用该插件依然是很好的</p>
</blockquote>
<h3 id="插件配置-3"><a href="#插件配置-3" class="headerlink" title="插件配置"></a>插件配置</h3><blockquote>
<p>直接按照下图配置即可, 没什么按需调整的选项</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240104154542177.png"></p>
<h3 id="插件使用-3"><a href="#插件使用-3" class="headerlink" title="插件使用"></a>插件使用</h3><blockquote>
<p>插件的集团使用可参考下 GIF 以及表格</p>
</blockquote>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/PixPin_2024-01-04_16-24-52.gif"></p>
<table>
<thead>
<tr>
<th>热键</th>
<th>行为</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Tab</td>
<td>下一个单元格</td>
<td>执行格式化</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>前一个单元格</td>
<td>执行格式化</td>
</tr>
<tr>
<td>Enter</td>
<td>下一行</td>
<td>跳转至下一行, 没有下一行则新增</td>
</tr>
<tr>
<td>Ctrl + Shift + D</td>
<td>打开表格帮助面板</td>
<td>需要更新值 obsidian 的 v1.5.3 版本以上才可用</td>
</tr>
</tbody></table>
<h2 id="Markdown-Prettifier"><a href="#Markdown-Prettifier" class="headerlink" title="Markdown Prettifier"></a>Markdown Prettifier</h2><h3 id="插件简介-4"><a href="#插件简介-4" class="headerlink" title="插件简介"></a>插件简介</h3><blockquote>
<p>该插件主要</p>
</blockquote>
<h2 id="Mousewheel-image-zoom"><a href="#Mousewheel-image-zoom" class="headerlink" title="Mousewheel-image-zoom"></a>Mousewheel-image-zoom</h2><h3 id="插件简介-5"><a href="#插件简介-5" class="headerlink" title="插件简介"></a>插件简介</h3><p>主要作用是用来进行图片大小的控制</p>
<h3 id="插件配置-4"><a href="#插件配置-4" class="headerlink" title="插件配置"></a>插件配置</h3><p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240418143729742.png" alt="|695"></p>
<p><strong>注意事项：</strong> 如果选择了 <code>ctrl</code> 为快捷键，需要到设置 -&gt;选项 -&gt;外观下关闭快速调整字体大小功能</p>
<p><img src="/assets/Obsidian%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/image-20240418143845538.png" alt="|635"></p>
]]></content>
      <tags>
        <tag>工具/obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>Orecal数据库还原</title>
    <url>/2024/12/09/archive/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<blockquote>
<p>以下所有操作基于刚安装的 orecal11g 数据库, 本文中的所有命令都是在具有管理员权限的 cmd 中执行</p>
</blockquote>
<h2 id="使用-Dba-账号登录"><a href="#使用-Dba-账号登录" class="headerlink" title="使用 Dba 账号登录"></a>使用 Dba 账号登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlplus/nolog</span><br><span class="line">conn &#123;sys&#125;/&#123;1234&#125;@orcl as sysdba;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sys</code> dba 的账号, 一般是 sys, 或者 system</li>
<li><code>1234</code> 对应账号的密码, 安装数据库的时候有设置</li>
</ul>
<h3 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h3><p><img src="/assets/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/image-20231109161949928.png"></p>
<h2 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE &#123;ykspace&#125; DATAFILE <span class="string">&#x27;&#123;D:\soft\Orecal\oradata\orcl\ykspace.dbf&#125;&#x27;</span> SIZE <span class="number">1000</span>M AUTOEXTEND <span class="keyword">ON</span> NEXT <span class="number">100</span>M EXTENT MANAGEMENT <span class="keyword">LOCAL</span> UNIFORM SIZE <span class="number">256</span>K;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ykspace</code> 是表空间名称</p>
</li>
<li><p><code>&#39;D:\soft\Orecal\oradata\orcl\ykspace.dbf&#39;</code> 表空间所在路径, 已办基于 Orecal 安装路径</p>
</li>
</ul>
<h3 id="示例图-1"><a href="#示例图-1" class="headerlink" title="示例图"></a>示例图</h3><p><img src="/assets/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/image-20231109162610185.png"></p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>   &#123;yksoft&#125;  IDENTIFIED <span class="keyword">BY</span> &#123;yksoft1919&#125; <span class="keyword">DEFAULT</span> TABLESPACE &#123;ykspace&#125; TEMPORARY TABLESPACE temp;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>yksoft</code> 用户名</li>
<li><code>yksoft1919</code> 密码</li>
<li><code>ykspace</code> 上一步创建的表空间, 也就是给用户分配的表空间</li>
</ul>
<h3 id="示例图-2"><a href="#示例图-2" class="headerlink" title="示例图"></a>示例图</h3><p><img src="/assets/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/image-20231109163029381.png"></p>
<h2 id="授权给用户"><a href="#授权给用户" class="headerlink" title="授权给用户"></a>授权给用户</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">connect</span>,dba <span class="keyword">to</span>  &#123;yksoft&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>yksoft</code> 被授权的用户名</li>
</ul>
<h3 id="示例图-3"><a href="#示例图-3" class="headerlink" title="示例图"></a>示例图</h3><p><img src="/assets/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/image-20231109163052788.png"></p>
<h2 id="创建-Orecal-可以读取的文件夹"><a href="#创建-Orecal-可以读取的文件夹" class="headerlink" title="创建 Orecal 可以读取的文件夹"></a>创建 Orecal 可以读取的文件夹</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> directory &#123;gqys&#125; <span class="keyword">as</span> &#123;<span class="string">&#x27;D:\data&#x27;</span>&#125;;   <span class="comment">-- 这个路径是用来存放数据库备份文件的路径</span></span><br><span class="line"><span class="keyword">grant</span> read,write <span class="keyword">on</span> directory gqys <span class="keyword">to</span> &#123;yksoft&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gqys</code> 创建的 orecl 可读取的文件夹名称</li>
<li><code>&#39;D:\data&#39;</code> 文件夹的路径</li>
<li><code>yksoft</code> 授权文件夹给该用户</li>
</ul>
<h2 id="执行还原"><a href="#执行还原" class="headerlink" title="执行还原"></a>执行还原</h2><p><code>yksoft/yksoft1919</code> 用户名&#x2F;用户密码 <code>yksoft:yksoft </code> 数据原属用户: 导入的目标用户</p>
<p><code>gqys_oracle11201_20190802.DMP</code> 备份的文件 <code>gqys</code> 上一步创建的可读文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impdp &#123;user&#125;/&#123;密码&#125;@orcl remap_schema=&#123;yksoft&#125;:&#123;user&#125; Remap_tablespace=&#123;ykspace&#125;:&#123;newykspace&#125; dumpfile=&#123;GQYS_ORACLE11201_20230802.DMP&#125;  DIRECTORY=&#123;dir&#125; table_exists_action=replace</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user</code> 用户名</li>
<li><code>pwd</code> 密码</li>
<li><code>yksoft</code> 原用户名</li>
<li><code>ykspace</code> 原表空间名</li>
<li><code>newykspace</code> 现表空间</li>
<li><code>GQYS_ORACLE11201_20230802.DMP</code> 备份文件, 需要在授权文件夹下</li>
<li><code>dir</code> 授权文件夹名称</li>
</ul>
<h3 id="示例图（新终端）"><a href="#示例图（新终端）" class="headerlink" title="示例图（新终端）"></a>示例图（新终端）</h3><p><img src="/assets/Orecal%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E5%8E%9F/image-20231109175030562.png"></p>
]]></content>
      <tags>
        <tag>数据/oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>PGSQL基本概念</title>
    <url>/2025/03/18/archive/PGSQL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote>
<p>本文用生活中常见的比喻帮你梳理 <strong>PostgreSQL 的核心概念</strong>，保证通俗易懂。👇</p>
</blockquote>
<h2 id="数据库（Database）-→-仓库"><a href="#数据库（Database）-→-仓库" class="headerlink" title="数据库（Database） → 仓库"></a>数据库（Database） → 仓库</h2><ul>
<li><p><strong>是什么</strong>：一个独立的仓库，存放所有数据。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>完全隔离：不同仓库之间不能直接拿对方的货物（除非特殊操作）。</li>
<li>仓库名示例：<code>订单库</code>、<code>用户库</code>、<code>日志库</code>。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 订单库;   <span class="comment">-- 建一个仓库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE 订单库;     <span class="comment">-- 拆掉仓库（慎用！）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模式（Schema）-→-货架"><a href="#模式（Schema）-→-货架" class="headerlink" title="模式（Schema） → 货架"></a>模式（Schema） → 货架</h2><ul>
<li><p><strong>是什么</strong>：仓库里的货架，用来分类存放货物。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>逻辑分区：一个仓库可以有多个货架（如 <code>公共货架</code>、<code>VIP货架</code>）。</li>
<li>默认货架：<code>public</code>（如果没指定货架，默认放这里）。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA VIP货架;          <span class="comment">-- 新建货架 </span></span><br><span class="line"><span class="keyword">SET</span> search_path <span class="keyword">TO</span> VIP货架;     <span class="comment">-- 告诉仓库员：“以后默认找这个货架” 该值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>补充</strong><br>PGSQL 的环境变量中包含一个 <code>search_path</code> 参数，<code>search_path</code> 路径中的第一个模式被称为 <code>current schema</code> 该值通常为 <code>&quot;$user&quot;,public</code> 代表先从和用户名一致的货架下查询，该货架查询不到，则查询公共货架 <code>public</code></p>
</li>
</ul>
<h2 id="用户（User）-→-仓库管理员"><a href="#用户（User）-→-仓库管理员" class="headerlink" title="用户（User） → 仓库管理员"></a>用户（User） → 仓库管理员</h2><ul>
<li><p><strong>是什么</strong>：管理仓库的人，不同管理员有不同的钥匙和权限。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>权限分级：有的能进货（写数据），有的只能查库存（读数据）。</li>
<li>用户示例：<code>老板</code>、<code>库管员</code>、<code>财务员</code>。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 库管员 <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;123&#x27;</span>;  <span class="comment">-- 招个新管理员 </span></span><br><span class="line"><span class="keyword">GRANT</span> 进货权限 <span class="keyword">TO</span> 库管员;                <span class="comment">-- 给权限</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="表（Table）-→-储物箱"><a href="#表（Table）-→-储物箱" class="headerlink" title="表（Table） → 储物箱"></a>表（Table） → 储物箱</h2><ul>
<li><p><strong>是什么</strong>：货架上的储物箱，存放具体货物（数据）。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>结构化：每个箱子有固定格子（字段），比如 <code>订单表</code> 包含 <code>订单号</code>、<code>金额</code> 等字段。</li>
<li>唯一性：同一个货架下不能有同名箱子（但不同货架可以）。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 订单表 (订单号 <span class="type">INT</span>, 金额 <span class="type">DECIMAL</span>);  <span class="comment">-- 造个箱子 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 订单表 <span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="number">99.9</span>);         <span class="comment">-- 往箱子里放货物</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="角色（Role）-→-工作证"><a href="#角色（Role）-→-工作证" class="headerlink" title="角色（Role） → 工作证"></a>角色（Role） → 工作证</h2><ul>
<li><p><strong>是什么</strong>：一种身份标签，可以批量分配权限（类似公司里的“职位”）。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>继承性：一个角色可以有多个权限，用户戴上这个角色就能获得权限。</li>
<li>示例角色：<code>开发角色</code>（能建表、删表）、<code>只读角色</code>（仅查询）。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE 只读角色;                     <span class="comment">-- 定义职位 </span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">TO</span> 只读角色;   <span class="comment">-- 给职位配权限 </span></span><br><span class="line"><span class="keyword">GRANT</span> 只读角色 <span class="keyword">TO</span> 财务员;                 <span class="comment">-- 给用户分配职位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="权限（Privileges）-→-钥匙"><a href="#权限（Privileges）-→-钥匙" class="headerlink" title="权限（Privileges） → 钥匙"></a>权限（Privileges） → 钥匙</h2><ul>
<li><p><strong>是什么</strong>：控制谁能做什么（比如开门、拿货、整理货架）。</p>
</li>
<li><p><strong>常见钥匙</strong>：</p>
<ul>
<li><code>SELECT</code>：查看货物（读数据）。</li>
<li><code>INSERT</code>：放新货物（写数据）。</li>
<li><code>DELETE</code>：扔货物（删数据）。</li>
<li><code>UPDATE</code>：改货物（改数据）。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给钥匙：“允许财务员查订单表” </span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> 订单表 <span class="keyword">TO</span> 财务员;</span><br><span class="line"><span class="comment">-- 收回钥匙：“库管员不能删订单”</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> 订单表 <span class="keyword">FROM</span> 库管员;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="扩展（Extensions）-→-工具包"><a href="#扩展（Extensions）-→-工具包" class="headerlink" title="扩展（Extensions） → 工具包"></a>扩展（Extensions） → 工具包</h2><ul>
<li><p><strong>是什么</strong>：给仓库增加功能的插件（比如装个监控摄像头、自动分拣机）。</p>
</li>
<li><p><strong>常见扩展</strong>：</p>
<ul>
<li><code>PostGIS</code>：地理数据处理。</li>
<li><code>pgcrypto</code>：数据加密。</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION pgcrypto;  <span class="comment">-- 安装加密工具包</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="连接信息（JDBC-URL）-→-仓库地址"><a href="#连接信息（JDBC-URL）-→-仓库地址" class="headerlink" title="连接信息（JDBC URL） → 仓库地址"></a>连接信息（JDBC URL） → 仓库地址</h2><ul>
<li><p><strong>示例</strong>：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">url=&quot;jdbc:postgresql://IP地址:端口/仓库名?currentSchema=默认货架&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拆解</strong>：</p>
<ul>
<li><code>IP地址:端口</code>：仓库位置（如 <code>172.172.100.5:5432</code>）。</li>
<li><code>仓库名</code>：进哪个仓库（如 <code>订单库</code>）。</li>
<li><code>currentSchema</code>：默认找哪个货架（如 <code>VIP货架</code>）。</li>
</ul>
</li>
</ul>
<h2 id="总结关系图"><a href="#总结关系图" class="headerlink" title="总结关系图"></a>总结关系图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">仓库（Database） </span><br><span class="line">│</span><br><span class="line">├── 管理员（User） → 用钥匙（权限）管理 </span><br><span class="line">│ </span><br><span class="line">├── 货架（Schema） → 分类放储物箱（表） </span><br><span class="line">│ </span><br><span class="line">├── 公共货架（public） </span><br><span class="line">	│ </span><br><span class="line">	└── VIP货架 </span><br><span class="line">	│ </span><br><span class="line">	└── 订单表（Table） </span><br><span class="line">│ </span><br><span class="line">└── 工具包（Extensions） → 增强功能</span><br></pre></td></tr></table></figure>

<h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol>
<li><strong>误区</strong>：仓库名（如 <code>订单库</code>）就是货架名。 <strong>正解</strong>：仓库名和货架名是独立的，默认货架是 <code>public</code>。</li>
<li><strong>误区</strong>：管理员（用户）自动拥有同名货架。 <strong>正解</strong>：需要手动建货架并授权（如 <code>CREATE SCHEMA AUTHORIZATION 库管员</code>）。</li>
<li><strong>误区</strong>：不同仓库的货架可以重名。 <strong>正解</strong>：货架名只在当前仓库内有效，不同仓库互不影响。</li>
</ol>
<p>希望这个比喻让你对 PostgreSQL 的核心概念一目了然！ 😊</p>
]]></content>
      <tags>
        <tag>数据</tag>
        <tag>数据/数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis小册</title>
    <url>/2024/12/09/archive/Redis%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[<h2 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h2><h3 id="判断是否安装-GCC-环境"><a href="#判断是否安装-GCC-环境" class="headerlink" title="判断是否安装 GCC 环境"></a>判断是否安装 GCC 环境</h3><blockquote>
<p>以下命令均可检查是否安装 GCC</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132137323.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis gcc</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">whereis g++</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132156616.png"></p>
<blockquote>
<p>如需安装, 执行以下命令即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119093335549.png"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>下载 redis, 联网情况下可以 wget 命令直接下载, 此方式默认下载至当前用户的家目录, 也可以下载好安装包上传至 linux</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-7.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132407697.png"></p>
<blockquote>
<p>&#x2F;opt 目录下解压 redis, 注意文件夹读写权限问题。<a href="https://www.linuxcool.com/tar">tar 命令 – 压缩和解压缩文件 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tar -zxvf redis-7.0.0.tar.gz -C /opt/</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132259120.png"></p>
<blockquote>
<p>进入安装目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/redis-7.0.0/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行 make 命令, 出现下图红框内容代表安装成功, 安装需要能够访问外网, 以及有足够的权限, 不知道为什么 sudo 的都不行, 最后直接使用的 root 用户进行的编译</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132311352.png"></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><blockquote>
<p>进入默认安装路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/bin</span><br><span class="line"><span class="comment"># 列出所有文件</span></span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132327916.png"></p>
<blockquote>
<p>将默认的 redis.conf 拷贝到我们自己定义的路径下, 以防后续修改坏了的话还有备份。<a href="https://www.linuxcool.com/cp">cp 命令 – 复制文件或目录 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /myredis/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件到自定义文件夹下</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /opt/redis-7.0.0/redis.conf /myredis/conf/redis7.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置 redis 的配置文件, 使用 Vim 打开 &#x2F;myredis&#x2F;conf&#x2F;redis7.conf 设置以下参数, 配置文件修改后, 需要重启 redis 服务才会生效</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以后台服务的模式启动</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 关闭redis的保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 注释掉bind参数</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 -::1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 添加redis密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>daemonize</code></td>
<td><strong>yes:</strong> Redis 以守护进程形式在后台运行，PID 号写入指定的 <code>pidfile</code> 文件。需要手动终止该进程。<br><strong>no:</strong> Redis 以前台模式运行，显示 Redis 命令行界面。退出终端或关闭连接工具将停止 Redis 进程。<img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131175630472.png"></td>
</tr>
<tr>
<td><code>protected-mode</code></td>
<td><strong>yes:</strong> 开启保护模式。只允许来自 <code>bind</code> 参数指定地址或通过 <code>requirepass</code> 密码访问。如果两者均未设置，则只允许本地地址访问。<br> <strong>no:</strong> 关闭保护模式。如果未设置 <code>bind</code> 和 <code>requirepass</code>，允许任何地址和 IP 直接连接 Redis，无需密码验证。</td>
</tr>
<tr>
<td><code>bind</code></td>
<td>通过设置 <code>bind</code> 参数，限制只允许指定地址连接到 Redis 服务。</td>
</tr>
<tr>
<td><code>requirepass</code></td>
<td>设置 Redis 密码。连接 Redis 服务时必须提供正确密码，否则无法访问。</td>
</tr>
</tbody></table>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><blockquote>
<p>启动 redis 服务, <code>/usr/local/bin</code> 目录下运行 <code>redis-server</code> ，启用&#x2F;myredis&#x2F;conf&#x2F;redis7.conf 文件, 服务启动是没有输出消息的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /myredis/conf/redis7.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看是否启动成功 <a href="https://www.linuxcool.com/ps">ps 命令 – 显示进程状态 – Linux 命令大全(手册) (linuxcool.com)</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep redis|grep -v grep</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132341742.png"></p>
<h3 id="链接服务"><a href="#链接服务" class="headerlink" title="链接服务"></a>链接服务</h3><blockquote>
<p>链接 <code>redis-cli</code> 是 redis 的命令行工具, 有很多参数可以 <code>redis-cli --help</code> 去了解, 链接成功如下图所示</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -a 1234 -p 6379</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240116231738455.png"></p>
<blockquote>
<p>测试服务是否能正常使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240125132355860.png"></p>
<h3 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h3><blockquote>
<p>退出客户端</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><blockquote>
<p>redis-cli 内部执行 <code>shutdown</code> 或者 <code>redis-cli -a 1234 shutdown</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未进入 redis-cli</span></span><br><span class="line">redis-cli -a 1234 shutdown</span><br><span class="line"><span class="comment"># 进入  redis-cli内部后</span></span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240116232000371.png"></p>
<h2 id="Redis-十大数据类型"><a href="#Redis-十大数据类型" class="headerlink" title="Redis 十大数据类型"></a>Redis 十大数据类型</h2><h3 id="Key-键"><a href="#Key-键" class="headerlink" title="Key(键)"></a>Key(键)</h3><p>Redis 键命令用于管理 redis 的键。</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><code>DEL key</code> 该命令用于在 key 存在时删除 key</li>
<li><code>DUMP key</code> 序列化给定 key ，并返回被序列化的值。使用 <code>DUMP</code> 命令所获取的序列化数据可以用 <code>RESTORE</code> 命令来恢复</li>
<li><code>EXISTS key</code> 判断键是否存在，存在返回 1，不存在返回 0</li>
<li><code>EXPIRE key seconds</code> 设置键的过期秒数</li>
<li><code>EXPIREAT key timestamp</code> 作用和 <code>EXPIRE</code> 一样，不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳，可以指定到期时间</li>
<li><code>PEXPIRE key seconds</code> 设置键的过期毫秒数</li>
<li><code>PEXPIREAT key timestamp</code> 作用和 <code>EXPIRE</code> 一样，不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳，可以指定到期时间</li>
<li><code>KEYS partten</code> 查找所有符合给定模式 ( pattern) 的 key 全部就是 key <strong>正式环境禁用，使用 scan 命令代替</strong>。</li>
<li><code>MOVE key db</code> 移动 key 到指定的库</li>
<li><code>PERSIST key</code> 移除 key 的过期时间，能让数据一致保持</li>
<li><code>TTL key</code> 看 key 剩余时间还有多少秒</li>
<li><code>PTTL key</code> 看 key 剩余时间还有多少毫秒</li>
<li><code>RANDOMKEY</code> 随机返回库中的一个 key</li>
<li><code>RENAME key newkey</code> 修改 key 的名称</li>
<li><code>RENAMENX key newkey</code> 修改 key 的名称，当新 key 不存在时才生效</li>
<li><code>TYPE key</code> 返回 key 的类型</li>
<li><code>SCAN cursor [MATCH pattern] [COUNT count]</code> 迭代数据库中的数据库键。返回值有下一次用于迭代的游标，<code>COUNT count</code>，是一种提示 (hint)，如 <code>Count 10</code> 表示期望返回 10 个 key，大多数情况是有效的，但不一定 100% 返回 10 个 key。</li>
</ul>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>String 是 Redis 中最简单同时也是最常用的数据类型。它是一个二进制安全的字符串，可以存储任何类型的数据，如字符串、整数、浮点数等。</p>
<ul>
<li><code>SET key value</code> 设置指定 <code>key</code> 的值。</li>
<li><code>GET key</code> 获取指定 <code>key</code> 的值。</li>
<li><code>GETRANGE key start end</code> 返回 <code>key</code> 中字符串值的子字符串。</li>
<li><code>GETSET key value</code> 将给定 <code>key</code> 的值设为 <code>value</code>，并返回 <code>key</code> 的旧值。</li>
<li><code>GETBIT key offset</code> 对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位（bit）。</li>
<li><code>MGET key1 [key2..] </code> 获取所有（一个或多个）给定 <code>key</code> 的值。</li>
<li><code>SETBIT key offset value</code> 对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位（bit）。</li>
<li><code>SETEX key seconds value</code> 将值 <code>value</code> 关联到 <code>key</code>，并将 <code>key</code> 的过期时间设为 <code>seconds</code>（以秒为单位）。</li>
<li><code>SETNX key value</code> 只有在 <code>key</code> 不存在时设置 <code>key</code> 的值。</li>
<li><code>SETRANGE key offset value</code> 用 <code>value</code> 参数覆写给定 <code>key</code> 所储存的字符串值，从偏移量 <code>offset</code> 开始。</li>
<li><code>STRLEN key</code> 返回 <code>key</code> 所储存的字符串值的长度。</li>
<li><code>MSET key value [key value ...]</code> 同时设置一个或多个 <code>key-value</code> 对。</li>
<li><code>MSETNX key value [key value ...] </code> 同时设置一个或多个 <code>key-value</code> 对，当且仅当所有给定 <code>key</code> 都不存在。</li>
<li><code>PSETEX key milliseconds value</code> 同 <code>SETEX</code> 命令相似，但它以毫秒为单位设置 <code>key</code> 的生存时间。</li>
<li><code>INCR key</code> 将 <code>key</code> 中储存的数字值增一。</li>
<li><code>INCRBY key increment</code> 将 <code>key</code> 所储存的值加上给定的增量值（increment）。</li>
<li><code>INCRBYFLOAT key increment</code> 将 <code>key</code> 所储存的值加上给定的浮点增量值（increment）。</li>
<li><code>DECR key</code> 将 <code>key</code> 中储存的数字值减一。</li>
<li><code>DECRBY key decrement</code> 将 <code>key</code> 所储存的值减去给定的减量值（decrement）。</li>
<li><code>APPEND key value</code> 如果 <code>key</code> 已经存在并且是一个字符串，<code>APPEND</code> 命令将指定的 <code>value</code> 追加到该 <code>key</code> 原来值的末尾。<br><strong>常用命令</strong>：</li>
<li><code>SET key value</code>：设置 key 的值。</li>
<li><code>GET key</code>：获取 key 的值。</li>
<li><code>INCR key</code>：将 key 中的数字值增 1。</li>
<li><code>DECR key</code>：将 key 中的数字值减 1。</li>
<li><code>STRLEN key</code>：获取 key 的值的长度。</li>
<li><code>EXISTS key</code>：判断 key 是否存在。</li>
<li><code>DEL key</code>：删除 key 及其值。</li>
<li><code>EXPIRE key seconds</code>：为 key 设置过期时间（秒）。</li>
<li><code>TTL key</code>：查看 key 的剩余生存时间（秒）。</li>
</ul>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 中的 List 是一个双向链表，支持快速的插入和删除操作。它可以作为队列或栈来使用。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>LPUSH key value</code>：在列表的左端插入一个或多个值。</li>
<li><code>RPUSH key value</code>：在列表的右端插入一个或多个值。</li>
<li><code>LPOP key</code>：移除并返回列表的左端元素。</li>
<li><code>RPOP key</code>：移除并返回列表的右端元素。</li>
<li><code>LRANGE key start stop</code>：获取列表指定范围内的元素。</li>
<li><code>LLEN key</code>：获取列表的长度。</li>
</ul>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 中的 Set 是一个无序的字符串集合，它不允许有重复的元素。Set 提供了集合操作，如添加、删除、合并等。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>SADD key member</code>：向集合添加一个或多个成员。</li>
<li><code>SREM key member</code>：从集合移除一个或多个成员。</li>
<li><code>SMEMBERS key</code>：返回集合中的所有成员。</li>
<li><code>SISMEMBER key member</code>：判断成员是否在集合中。</li>
<li><code>SCARD key</code>：获取集合的成员数量。</li>
</ul>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis 中的 Hash 是一个键值对的集合，类似于一个对象。Hash 中的每个字段（Field）和值（Value）都是字符串。</p>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>HSET key field value</code>：为哈希表 key 中的字段 field 设置值 value。</li>
<li><code>HGET key field</code>：获取哈希表 key 中字段 field 的值。</li>
<li><code>HMSET key field1 value1 field2 value2</code>：同时设置哈希表 key 的多个字段的值。</li>
<li><code>HMGET key field1 field2</code>：同时获取哈希表 key 的多个字段的值。</li>
<li><code>HGETALL key</code>：获取哈希表 key 中的所有字段和值。</li>
<li><code>HDEL key field</code>：删除哈希表 key 中的字段 field。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><blockquote>
<p>redis 持久化 (也叫备份和恢复) 是指将数据写入持久存储，例如固态磁盘 （SSD）。Redis 提供了一系列持久性选项。这些包括：</p>
</blockquote>
<ul>
<li><strong>RDB</strong>（Redis 数据库）：RDB 持久性按指定的时间间隔执行数据集的时间点快照。</li>
<li><strong>AOF</strong>（仅追加文件）：AOF 持久性记录服务器接收的每个写入操作。然后，可以在服务器启动时再次重播这些操作，从而重建原始数据集。使用与 Redis 协议本身相同的格式记录命令。</li>
<li><strong>RDB + AOF</strong>：您还可以在同一实例中组合 AOF 和 RDB。</li>
<li><strong>无持久性</strong>：您可以完全禁用<strong>持久性</strong>。这有时在缓存时使用。</li>
</ul>
<h3 id="持久化的两种方式"><a href="#持久化的两种方式" class="headerlink" title="持久化的两种方式"></a>持久化的两种方式</h3><blockquote>
<p>下图形象的描述了持久化的两种方式, 我们可以对其有个大概印象, 后续再回头看这张图就会有更多的理解</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119193642354.png"></p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><h5 id="是什么-能干嘛"><a href="#是什么-能干嘛" class="headerlink" title="是什么, 能干嘛"></a>是什么, 能干嘛</h5><blockquote>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘, 也就是行话讲的 Snapshot 内存快照，它恢复时再将硬盘快照文件直接读回到内存里</p>
</blockquote>
<h5 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h5><h6 id="配置文件新旧版本说明"><a href="#配置文件新旧版本说明" class="headerlink" title="配置文件新旧版本说明"></a>配置文件新旧版本说明</h6><p>讲在前头, redis6 和 7 的 RDB 配置的主要在于同步频次上, 以及在 redis7 中如果不进行显示配置, 则会按照默认的同步快照的批量进行.</p>
<p>关于同步快照的设置格式为 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 距离最近一次同步的秒数    键改变的数量</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6.0.16 之前的配置文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119195211598.png"></p>
<blockquote>
<p>redis2.0 到 redis7 的配置</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119195705438.png"></p>
<h6 id="自动触发快照保存"><a href="#自动触发快照保存" class="headerlink" title="自动触发快照保存"></a>自动触发快照保存</h6><p><strong>修改同步频次</strong>本文档使用的是 redis7.0.0 进行操作, 因此为了更好的观察现象, 我们修改同步的配置为 <code>save 20 2</code>,也就是距离上传同步大于 20 秒, 并且有至少两次键值改变才触发同步</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202317352.png"></p>
<p><strong>修改快照保存路径</strong> 快照保存路径默认为当前 redis 所工作目录下, 我们可以修改配置文件中的 dir 参数自定义快照保存路径, 🔔 需要注意的是, 文件夹需要提前存在</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202043117.png"></p>
<p><strong>修改保存文件的名称</strong> 文件默认保存的文件名为 <code>dump.rdb</code> 单机情况下肯定是无须修改, 但如果是集群环境下, 还是最好对文件名做一定的调整, 方便区分是那台服务的备份文件, 我们本次修改为 <code>dump6379.rdb</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119202035248.png"></p>
<p><strong>踩坑记录</strong></p>
<blockquote>
<p>问题现象: 当触发了自动备份时, 会爆出下图中的错误</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210051618.png"></p>
<blockquote>
<p>排查过程:</p>
</blockquote>
<ol>
<li><p>修改配置文件, 自定义日志的输出路径 <code>logfile &quot;/myredis/logs/redis.log&quot;</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210336172.png"></p>
</li>
<li><p>启动服务, 好嘛这次连服务都起不来了<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210546990.png"></p>
</li>
<li><p>按照 GPT 的回答, 是日志权限不足, 一查还真是, 除了当前用户,其他人没有写的权限</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119210814526.png"></p>
</li>
<li><p>修改日志的权限 <code>sudo chmod 666 /myredis/logs/redis.log</code></p>
</li>
<li><p>服务启动, 再次进行触发备份的操作, 步骤 1 的问题复现</p>
</li>
<li><p>查看 redis 日志 <code>cat redis.log</code>, 密密麻麻两个字 吃人 (权限不足)<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119211312698.png"></p>
</li>
<li><p>修改备份文件夹权限 <code>sudo chmod 777 dumpfiles/</code><br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119211445713.png"></p>
</li>
<li><p>大功告成 <code>dump6379</code> 就是自动触发的快照保存<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240119212005640.png"></p>
</li>
</ol>
<p><strong>总结</strong> ① 与 redis 服务交互的文件需要给予足够的权限 ② 触发自动备份的时机除了上述满足条件外, 还有主动 <code>shutdown</code> 服务时也会进行一次备份</p>
<h6 id="手动触发快照保存"><a href="#手动触发快照保存" class="headerlink" title="手动触发快照保存"></a>手动触发快照保存</h6><blockquote>
<p>Redis 提供了两个命令来生成 RDB 文件分别是 <code>save</code> 和 <code>bgsave</code></p>
</blockquote>
<ul>
<li><code>save</code> 在主程序中执行会阻塞当前 redis 服务器，直到持久化工作完成执行 save 命令期间，Redis 不能处理其他命令，<strong>线上禁止使用</strong></li>
<li><code>basve</code> Redis 会在后台异步进行快照操作，不阻塞快照同时还可以响应客户端请求，该触发方式会 fork 一个子进程由子进程复制持久化过程。讲点大白话就是，执行 <code>bsave</code> 之后, 会 <code>fork</code> 复刻一个当前的进程, 专门用来进行数据集的保存。原来的进程继续用来接受处理 redis 的线上请求</li>
</ul>
<h6 id="Lastsave"><a href="#Lastsave" class="headerlink" title="Lastsave"></a>Lastsave</h6><blockquote>
<p>查看最后一次快照的保存时间 <code>lastsave</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120094219499.png"></p>
<h5 id="优势及注意点"><a href="#优势及注意点" class="headerlink" title="优势及注意点"></a>优势及注意点</h5><p><strong>优势</strong></p>
<ul>
<li>RDB 是 Redis 数据的一个非常紧凑的单文件时间点表示。RDB 文件非常适合备份。例如，您可能希望在最近的 24 小时内每小时归档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松恢复不同版本的数据集。</li>
<li>RDB 非常适合灾难恢复，它是一个可以传输到远程数据中心或 AmazonS3（可能已加密）的压缩文件。</li>
<li>RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘 I&#x2F;O 或类似操作。</li>
<li>与 AOF 相比，RDB 允许使用大数据集更快地重启。</li>
<li>在副本上，<em>RDB 支持重启和故障转移后的部分重新同步。</em></li>
</ul>
<p><strong>注意点</strong></p>
<ol>
<li>适合大规模的数据恢复;</li>
<li>按照业务定时备份;</li>
<li>对数据完整性和一至 - 致性要求不高;</li>
<li>RDB 文件在内存中的加载速度要比 AOF 快得多</li>
</ol>
<h5 id="劣势及注意点"><a href="#劣势及注意点" class="headerlink" title="劣势及注意点"></a>劣势及注意点</h5><p><strong>劣势</strong></p>
<ul>
<li><p>如果您需要在 Redis 停止工作时（例如断电后）将数据丢失的可能性降到最低，那么 RDB 并不好。您可以配置生成 RDB 的不同保存点（例如，在对数据集至少 5 分钟和 100 次写入之后，您可以有多个保存点）。但是，您通常会每五分钟或更长时间创建一次 RDB 快照，<strong>因此，如果 Redis 由于任何原因在没有正确关闭的情况下停止工作，您应该准备好丢失最新分钟的数据。</strong></p>
</li>
<li><p>RDB 需要经常 fork() 以便使用子进程在磁盘上持久化。如果数据集很大，fork() 可能会很耗时，并且如果数据集很大并且 CPU 性能不是很好，可能会导致 Redis 停止为客户端服务几毫秒甚至一秒钟。AOF 也需要 fork() 但频率较低，您可以调整要重写日志的频率，而不需要对持久性进行任何权衡。</p>
</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li><p>在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong>;</p>
</li>
<li><p>内存数据的全量同步，如果<strong>数据量太大会导致 I&#x2F;O 严重影响服务器性能</strong>;</p>
</li>
<li><p>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。f<strong>ork 的时候内存中的数据被克隆了一份，大致 2 倍的膨胀性</strong>，需要考虑</p>
</li>
</ul>
<h5 id="模拟数据丢失"><a href="#模拟数据丢失" class="headerlink" title="模拟数据丢失"></a>模拟数据丢失</h5><blockquote>
<p>录入数据, 正常触发保存. 保存后, 设置 a5 的值, 并且此次数据录入并未满足自动保存条件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120101638883.png"></p>
<blockquote>
<p>模拟意外的发生</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询进程号</span></span><br><span class="line">ps aux |grep &#123;redis&#125;</span><br><span class="line"><span class="comment"># 杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 &#123;进程号&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120102208295.png"></p>
<blockquote>
<p>重启服务, 并查询 a3, a4, a5 的值, 可以发现 最后一次保存时间点前的数据 a3 和 a4 能正常获取, 而 a5 的数据发生了丢失</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120102542245.png"></p>
<h5 id="检查修复-Dump-文件"><a href="#检查修复-Dump-文件" class="headerlink" title="检查修复 Dump 文件"></a>检查修复 Dump 文件</h5><blockquote>
<p>以下指令用来修复备份文件, 能修复就修复了, 修复不了基本上就寄了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-check-rdb /myredis/dumpfiles/dump6379.rdb</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120103349033.png"></p>
<h5 id="触发快照保存的情况总结"><a href="#触发快照保存的情况总结" class="headerlink" title="触发快照保存的情况总结"></a>触发快照保存的情况总结</h5><ul>
<li>符合配置文件中快照配置条件</li>
<li>手动 <code>save</code>&#x2F;<code>bsave</code> 命令执行</li>
<li>执行 <code>flushall</code>&#x2F;<code>flushdb</code> 命令也会触发备份, 不过会清空备份文件, 没意义</li>
<li>执行 <code>shutdown</code> 且没开启 AOF 持久化</li>
<li>主从复制, 主节点自动触发 (当前还未验证,后面验证)</li>
</ul>
<h5 id="禁用快照-自动保存"><a href="#禁用快照-自动保存" class="headerlink" title="禁用快照 (自动保存)"></a>禁用快照 (自动保存)</h5><blockquote>
<p>使用命令动态临时的关闭快照</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli config <span class="built_in">set</span> save <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120104839516.png"></p>
<blockquote>
<p>或者直接修改配置文件中的 <code>save</code> 参数为 <code>&#39;&#39;</code></p>
</blockquote>
<h5 id="RDB-配置项详解"><a href="#RDB-配置项详解" class="headerlink" title="RDB 配置项详解"></a>RDB 配置项详解</h5><blockquote>
<p>也就是配置文件的件 SNAPSHOTTING 模块</p>
</blockquote>
<ul>
<li><code>stop-writes-on-bgsave-error </code> <strong>默认 yes</strong>,如果配置成 no，表示你不在乎数据不一致或者有其他的手段发现和控制这种不一致，那么在快照写入失败时，也能确保 redis 继续接受新的写请求|</li>
<li><code>rdbcompression</code> <strong>默认 yes</strong>, 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能</li>
<li><code>rdbchecksum</code> <strong>默认 yes</strong> 在存储快照后，还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</li>
<li><code>rdb-del-sync-files</code> 在没有持久性的情况下删除复制中使用的 RDB 文件启用。<strong>默认情况下 no</strong>，此选项是禁用的</li>
<li><code>save 20 2</code></li>
<li><code>dbfilename dump6379.rdb</code></li>
<li><code>dir /myredis/dumpfiles</code></li>
</ul>
<h5 id="一图总结"><a href="#一图总结" class="headerlink" title="一图总结"></a>一图总结</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120110106579.png"></p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><h5 id="是什么-能干嘛-1"><a href="#是什么-能干嘛-1" class="headerlink" title="是什么, 能干嘛"></a>是什么, 能干嘛</h5><blockquote>
<p>以日志的形式来记录每个 <code>增删改</code> 操作，将 Redis 执行过的所有写指令记录下来 (<strong>读操作不记录</strong>)，只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</blockquote>
<h5 id="AOF-持久化的工作流程图"><a href="#AOF-持久化的工作流程图" class="headerlink" title="AOF 持久化的工作流程图"></a>AOF 持久化的工作流程图</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120131908075.png"></p>
<ol>
<li>Client 作为命令的来源，会有多个源头以及源源不断的请求命令。</li>
<li>在这些命令到达 Redis Server 以后并不是直接写入 AOF 文件，会将其这些命令先放入 AOF 缓存中进行保存。这里的 AOF 缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘 IO 操作。</li>
<li>AOF 缓冲会根据 AOF 缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的 AOF 文件。</li>
<li>随着写入 AOF 内容的增加为避免文件膨胀，会根据规则进行命令的合并 (又称<strong>AOF 重写</strong>)，从而起到 AOF 文件压缩的目的。</li>
<li>当 Redis Server 服务器重启的时候会从 AOF 文件载入数据。</li>
</ol>
<h5 id="AOF-三种同步的写回策略"><a href="#AOF-三种同步的写回策略" class="headerlink" title="AOF 三种同步的写回策略"></a>AOF 三种同步的写回策略</h5><blockquote>
<p>三种写回策略</p>
</blockquote>
<ol>
<li><code>always</code> 可以理解为, 客户端执行写一个指令, 离开就往日志文件中追加一个</li>
<li><code>everysec</code> 每秒写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘</li>
<li><code>no</code> 操作系统控制的写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓中区，由操作系统决定何时将缓中区内容写回磁盘</li>
</ol>
<blockquote>
<p>各种策略优缺点</p>
</blockquote>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步写回</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td>Everysec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>岩机时丢失 1 秒内的数据</td>
</tr>
<tr>
<td>No</td>
<td>操作系统控制的写回</td>
<td>性能好</td>
<td>岩机时丢失数据较多</td>
</tr>
</tbody></table>
<h5 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h5><h6 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h6><p><strong>开启 AOF</strong></p>
<blockquote>
<p>AOF 默认是关闭的, 开起需要将配置文件中的 <code>appendonly</code> 参数设置为 <code>yes</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120134647477.png"></p>
<p><strong>设置回写策略</strong></p>
<blockquote>
<p>使用默认的写回策略, 默认写回即可</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120134928816.png"></p>
<p><strong>备份存放路径</strong></p>
<blockquote>
<p>redis6 中的 AOF 保存文件的位置和 RDB 保存文件的位置一样，都是通过 redis.conf 配置文件的 dir 配置, 但是在 redis 中, 增加了 <code>appenddirname</code> 参数, 用来指定 AOF 的日志存放文件夹。因此当前 redis7 中的 AOF 备份的实际存放路径为 <code>dir</code>+<code>appenddirname</code>。本次修改 AOF 保存文件的路径为 <code>/myredis/backupfiles/appendonlydir</code></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120215308219.png"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120215403262.png"></p>
<p><strong>备份文件名</strong></p>
<blockquote>
<p>Redis6 版本中的备份文件名由 <code>appendfilename</code> 参数控制, 是单独一个文件。但是由于 AOF 是一个一个指令集的叠加, 导致文件会逐渐膨胀, 过大的文件会导致影响写入指令的 IO 性能。 因此在 Redis7 中, 使用了一组文件来作为 AOF 的备份文件, 分别是 <code>基础文件base</code>, <code>增量文件incr</code>, <code>清单文件manifest</code> 。而 <code>appendfilename</code> 参数所配置的为该组文件的文件名后缀, 此次我们使用默认的不做变更。</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120223442310.png"></p>
<h6 id="生成-AOF-备份文件"><a href="#生成-AOF-备份文件" class="headerlink" title="生成 AOF 备份文件"></a>生成 AOF 备份文件</h6><blockquote>
<p>按需求配置完参数, 重启 reds 服务, nice, 启动失败</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120224030427.png"></p>
<blockquote>
<p>额, 这波属实是不长记性了, 处理一下小意外, 无伤大雅</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建备份文件的路径</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /myredis/backupfiles</span><br><span class="line"><span class="comment"># 给备份文件夹修改写入权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 /myredis/backupfiles</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120224608380.png"></p>
<blockquote>
<p>正常写入数据</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225154128.png"></p>
<blockquote>
<p>查看生成的备份文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225400306.png"></p>
<blockquote>
<p>重启 redis, 为避免是从由于 RDB 文件中加载的数据, 我们将 RDB 备份文件重命名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> dump6379.rdb dump6379.rdb.bak</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120225834361.png"></p>
<blockquote>
<p>重启服务, 获取数据, 该说不说, 兄弟们好使 👍</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120230047211.png"></p>
<blockquote>
<p>作死执行一手 <code>flushall</code> , 查看一下备份文件的情况</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120230702616.png"></p>
<blockquote>
<p>重启 Redis, 查询数据发现, 没有值</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120231112178.png"></p>
<blockquote>
<p>命令不是逐条写入, 写的这么清楚, 我是不是能改一下呢, 删掉 <code>flushall</code> 来恢复数据呢? 说干就干, 不过干之前备份文件夹。本来还想记录踩坑经过呢， 没想到一把梭哈，我真是张飞吃豆芽, 粗中有细啊.</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120231924031.png"></p>
<h6 id="异常恢复-AOF-备份文件"><a href="#异常恢复-AOF-备份文件" class="headerlink" title="异常恢复 AOF 备份文件"></a>异常恢复 AOF 备份文件</h6><blockquote>
<p>AOF 备份文件可能会由于网络断链, 服务进程被杀掉等情况导致命令还未完全写入备份文件导致的文件损坏, 这里我们乱写一通模拟坏掉的文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120232431665.png"></p>
<blockquote>
<p>备份文件损坏后, 我们发现连服务都起不来</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120232620664.png"></p>
<blockquote>
<p>修复备份文件, 记住检查指令中一定要加上 <code>--fix</code> 参数, 是否继续选 <code>y</code> 就行了, 如下图操作所示, 好使。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-check-aof --fix  /myredis/backupfiles/appendonlydir/appendonly.aof.1.incr.aof</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240120233119037.png"></p>
<h5 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h5><ul>
<li>优点： 更好的保护数据不丢失、性能高、可做紧急恢复</li>
<li>缺点：① 相同数据集的数据而言 aof 文件要远大于 rdb 文件，恢复速度慢于 rdb； ②aof 运行效率要慢于 rdb,每秒同步策略效率较好，不同步效率和 rdb 相同</li>
</ul>
<h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><h6 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h6><blockquote>
<p>由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中，随着 Redis 不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis 新增了重写机制，当 AOF 文件的大小超过所设定的峰值时，Redis 就会<strong>自动</strong>启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 <code>bgrewriteaof</code> 来重写。<strong>启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集</strong></p>
</blockquote>
<h6 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h6><blockquote>
<p>触发机制分为两种情况, 分别是自动触发和手动触发</p>
</blockquote>
<ul>
<li><p><strong>自动触发：</strong> 需要同时满足下图中的两个条件，即 <code>auto-aof-rewrite-percentage</code> 本次 AOF 文件大小达到上次 AOF 文件的百分之多少; <code>auto-aof-rewrite-min-size </code> 重写时需要满足的文件大小至少要满足多少。举个 🌰: redis7 中默认参数分别是 <code>auto-aof-rewrite-percentage 100</code>, <code>auto-aof-rewrite-min-size 64mb</code> 也就意味着, 当本次的 AOF 的大小是之前 AOF 的百分之百<strong>并且</strong>本次文件大小不小于 64Mb, 才会触发自动重写机制</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122214437669.png"></p>
</li>
<li><p><strong>手动触发：</strong> 客户端向服务器发送 <code>bgrewriteaof</code> 命令</p>
</li>
</ul>
<h6 id="案例演示-仅演示自动触发"><a href="#案例演示-仅演示自动触发" class="headerlink" title="案例演示 (仅演示自动触发)"></a>案例演示 (仅演示自动触发)</h6><blockquote>
<p>前期配置文件修改</p>
</blockquote>
<ul>
<li>开启 AOF : <code>appendonly yes</code> 默认是 no, 设置为 yes 即可开启</li>
<li>重写峰值: <code>auto-aof-rewrite-min-size 1kb</code> 默认的重写峰值是 64mb 太大了, 不好测试, 我们修改为 1kb</li>
<li>关闭混合持久化: <code>aof-use-rdb-preamble no</code> 默认是 yes, 我们为了单纯的测 AOF, 所以关掉与 AOF 的混合持久化</li>
<li>删除原来的 aof 与 rdb 文件, 避免干扰项</li>
</ul>
<p><code> </code></p>
<blockquote>
<p>启动服务, 执行写入数据的指令, 当我执行了 16 次 <code> set k1 1111111111111111111111111111111</code> 之后, 增量 AOF 文件的大小来到了 967kb</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122221418987.png"></p>
<blockquote>
<p>此时我们查看一下 <code>cat appendonly.aof.1.incr.aof</code> 文件的内容, 不出以外, 清一色的如下指令, 如下图所示</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122221724897.png"></p>
<blockquote>
<p>趁此间隙, 解释一下这些指令集怎么看吧 <code># *&#123;该条指令包含几个参数&#125;</code>, <code># $&#123;该参数的长度&#125;</code>, 也就是说下面这个指令集的意思是包含三个参数, 第一个参数的长度是 3, 值是 set , 第二个参数的长度是 2, 值是 k1, 后面的规则相同…….</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="variable">$2</span></span><br><span class="line">k1</span><br><span class="line"><span class="variable">$31</span></span><br><span class="line">1111111111111111111111111111111</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继续写入数据, 触发重写</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223637183.png"></p>
<blockquote>
<p>查看 apf 备份文件夹下的文件情况, 我们发现 incr 文件没有继续增加大小, 反而是 base 文件变大了, 并且文件的后缀均变成了 2</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223537711.png"></p>
<blockquote>
<p>我们先看一下 base 文件里新增的内容, 根据刚刚学习的指令集, 我们发现 base 文件中只存了我们当前最新的数据, 并没有保存以前输入的一大堆 set k1 111111</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122223946887.png"></p>
<blockquote>
<p>再来看一下 incre 文件, 第一次查看时, 没有内容, 第二次查看时又有内容了。为什么呢？因为第一次查看查看时，我发现没有数据， 所以我又执行了一条指令。由此我们可以断定， <code>set k1 ababab......</code> 触发重写后, 会将当前内存里的数据写入 base 文件, 后续的指令写入到 incr 文件中</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122224348340.png"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122224603069.png"></p>
<blockquote>
<p><strong>结论:</strong> 也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code>：默认值为 100，以及 <code>auto-aof-rewrite-min-size</code>：64mb 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，<strong>默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发</strong></p>
</blockquote>
<h6 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h6><blockquote>
<p>AOF 的重写原理可以参考以下链接 <a href="https://cloud.tencent.com/developer/article/2294422">Redis7.0 以后 AOF 底层原理变更图解-腾讯云开发者社区-腾讯云 (tencent.com)</a>。</p>
</blockquote>
<ol>
<li>在重写开始前，redis 会创建一个“重写子进程”，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</li>
<li>当“重写子进程 “ 完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中</li>
<li>当追加结束后，redis 就会用新 AOF 文件来代替 I 旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中</li>
<li>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似</li>
</ol>
<h5 id="AOF-配置项详解"><a href="#AOF-配置项详解" class="headerlink" title="AOF 配置项详解"></a>AOF 配置项详解</h5><blockquote>
<p>也就是配置文件中的 APPEND_ONLY_MODLE 模块</p>
</blockquote>
<ul>
<li><code>appendonly</code> 是否开启 AOF, 默认 no</li>
<li><code>appendfilename</code> AOF 系列文件的前缀名</li>
<li><code>appendfsync</code> 三种同步策略 <strong>everysec&#x2F;always&#x2F;no</strong></li>
<li><code>no-appendfsync-on-rewrite</code> aof 重写期间是否同步, 默认值 no</li>
<li><code>auto-aof-rewrite-percentage</code> 重写触发百分比</li>
<li><code>auto-aof-rewrite-min-size</code> 重写触发文件大小的最小值</li>
</ul>
<h5 id="一图总结-1"><a href="#一图总结-1" class="headerlink" title="一图总结"></a>一图总结</h5><p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240122231102027.png"></p>
<h3 id="RDB-AOF-混合持久化"><a href="#RDB-AOF-混合持久化" class="headerlink" title="RDB+AOF 混合持久化"></a>RDB+AOF 混合持久化</h3><h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><blockquote>
<p>关于 RDB 和 AOF 这两种持久化模式, 我们该如何选择, 官网是这样说的 <a href="https://redis.io/docs/management/persistence/#backing-up-aof-persistence">Redis persistence | Redis</a>, 建议我们两者均开启</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123205559279.png"></p>
<h4 id="RDB-Vs-AOF"><a href="#RDB-Vs-AOF" class="headerlink" title="RDB Vs AOF"></a><code>RDB</code> Vs <code>AOF</code></h4><h5 id="能否共存"><a href="#能否共存" class="headerlink" title="能否共存?"></a>能否共存?</h5><blockquote>
<p>不用看了, 两者肯定能共存, 前面测试 AOF 的时候, rdb 备份文件也生成了</p>
</blockquote>
<h5 id="两者同时存在时的优先级谁高"><a href="#两者同时存在时的优先级谁高" class="headerlink" title="两者同时存在时的优先级谁高?"></a>两者同时存在时的优先级谁高?</h5><blockquote>
<p>优先级是 AOF 的高, 主要原因在于 AOF 备份的实时性太搞了, 在开启 <code>always</code> 的写回策略时, 能保证数据的百分百一直, 所以数据恢复以及加载时, 肯定会以 AOF 为主</p>
</blockquote>
<h5 id="数据恢复的顺序和加载流程"><a href="#数据恢复的顺序和加载流程" class="headerlink" title="数据恢复的顺序和加载流程"></a>数据恢复的顺序和加载流程</h5><blockquote>
<p>在同时开启 rdb 和 aof 持久化时，重启时只会加载 aof 文件，不会加载 rdb 文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123210320789.png"></p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><blockquote>
<p>两种持久化方式的特点</p>
</blockquote>
<ul>
<li>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾</li>
</ul>
<blockquote>
<p>🔔 推荐同时开启两种持久化方式, 虽然两者同时开启是, AOF 的优先级总是高于 RDB, 但是, 由于 AOF 文件总是在一直变化, 所以不易备份, 应该留存 RDB 文件用作备份, 分机备份</p>
</blockquote>
<h4 id="RDB-AOF-混合模式"><a href="#RDB-AOF-混合模式" class="headerlink" title="RDB + AOF 混合模式"></a><code>RDB</code> + <code>AOF</code> 混合模式</h4><blockquote>
<p>先说好处, 这种方式结合了 RDB 和 AOF 的优点，既能快速加载又能避免丢失过多的数据。强烈推荐</p>
</blockquote>
<h5 id="开启混合模式"><a href="#开启混合模式" class="headerlink" title="开启混合模式"></a>开启混合模式</h5><blockquote>
<p>之前测试 AOF 重写的时候关闭了, 这次再打开</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123211637657.png"></p>
<h5 id="写入数据-触发重写"><a href="#写入数据-触发重写" class="headerlink" title="写入数据, 触发重写"></a>写入数据, 触发重写</h5><blockquote>
<p>我们可以看到, 在开启混合模式之后, redis 在压缩指令集的时候, 并没有将内存快照处理成 base.aof 文件, 而是处理成了 RDB 文件</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123212034897.png"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>使用 RDB 进行快照存储，然后使用 AOF 持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能</p>
</blockquote>
<h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><blockquote>
<p>关机就关机, 停服务就停服务, 主打一个对数据不关心, 强烈不推荐, 多大的并发啊, Redis 都支持不了你, 处理不了就加设备…..<br>至于如何开启, 把 AOF 和 RDB 都关了就算开启</p>
</blockquote>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>关于 Redis 的事务, 官网上是这样介绍的 <a href="https://redis.io/docs/interact/transactions/">Transactions | Redis</a>, Redis Transactions allow the execution of a group of commands in a single step, they are centered around the commands <a href="https://redis.io/commands/multi"><code>MULTI</code></a>, <a href="https://redis.io/commands/exec"><code>EXEC</code></a>, <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> and <a href="https://redis.io/commands/watch"><code>WATCH</code></a>。讲人话就是可以一次执行多个命令，事务的本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</p>
</blockquote>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p>开启 一个队列中，一次性、顺序性、排他性的执行一系列命令, 不允许其他指令加塞, 大致原理参照下图</p>
</blockquote>
<h3 id="Redis-事务-VS-数据库事务"><a href="#Redis-事务-VS-数据库事务" class="headerlink" title="Redis 事务 VS 数据库事务"></a>Redis 事务 VS 数据库事务</h3><h4 id="数据库事务及特性"><a href="#数据库事务及特性" class="headerlink" title="数据库事务及特性"></a>数据库事务及特性</h4><blockquote>
<p>数据库事务是一组数据库操作，它们在数据库中被视为一个单一的工作单元，要么全部执行，要么全部不执行。事务是确保数据库数据一致性和完整性的一种机制。在事务的执行过程中，如果发生错误，所有已执行的操作将被撤销，数据库回滚到事务开始之前的状态。只有当所有操作都成功完成时，事务才会被提交，数据库保存更新后的状态。</p>
</blockquote>
<p>🙈 这里多提一嘴, 数据库事务具有以下四个主要特性，通常被称为 ACID 特性：</p>
<ol>
<li><p><strong>原子性（Atomicity）：</strong> 事务是一个原子操作，要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任何一个操作失败，整个事务将被撤销，数据库回到事务开始之前的状态。</p>
</li>
<li><p><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束后，数据库的完整性约束应该保持一致。这意味着事务执行后，数据库应该处于一个合法的状态，不违反任何完整性规则。</p>
</li>
<li><p><strong>隔离性（Isolation）：</strong> 事务的执行应该是相互隔离的，即一个事务的执行不应该影响其他事务的执行。隔离性通常通过并发控制机制来实现，以防止多个事务之间的干扰。</p>
</li>
<li><p><strong>持久性（Durability）：</strong> 一旦事务提交，其修改将永久保存在数据库中，即使系统发生故障或重启，事务的结果也不会丢失。</p>
</li>
</ol>
<h4 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h4><table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>单独的隔离操作</td>
<td>Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，redis 命令执行是<strong>单线程</strong>架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</td>
</tr>
<tr>
<td>没有隔离级别的概念</td>
<td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td>
</tr>
<tr>
<td>不保证原子性</td>
<td>Redis 的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>
</tr>
<tr>
<td>排它性</td>
<td>Redis 会保证一个事务内的命令依次执行，而不会被其它命令插入 (这个感觉和第一个特性的区别不大)</td>
</tr>
</tbody></table>
<h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MULTI</td>
<td>开启一个事务</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行所有事务内的命令</td>
</tr>
<tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个或多个键，如果在事务执行之前这些键被修改，则事务将被打断</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消所有对所有键的监视</td>
</tr>
</tbody></table>
<h4 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h4><blockquote>
<p><code>multi</code> 指令输入后, 将需要执行的指令依次放入队列, 但并不执行, 返回 <code>QUEUED</code> 代表放入成功, 当输入 exec 时, 一次性执行完前面的指令, 并返回对应的结果。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">MULTI</span><br><span class="line"><span class="comment"># ......输入语句</span></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123225013798.png"></p>
<blockquote>
<p>正常执行大体流程示意图</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio" alt="事务执行流程图"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123232127571.png"></p>
<h4 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h4><blockquote>
<p><code>multi</code> 指令输入后, 将需要执行的指令依次放入队列, 但并不执行, 返回 <code>QUEUED</code> 代表放入成功, 当输入 <code>discard</code> 时,取消执行前面的指令, 并结束事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">MULTI</span><br><span class="line"><span class="comment"># ......输入语句</span></span><br><span class="line"><span class="comment"># 放弃执行</span></span><br><span class="line">DISCARD</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123233016457.png"></p>
<blockquote>
<p>事务放弃执行的大体流程图如下</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E4%BA%8B%E5%8A%A1%E6%94%BE%E5%BC%83%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240123233326990.png"></p>
<h4 id="全体连坐"><a href="#全体连坐" class="headerlink" title="全体连坐"></a>全体连坐</h4><blockquote>
<p>该种情况是指在开启事务后部分语法编译阶段就未通过, 会导致事务内的所有指令均不执行.</p>
</blockquote>
<p>下图中, 首先设置 <code>k1</code> 的值为 <code>zhanglei</code> , 然后开启事务, 修改 <code>k1</code> 的值为 <code>zhangsan</code> , 然后将 输入了一条错误的指令 <code>set k2</code> ,由于该指令语法错误, 并且都<strong>编译未通过</strong>, 因此在后续执行 <code>exec</code> 提交时, <code>set k1 zhangsan</code> 指令并未生效. 获取 <code>k1</code> 的值仍然为 <code>zhangslei</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131213214926.png"></p>
<h4 id="冤头债主"><a href="#冤头债主" class="headerlink" title="冤头债主"></a>冤头债主</h4><blockquote>
<p>该情况是指, <code>redis</code> 开启事务之后, 存在错误的指令, 但是在编译阶段并未发现, 而当提交执行后, 冤有头债有主, 正取的指令执行, 错误的指令停止</p>
</blockquote>
<p>如下图所示, 首先设置 <code>k1</code> 的值为 <code>zhanglei</code>, 设置 <code>count</code> 的值为 <code>abc</code> , 开启事务, 修改 <code>k1</code> 的值为 <code>zhangsan</code> 并执行 <code>incr count指令</code>. 我们要知道的是, <code>incr</code> 这条自增指令并未在此时报错, 但是它存在语法错误, 字符串无法执行自增指令, 后续获取 <code>k1</code> 和 <code>count</code> 的值, 我们可以发现, 与编译未通过不同的是, <code>set k1 zhangsan</code> 这条指令仍然生效了. 仅有 <code>incr count</code> 该指令未执行成功</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131214404940.png"></p>
<p><strong>注意事项</strong> 与传统数据库事务不同,Redis 事务中的指令并不是一起成功一起失败的, 并且 Redis 未提供数据回滚的能力, 开发者需要再事务执行失败后, 自行恢复数据状态</p>
<h4 id="Watch-监控"><a href="#Watch-监控" class="headerlink" title="Watch 监控"></a>Watch 监控</h4><blockquote>
<p>Redis 使用 <code>watch</code> 来实现乐观锁定, 类似于 CAS(check and set) ,Redis Watch 命令用于监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断</p>
</blockquote>
<p>如下图所示, 有两台 redis 客户端, 客户端 1 先执行左侧红框内 ① 中的指令, 设置 k1, k2 和 money 的值, 并监视 (<code>watch</code>) money 的值, 然后客户端 ② 执行右侧红框 ② 中的指令, 并修改了 money 的值为 200, 客户端 1 执行左侧蓝框 ③ 中的指令, 并开启事务, 修改 money 以及 k1 的值, 我们可以发现, 修改指令并未生效, 原因就是 <code>watch</code> 的 money 值发生改变, 导致事务中端</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131221112849.png"></p>
<p><strong>取消监视的几种情况</strong></p>
<ul>
<li>手动执行 <code>unwatch</code> 指令</li>
<li>执行 <code>exec</code> 提交事务后, 会取消所有的监视</li>
<li>客户端断开链接, 也会取消所有的监视</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>讲白了, Redis 的事务就三步: ① 开启事务; ② 命令入队, ③ 执行命令</p>
</blockquote>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p><a href="https://zhuanlan.zhihu.com/p/144268090">高频 Redis 面试题解析：Redis 事务是否具备原子性？ - 知乎 (zhihu.com)</a></p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="Redis 管道"></a>Redis 管道</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><blockquote>
<p>如何优化命令往返导致的性能瓶颈?</p>
</blockquote>
<h4 id="面试题由来"><a href="#面试题由来" class="headerlink" title="面试题由来"></a>面试题由来</h4><p>Redis 是一种基于客户端 - 服务端模型以及请求&#x2F;响应协议的 TCP 服务。一个请求会遵循以下步骤：</p>
<ol>
<li>客户端向服务端发送命令分四步 (发送命令 → 命令排队 → 命令执行 → 返回结果)，并监听 Socket 返回，通常以阻塞模式等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
<p>上述两步称为：<strong>Round Trip Time</strong>(简称 RTT,数据包往返于两端的时间)，如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 redis 调用多次 read() 和 write() 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好，o(╥﹏╥)o</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131224548063.png"></p>
<p><strong>答案</strong></p>
<blockquote>
<p>管道 (pipeline) 可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与 redis 的通信次数来实现降低往返延时时间。pipeline 实现的原理是队列，先进先出特性就保证数据的顺序性。</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131224611607.png"></p>
<h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>Pipeline 是为了解决 RTT 往返回时，仅仅是将命令打包一次性发送，对整个 Redis 的执行不造成其它任何影响. 批处理命令变种, 类似于 redis 原生命令中的 <code>mest</code> 和 <code>mget</code></p>
</blockquote>
<h3 id="怎么用-3"><a href="#怎么用-3" class="headerlink" title="怎么用"></a>怎么用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> cmd.txt | redis-cli -a 1234 --pipe</span><br></pre></td></tr></table></figure>

<p>先将需要执行的指令写入一个文档, 文档中的指令格式可以是通常的指令, 也可以是 aof 的增量文件的指令格式. 安装上方的指令即可将文档中的指令打包扔给 redis server 执行</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240131225908947.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="Pipeline-与原生批量命令对比"><a href="#Pipeline-与原生批量命令对比" class="headerlink" title="Pipeline 与原生批量命令对比"></a>Pipeline 与原生批量命令对比</h4><ul>
<li>原生批量命令是原子性 (例如:mset,mget)，pipeline 是非原子性</li>
<li>原生批量命令一次只能执行一种命令，pipeline 支持批量执行不同命令</li>
<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>
</ul>
<h4 id="Pipeline-与事务对比"><a href="#Pipeline-与事务对比" class="headerlink" title="Pipeline 与事务对比"></a>Pipeline 与事务对比</h4><ul>
<li>事务具有原子性，管道不具有原子性</li>
<li><strong>管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到 exec 命令后才会执行</strong>，管道不会</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>pipeline 缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</li>
<li>使用 pipeline 组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li>
</ul>
<h2 id="Redis-发布与订阅"><a href="#Redis-发布与订阅" class="headerlink" title="Redis 发布与订阅"></a>Redis 发布与订阅</h2><h3 id="学习定位"><a href="#学习定位" class="headerlink" title="学习定位"></a>学习定位</h3><blockquote>
<p>该部分内容了解即可</p>
</blockquote>
<h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</blockquote>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li><p><strong>消息订阅：</strong> Redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号, 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201103328724.png"></p>
</li>
<li><p><strong>消息发布：</strong> 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201103555854.png"></p>
</li>
</ul>
<h3 id="怎么用-4"><a href="#怎么用-4" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>① 订阅一个或多个符合给定模式的频道。② 推荐先订阅再发布, 否则在订阅之前发布的消息接收不到。</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody></table>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><h5 id="订阅-退订-发布"><a href="#订阅-退订-发布" class="headerlink" title="订阅&#x2F;退订&#x2F;发布"></a>订阅&#x2F;退订&#x2F;发布</h5><blockquote>
<p>涉及指令 <code>SUBSCRIBE</code> and <code>UNSUBSCRIBE</code> and <code>PUBLISH</code></p>
</blockquote>
<ul>
<li>客户端 A 订阅消息, 客户端 C 发布消息 如下图 ①②③</li>
<li>客户端 B 也订阅消息, 客户端 C 发布消息 如下图 ④⑤⑥ 此时客户端 B 并<strong>未收到订阅之前的消息</strong></li>
<li>客户端 A 退订消息, 客户端 C 发布消息 如下图 ⑦⑧⑨ 此时仅有客户端 B 收到了消息</li>
</ul>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201114933423.png"></p>
<h4 id="批量订阅与发布"><a href="#批量订阅与发布" class="headerlink" title="批量订阅与发布"></a>批量订阅与发布</h4><blockquote>
<p>涉及指令: <code>PUBSUB NUMPAT</code> and <code>PUNSUBSCRIBE</code></p>
</blockquote>
<ul>
<li>查看当前订阅模式的数量 当前为 0 如下图 ①</li>
<li>订阅 <code>a* b* c*</code> 三种模式 如下图 ②</li>
<li>再次查看订阅模式的数量 如下图 ③</li>
<li>发布消息, 客户端通过订阅模式的方式接收 如图 ④⑤⑥⑦</li>
<li>退订 <code>PUNSUBSCRIBE a* b* c*</code> 这个参数在不同的客户端下有不同的表现, 此处不做展示了就</li>
</ul>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201133834586.png"></p>
<h4 id="查看订阅与发布系统状态"><a href="#查看订阅与发布系统状态" class="headerlink" title="查看订阅与发布系统状态"></a>查看订阅与发布系统状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看订阅模式的数量 (订阅模式的数量而不是客户端的数量)。</span><br><span class="line">PUBSUB NUMPAT</span><br><span class="line"># 查看给定频道的订阅者数量， 订阅模式的客户端不计算在内</span><br><span class="line">PUBSUB NUMSUB [channel-1 ... channel-N]</span><br><span class="line"># 活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。有pattern参数, 则只会返回与pattern参数相匹配的</span><br><span class="line">PUBSUB channels [pattern]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Redis 可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。仅代表我个人，不推荐使用该功能，专业的事情交给专业的中间件处理，redis 就做好分布式缓存功能</p>
</blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>发布的消息在 Redis 系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃</li>
<li>消息只管发送对于发布者而言消息是即发即失的，不管接收，也没有 ACK 机制，无法保证消息的消费成功。</li>
<li>以上的缺点导致 Redis 的 Pub&#x2F;Sub 模式就像个小玩具，在生产环境中几乎无用武之地，为此 Redis5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub&#x2F;Sub 更加的强大</li>
</ul>
<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>一句话来讲就是 <strong>主从复制</strong> , master 以写为主, slave 以读为主, 并且当 master 数据变化的时候，自动将新的数据异步同步到其它 slave 数据库。 下图是来自于官网的解释 <a href="https://redis.io/docs/management/replication/">Redis replication | Redis</a></p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240201141151733.png"></p>
<h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
<li>容灾恢复</li>
<li>数据备份</li>
<li>水平扩容，可支持高并发</li>
</ul>
<h3 id="怎么用-5"><a href="#怎么用-5" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><strong>配从不配主</strong> 只需要修改从库的配置文件即可， 无须修改主库的配置文件</li>
<li><strong>权限问题</strong> 如果主库配置了密码， 则要将从库配置文件中 <code>masterauth</code> 参数配置为主库的密码, 否则主库会拒绝从库的请求</li>
<li><strong>基本的命令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>info replication</code></td>
<td>可以查看复制节点的主从关系和配置信息</td>
</tr>
<tr>
<td><code>replicaof 主库IP 主库端口</code></td>
<td>告诉当前的 Redis 服务器从哪个主库复制数据</td>
</tr>
<tr>
<td><code>replicaof no one</code></td>
<td>当前服务器将停止复制来自其他服务器的数据，并成为独立的主服务器。</td>
</tr>
<tr>
<td><code>SLAVEOF 192.168.1.100 6379</code></td>
<td>命令等同于 <code>replicaof </code> , 是旧版本的命令, 为兼容而保留的</td>
</tr>
<tr>
<td><code>SLAVEOF no one</code></td>
<td>命令等同于 <code>replicaof no one</code> , 是旧版本的命令, 为兼容而保留的</td>
</tr>
</tbody></table>
<h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><blockquote>
<p>如果使用三台虚拟机来启动三台 redis 服务, 电脑有点吃不消, 我们使用三个不同的端口号来模拟三台服务即可, 反正原理上大差不差</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/redis%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240222213914823.png"></p>
<h4 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h4><ol>
<li>开启 daemaonize yes</li>
<li>注释 bind 127.0.0.1</li>
<li>关闭 protected-mode no</li>
<li>指定端口</li>
<li>指定工作目录 备份会存放在该目录下 <code>dir /myredis/redis6381/backupfiles</code></li>
<li>修改 pid 文件名称,pidfile <code>/myredis/redis6381/run/redis_6381.pid</code></li>
<li>修改 log 文件名字,logfile <code>/myredis/redis6381/logs/redis_6381.log</code></li>
<li>设置 requirepass 密码</li>
<li>设置 dump.rdb 名字</li>
<li>开启 aof 备份 <code>appendonly yes</code></li>
<li>设置 aof 文件的备份文件夹，<code>appenddirname &quot;appendonlydir&quot;</code> , 这样配置的花 AOF 备份文件就在&#x2F;myredis&#x2F;redis6381&#x2F;backupfiles&#x2F;appendonlydir 文件夹下</li>
<li>设置 aof 文件名前缀， <code>appendfilename &quot;appendonly.aof&quot;</code></li>
<li><strong>如果是从机，则需要配置主机的通行证 masterauth，必须的</strong></li>
</ol>
<blockquote>
<p>拷贝三份配置文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6379.conf</span><br><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6380.conf</span><br><span class="line">[su@localhost conf]$ <span class="built_in">sudo</span> <span class="built_in">cp</span> redis7.conf redis6381.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240222214740056.png"></p>
<h4 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h4><blockquote>
<p>修改完三份配置文件后, 启动三个端口的服务, 如下动图我们可以发现, 在主服务 6379 上设置的 k1 和 k2, 均能在从服务上读取数据, 但是从服务拒绝写入数据</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/recording.gif"></p>
<h3 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240529232412978.png" alt="|480"></p>
<h4 id="主机停止服务"><a href="#主机停止服务" class="headerlink" title="主机停止服务"></a>主机停止服务</h4><p>默认情况下，master 服务挂掉之后，不会在 slave 节点中自动重选一个 master，redis 无法在对外提供写入服务，如果想要重启服务，需要人工干预。无人值守成为刚需。</p>
<h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><p>吹哨人巡查监控后台 master 主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务</p>
<p><strong>作用</strong>：</p>
<ul>
<li>监控 Redis 的运行状态，包括 master 和 slave</li>
<li>当 master 宕机，能够自动将从机切换成主机<br><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240530231114346.png" alt="|550"></li>
</ul>
<h3 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li>主从监控：监控主从 Redis 运行是否正常</li>
<li>消息通知：可以将故障转移的结果通知给客户端</li>
<li>故障转移：如果主机异常，则进行主从切换，将其中一个 salve 作为新的 master</li>
<li>配置中心：客户端可以通过哨兵来获取当前 redis 服务的主节点地址</li>
</ol>
<h3 id="怎么用-6"><a href="#怎么用-6" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="架构说明-1"><a href="#架构说明-1" class="headerlink" title="架构说明"></a>架构说明</h4><p>由于每一台虚拟机进启动一台 redis 的话，下图架构至少需要 6 台虚拟机，这样的话 16G 的内存有点吃不消，因此，如下图中的架构图所示，仅以端口号来对服务进行区分</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.drawio"></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240530233523704.png" alt="|600"></p>
<h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h3><h4 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h4><p><code>sudo mkdir /myredis/sentinel26379</code></p>
<h4 id="配置-sentinel-conf-文件"><a href="#配置-sentinel-conf-文件" class="headerlink" title="配置 sentinel.conf 文件"></a>配置 sentinel.conf 文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line">logfile &quot;/myredis/sentinel26379/logs/sentinel26379.log&quot;</span><br><span class="line"></span><br><span class="line">pidfile /myredis/sentinel26379/run/sentinel26379.pid</span><br><span class="line"># 修改工作的目录</span><br><span class="line">dir /myredis/sentinel26379</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>

<h4 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h4><p>由于测试机器上安装了 docker，并且自动启动了 docker 容器，因此需要先关闭一下，避免冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /myredis/redis6379/conf/redis7_6379.conf</span><br><span class="line">redis-server /myredis/redis6380/conf/redis7_6380.conf</span><br><span class="line">redis-server /myredis/redis6381/conf/redis7_6381.conf</span><br></pre></td></tr></table></figure>

<p>测试主从复制正常</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601004628234.png" alt="|500"></p>
<h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel26379/conf/sentinel_26379.conf --sentinel</span><br><span class="line">redis-sentinel /myredis/sentinel26380/conf/sentinel_26380.conf --sentinel</span><br><span class="line">redis-sentinel /myredis/sentinel26381/conf/sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601010332809.png" alt="|540"></p>
<h4 id="测试哨兵自动切换的流程"><a href="#测试哨兵自动切换的流程" class="headerlink" title="测试哨兵自动切换的流程"></a>测试哨兵自动切换的流程</h4><p>首先，正常启动主机服务，从机服务，查看同步是否正常，如下图 ①-⑤，此时我们停止主机 6379 的服务，如下图步骤 ⑥，为了验证从机是否自动切换成主机，我们进行了步骤 ⑦ 和 ⑧，发现从机并没有切换为主机，当进行操作 ⑨ 的时候，我们可以发现 6380 显示的身份为 master，此时再进行写入操作，发现成功，并且数据同步到了 6381 机器上,如下图步骤 10-11(说明主机下线时，从机上位需要一定的时间)，当 6379 服务重新启动的时候，我们可以发现此时 6379 的身份已经变成了从机，至此哨兵切换主从机的步骤完成。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601011357939.png" alt="|900"></p>
<h4 id="对比配置文件"><a href="#对比配置文件" class="headerlink" title="对比配置文件"></a>对比配置文件</h4><p>senter</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/image-20240601013211368.png"></p>
<h3 id="运行流程和选举原理"><a href="#运行流程和选举原理" class="headerlink" title="运行流程和选举原理"></a>运行流程和选举原理</h3><p>当一个主从配置中的 master 失效之后，sentinel 可以选举出一个新的 master 用于自动接替原 master 的工作，主从配置中的其他 redis 服务器自动指向新的 master 同步数据。般建议 sentinel 采取奇数台，防止某一台 sentinel 无法连接到 master 导致误切换</p>
<p>哨兵是禁军，哨兵 leader 是进军统帅，而选举则是发动政变，推举新的 master</p>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>哨兵节点的数量应该为多个，哨兵本身应该是集群，保证高可用</li>
<li>哨兵节点的数量应该为多个</li>
<li>各个哨兵节点的配置应一致</li>
<li>如果哨兵节点部署在 Docker 等容器里，尤其注意端口的正确映射</li>
<li>哨兵集群 + 主从复制，并不能保证数据零丢失</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h3 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h3><blockquote>
<p>为节省服务器资源，将会在同一台服务器上，不同端口下起六台服务。均位于 <code> /myredis/cluster</code> 文件夹下</p>
</blockquote>
<h4 id="3-主-3-从的集群配置"><a href="#3-主-3-从的集群配置" class="headerlink" title="3 主 3 从的集群配置"></a>3 主 3 从的集群配置</h4><p>^8208ce</p>
<p><strong>配置相关文件及文件夹</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建此次配置的根路径</span><br><span class="line"> <span class="built_in">mkdir</span> /myredis/cluster</span><br><span class="line"> 创建所属的文件夹</span><br><span class="line"> <span class="built_in">mkdir</span> /myredis/cluster/redisCluster6381</span><br><span class="line"> 创建配置文件，配置文件的内容参考下面的conf代码块</span><br><span class="line">vim  /myredis/cluster/redisCluster6381/redisCluster6382/cluster.conf</span><br></pre></td></tr></table></figure>

<p><strong>cluster.conf 文件的内容，不同的端口文件只需要更换 ip 端口就好了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6386</span><br><span class="line">logfile &quot;/myredis/cluster/redisCluster6386/cluster.log&quot;</span><br><span class="line">pidfile /myredis/cluster/redisCluster6386/cluster.pid</span><br><span class="line">dir /myredis/cluster/redisCluster6386</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">requirepass 111111</span><br><span class="line">masterauth 111111</span><br><span class="line"> </span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6386.conf</span><br><span class="line">cluster-node-timeout 5000</span><br></pre></td></tr></table></figure>

<p><strong>启动 6 台 redis 实例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /myredis/cluster/redisCluster6381/cluster.conf</span><br><span class="line">......</span><br><span class="line">redis-server /myredis/cluster/redisCluster6386/cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121000916770.png"></p>
<p><strong>构建集群关系</strong></p>
<p>构建集群关系的指令格式如下，其中 <code>--cluster-replicas 1 </code> 表示为每个 master 创建一个 slave 节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster create --cluster-replicas 1  127.0.0.1:6381  127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 127.0.0.1:6386</span><br></pre></td></tr></table></figure>

<p>执行构建集群的命令后，我们可以发现 <code>6381</code>，<code>6382</code> ，<code>6383</code> 为主节点，从节点依次为 <code>6384</code>，<code>6385</code>，<code>6386</code>。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121002035757.png"></p>
<p><strong>查验集群状态</strong><br>随便进入一台 redis 实例中去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看集群节点从属关系</span><br><span class="line">cluster nodes</span><br><span class="line">查看集群状态</span><br><span class="line">cluster info</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121003459885.png"></p>
<h4 id="集群读写"><a href="#集群读写" class="headerlink" title="集群读写"></a>集群读写</h4><blockquote>
<p>问题：为什么 set k1 v1 在 6383 端口是历下就能正常写入，而在 6381 就会报错</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121003818430.png"></p>
<p>由于 redis 使用了槽位分区，<code>k1</code> 经过 crc16 算法会落在 12706 的位置上，而该位置由实例 6383 负责。那么问题又来了，我们该如何解决这个问题呢?总不能每次都自己算一遍吧</p>
<blockquote>
<p>解决方案：进入实例时，新加 <code>-c</code> 参数优化路由</p>
</blockquote>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121004337765.png"></p>
<p>当我们想知道一个键会落在那个槽位置时，可以选择使用 <code>cluster keyslot 键名称</code></p>
<h4 id="主从容错迁移"><a href="#主从容错迁移" class="headerlink" title="主从容错迁移"></a>主从容错迁移</h4><blockquote>
<p>如果此时一台 6381 的主机停止服务，可能是发生宕机，也可能是发生其他因素导致需要停止该服务，那么会发生什么现象?</p>
</blockquote>
<p>我们在模拟宕机之前，6381 为主机，其从机为 6385，当我们手动停止 6381 的服务，再次查看集群状态，我们可以发现 6381 的状态标识已经变换成了 fail，而 6385 的角色从 slave 转换成了 master</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121234211822.png"></p>
<p> 我们模拟宕机问题处理完毕，重启 6381 服务 <code> redis-server /myredis/cluster/redisCluster6381/cluster.conf</code></p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121234951860.png"></p>
<p>查看集群状态，我们可以发现 6381 服务并未恢复到主机的地位，而是变成了 6385 的从机</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241121235107880.png"></p>
<p>设想我们 6381 服务器的性能较好，希望让其担任主机的角色，6385 成为其从机，我们应该如何调整节点的从属呢?</p>
<p>在从节点上执行 <code>CLUSTER FAILOVER</code> 命令，将启动手动故障转移过程</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122000241907.png"></p>
<blockquote>
<p><strong>注意</strong> 由于主机宕机，切换成从机上位需要一定的时间，如果此时刚好有其主机负责的槽位接收到了客户端请求，会响应给客户端请求响应失败，如果主机接收到了数据，未来得及同步到从机中去，立刻发生了宕机，则会导致数据的丢失。因此主从集群也<strong>无法保证数据的强一致性</strong></p>
</blockquote>
<h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><blockquote>
<p>随着业务量的增加，对集群需要进行扩容，在原有集群的基础上再增加两台 redis 实例，端口号分别为 6387 和 6388。分别是一主一从</p>
</blockquote>
<p>先启动两个 redis 实例，与之前 6 个服务启动 redis 实例的方式相同。内容参考 <a href="Redis%E5%B0%8F%E5%86%8C.md#%5E8208ce">三主三从集群配置</a> 我们可以发现，6387 和 6388 服务启动后并未直接加入集群中去</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122205053293.png"></p>
<p>将新增的 6387 节点作为 master 加原集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -a 密码 --cluster add-node 新增节点ip:端口 引路机器ip:端口</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122205954970.png"></p>
<p>此时我们检查集群状况 <code>redis-cli -a 密码 --cluster check 真实ip地址:端口</code> 可以发现，新增加进来的 6387 节点虽然被分配为了主节点，但是并没有负责的槽位</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122210450449.png"></p>
<p>使用 <code>redis-cli -a 密码 --cluster reshard IP地址:端口号</code> 重新分派槽位号。在执行重新分派的指令之后，程序会询问你要重新分派多少槽位，以及这些槽位要重新分配给谁，以及从哪些节点迁移槽位 (all 代表所有节点)。</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122211537084.png"></p>
<p>为新增的主节点添加从节点 6388</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- redis-cli -a 密码 --cluster add-node 新slaveip:端口  引路节点ip:端口 --cluster-slave --cluster-master-id 新主机节点ID </span><br><span class="line">redis-cli -a 111111 --clusetr add-node 127.0.0.1:6388 127.0.0.1:6384 --cluster-slave --cluster-master-id db03f008a93e4e878fd9d071090ecb3f72ad9cbe</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122212626161.png"></p>
<p>确定从节点加入完成后，我们检查一些当前集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster check 127.0.0.1:6381 </span><br></pre></td></tr></table></figure>

<p>根据下图我们可以看到，6388 节点已经成功加入集群，并且成为了 6377 的从节点</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122212846952.png"></p>
<h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><blockquote>
<p>集群既然能扩容，也相应的能缩容，我们现在将 6388 个 6387 两个节点从集群中移除</p>
</blockquote>
<p>移除集群节点前，先要获取节点的 ID</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122213545920.png"></p>
<p>直接执行删除从节点的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//  redis-cli -a 密码 --cluster del-node 从机ip:端口 从机节点ID</span><br><span class="line">redis-cli -a 111111 --cluster  del-node  127.0.0.1:6388 475638d51e2be82d3db552325e89b9ca5da5e83d</span><br></pre></td></tr></table></figure>

<p>我们使用同样的方式删除主节点，可以发现系统会提示我们 6387 下仍有数据，让我们重新分派槽位号之后再试</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122213935037.png"></p>
<p>按照提示，我们手动地在 Redis 集群中重新分配哈希槽，执行下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 111111 --cluster reshard 127.0.0.1:6387</span><br></pre></td></tr></table></figure>

<p>重新分配哈希槽的过程无非是，分配多少个哈希槽，由谁分出来，给谁的一个过程</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122214752427.png"></p>
<p>此时我们再次执行移除节点 6387 的指令，显示移除成功</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122215021973.png"></p>
<p>再次查看集群状况，我们可以发现集群状态再次变成了三主三从，不同点是，6381 节点负责了 8192 个槽位，这是因为我们将 6387 所有的槽位均分配给了 6381 的原因。至此我们实现了集群的缩容</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122215117956.png"></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote>
<p>不在同一个 slot 槽下的多键操作支持不好，需要使用通用占位符</p>
</blockquote>
<p>使用 mset 直接操作 三个 key，提示这些 key 的哈希不在同一个槽位下</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220037410.png"></p>
<p>因此我们需要使用哈希标签 <code>&#123;&#125;</code>，用于确保这组键会被分到一起 <img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220208881.png"></p>
<p>同样，我们使用 mget 的时候，也会遇到这种问题，也是使用哈希标签来解决问题</p>
<p><img src="/assets/Redis%E5%B0%8F%E5%86%8C/file-20241122220340548.png"></p>
<blockquote>
<p>现在集群架构是 3 主 3 从的 集群 r 由 3 个 master 平分 16384 个 slot，每个 master 的小集群负责 1&#x2F;3 的 slot，对应一部分数据。<strong>cluster-require-full-coverage：</strong> 默认值 yes , 即需要集群完整性，方可对外提供服务 通常情况，如果这 3 个小集群中，任何一个（1 主 1 从）挂了，你这个集群对外可提供的数据只有 2&#x2F;3 了， 整个集群是不完整的， redis 默认在这种情况下，是不会对外提供服务的。如果你的诉求是，集群不完整的话也需要对外提供服务，需要将该参数设置为 no，不是很建议这样做</p>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="https://redis.com.cn/documentation.html">redis 中文文档</a></li>
<li><a href="http://www.redis.cn/commands.html">Redis 命令中心）</a></li>
<li><a href="https://redis.io/">Redis 官网</a></li>
</ul>
]]></content>
      <tags>
        <tag>数据/redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SqlManger开发文档</title>
    <url>/2024/12/09/archive/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote>
<p>教程地址 <a href="https://www.w3schools.cn/pyqt5/index.html">PyQt5 教程 (w3schools.cn)</a></p>
</blockquote>
<h2 id="开发记录"><a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote>
<p>新建 python 项目, 环境选择新的 venv 环境</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231212174014517.png"></p>
<h3 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h3><blockquote>
<p>当前依赖为项目新增依赖, 后续可能会随开发进行更新</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提供了与 Python 3.5 或更高版本兼容的 32 位或 64 位架构的 wheels</span><br><span class="line">pip3 install PyQt5</span><br><span class="line"># 要安装 Qt Designer 等开发工具以支持 PyQt5 wheels</span><br><span class="line">pip3 install pyqt5-tools</span><br><span class="line"># 安装链接mysql所需依赖</span><br><span class="line">pip3 install pymysql</span><br><span class="line"># 链接mysql时所用到的加密方式</span><br><span class="line">pip3 install cryptography</span><br><span class="line"># 美化包依赖, 拉取依赖时, 不能使用豆瓣源, 豆瓣源没有这个依赖</span><br><span class="line">pip3 install qdarkstyle</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果直接使用官方镜像源出现安装失败的情况, 可以考虑国内的镜像源</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">pip3 install &#123;package&#125; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># 豆瓣源</span></span><br><span class="line">pip3 install &#123;package&#125; -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>

<p>安装依赖方式参考下图</p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231212175153752.png"></p>
<h3 id="设计-UI"><a href="#设计-UI" class="headerlink" title="设计 UI"></a>设计 UI</h3><blockquote>
<p>打开设计器路径 {项目路径}\venv\Lib\site-packages\qt5_applications\Qt\bin\designer.exe</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231212175609378.png"></p>
<blockquote>
<p>设计以下 UI 文件<br>主窗口 UI: sqlManger_ui.ui<br>新增记录模态框 UI: addrowdialog_ui.ui</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215150125976.png"></p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215150325964.png"></p>
<blockquote>
<p>UI 文件转成成 Python 文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyuic5 -x sqlManger_ui.ui -o sqlManger_ui.py</span><br><span class="line"></span><br><span class="line">pyuic5 -x addrowdialog_ui.ui -o addrowdialog_ui.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213113642881.png"></p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215150646257.png"></p>
<blockquote>
<p>转换完成后会生成以下文件</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215150806994.png"></p>
<blockquote>
<p>新增记录时, 不同的表格数据不同, 因此需要动态加载模态框表单项,<br>💡 技术点: <code>setattr</code> 与 <code>getattr</code> 方法的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setattr</span>(目标对象, 属性名, 属性值)</span><br><span class="line"><span class="built_in">getattr</span>(目标对象, 属性名, 属性值)</span><br></pre></td></tr></table></figure>

<p>重构 <code>addrowdialog_ui.py</code> 下的 <code>setupUi</code> <code>retranslateUi</code> 方法, 设置表单项时, 设置成由传入参数动态加载, 文件调整如下</p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215153026800.png"></p>
<h3 id="各个功能点信号与槽函数建立链接"><a href="#各个功能点信号与槽函数建立链接" class="headerlink" title="各个功能点信号与槽函数建立链接"></a>各个功能点信号与槽函数建立链接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接按钮</span></span><br><span class="line"><span class="variable language_">self</span>.ui.connbut.clicked.connect(<span class="variable language_">self</span>.conn_database)</span><br><span class="line"><span class="comment"># 查询按钮</span></span><br><span class="line"><span class="variable language_">self</span>.ui.querybut.clicked.connect(<span class="variable language_">self</span>.execute_query)</span><br><span class="line"><span class="comment"># 回滚按钮</span></span><br><span class="line"><span class="variable language_">self</span>.ui.roolbackbut.clicked.connect(<span class="variable language_">self</span>.rollback_database)</span><br><span class="line"><span class="comment"># 提交按钮</span></span><br><span class="line"><span class="variable language_">self</span>.ui.commitbut.clicked.connect(<span class="variable language_">self</span>.commit_database)</span><br><span class="line"><span class="comment"># 切换数据库选择</span></span><br><span class="line"><span class="variable language_">self</span>.ui.database.currentIndexChanged.connect(<span class="variable language_">self</span>.change_database)</span><br><span class="line"><span class="comment"># 更改主题</span></span><br><span class="line"><span class="variable language_">self</span>.ui.themeComboBox.currentIndexChanged.connect(<span class="variable language_">self</span>.change_theme)</span><br><span class="line"><span class="comment"># 右键表格, 展示菜单</span></span><br><span class="line"><span class="variable language_">self</span>.ui.tableView.setContextMenuPolicy(Qt.CustomContextMenu)</span><br><span class="line"><span class="variable language_">self</span>.ui.tableView.customContextMenuRequested.connect(<span class="variable language_">self</span>.display_table_menu)</span><br></pre></td></tr></table></figure>

<h3 id="Mysql-数据库的使用"><a href="#Mysql-数据库的使用" class="headerlink" title="Mysql 数据库的使用"></a>Mysql 数据库的使用</h3><blockquote>
<p>下载 mysql 相关依赖</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install mysql-connector-python</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为涉及到事务的回滚, 所以当前应用获取的数据库链接为单例, 代码如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_connection</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> Utils.connection <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> Utils.connection</span><br><span class="line">    Utils.connection = pymysql.connect(</span><br><span class="line">        <span class="comment"># 数据库主机名</span></span><br><span class="line">        host=<span class="variable language_">self</span>.ui.host.text(),</span><br><span class="line">        <span class="comment"># 数据库端口号，默认为3306</span></span><br><span class="line">        port=<span class="built_in">int</span>(<span class="variable language_">self</span>.ui.port.text()),</span><br><span class="line">        <span class="comment"># 数据库用户名</span></span><br><span class="line">        user=<span class="variable language_">self</span>.ui.username.text(),</span><br><span class="line">        <span class="comment"># 数据库密码</span></span><br><span class="line">        passwd=<span class="variable language_">self</span>.ui.pwd.text(),</span><br><span class="line">        <span class="comment"># 字符编码</span></span><br><span class="line">        charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> Utils.connection</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cursor</span>():</span><br><span class="line">    <span class="keyword">if</span> Utils.cursor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> Utils.cursor</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> Utils.connection <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            Utils.connection = Utils.get_connection()</span><br><span class="line">            Utils.cursor = Utils.connection.cursor()</span><br><span class="line">            <span class="keyword">return</span> Utils.cursor</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Utils.cursor = Utils.connection.cursor()</span><br><span class="line">            <span class="keyword">return</span> Utils.cursor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务的开启<br>开启时机: 与数据库建立链接之后</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">cursor.execute(<span class="string">&quot;BEGIN&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务的提交<br>提交时机: 点击提交按钮</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Utils.get_connection(<span class="variable language_">self</span>).commit()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务的回滚<br>回滚时机</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Utils.get_connection(<span class="variable language_">self</span>).rollback()</span><br></pre></td></tr></table></figure>

<h3 id="增加美化包"><a href="#增加美化包" class="headerlink" title="增加美化包"></a>增加美化包</h3><blockquote>
<p>原本的 QT 样式不怎么好看, 集成一下美化包</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install qdarkstyle -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>安装插件时, 不能使用豆瓣源, 豆瓣源没有这个依赖</p>
<blockquote>
<p>main.py 入口文件给实例设置浅色样式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api=<span class="string">&#x27;pyqt5&#x27;</span>, palette=LightPalette()))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换主题样式的实现</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215163133407.png"></p>
<p>监控下拉框数据改变的信号, 链接对应的槽函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为主题切换的信号和槽函数简历链接</span></span><br><span class="line"><span class="variable language_">self</span>.ui.themeComboBox.currentIndexChanged.connect(<span class="variable language_">self</span>.change_theme)</span><br></pre></td></tr></table></figure>

<p>切换主题的方法实现, 与启动项目时需要添加一步获取应用实例的操作 <code>Utils.get_app_self()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_theme</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.ui.themeComboBox.currentText() == <span class="string">&quot;Dark&quot;</span>:</span><br><span class="line">        Utils.get_app_self().setStyleSheet(qdarkstyle.load_stylesheet(qt_api=<span class="string">&#x27;pyqt5&#x27;</span>, palette=DarkPalette()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Utils.get_app_self().setStyleSheet(qdarkstyle.load_stylesheet(qt_api=<span class="string">&#x27;pyqt5&#x27;</span>, palette=LightPalette()))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔍 qt-material 有更丰富的样式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install qt-material</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用样式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态加载qt-material主题</span></span><br><span class="line"><span class="keyword">import</span> site</span><br><span class="line"><span class="comment"># venv/Lib/site-packages/qt_material/themes 读取该路径下的文件名</span></span><br><span class="line">site_packages_path = site.getsitepackages()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># self.ui.themeComboBox.addItems(&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  venv/Lib/site-packages/qt_material/themes 读取该路径下的文件名</span></span><br><span class="line">apply_stylesheet(app, theme=<span class="string">&#x27;light_blue_500.xml&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="新增窗口增加滚动条"><a href="#新增窗口增加滚动条" class="headerlink" title="新增窗口增加滚动条"></a>新增窗口增加滚动条</h3><blockquote>
<p>参考资料 <a href="https://blog.csdn.net/weixin_43749427/article/details/114883239">Qt designer + ScrollArea 实现滚动界面_qt designer scrollarea-CSDN 博客</a></p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215235502027.png"></p>
<h3 id="虚拟环境-Venv-同步"><a href="#虚拟环境-Venv-同步" class="headerlink" title="虚拟环境 Venv 同步"></a>虚拟环境 Venv 同步</h3><blockquote>
<p>参考资料: <a href="https://blog.csdn.net/pearl8899/article/details/113877334">python 项目自动生成环境配置文件 requirements.txt_如何生成 requirements.txt-CSDN 博客</a></p>
</blockquote>
<blockquote>
<p>生成 requirements.txt 文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装依赖,根据 requirements.txt</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="异常问题记录"><a href="#异常问题记录" class="headerlink" title="异常问题记录"></a>异常问题记录</h2><h3 id="QSqlDatabase-无法加载-MYSQL-驱动-未解决"><a href="#QSqlDatabase-无法加载-MYSQL-驱动-未解决" class="headerlink" title="QSqlDatabase 无法加载 MYSQL 驱动 (未解决)"></a>QSqlDatabase 无法加载 MYSQL 驱动 (未解决)</h3><blockquote>
<p>问题现象</p>
</blockquote>
<p>QSqlDatabase 无法链接 MYSQL 数据库, 提示无法加载驱动问题</p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213155858030.png"></p>
<blockquote>
<p>参考资料:</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_34769196/article/details/103898208">PyQt5 使用 QSqlDatabase 类连接 Mysql 的坑</a></p>
<blockquote>
<p>问题原因:</p>
</blockquote>
<p>最新版本的 QT 缺失 MYSQL 驱动的相关文件</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>根据以上的参考文章操作后问题也没有解决, 最后该问题选择通过 pymysql 链接数据库, 获取数据, 使用标准的 model 来展示</p>
<h3 id="获取-MYSQL-数据库链接报加密异常-已解决"><a href="#获取-MYSQL-数据库链接报加密异常-已解决" class="headerlink" title="获取 MYSQL 数据库链接报加密异常 (已解决)"></a>获取 MYSQL 数据库链接报加密异常 (已解决)</h3><blockquote>
<p>问题现象</p>
</blockquote>
<p>链接 MYSQL 在密码, 端口等信息均正确的情况下, 报如下异常</p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231214101243230.png"></p>
<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="https://blog.csdn.net/coco56/article/details/107948413">RuntimeError: ‘cryptography‘ package is required for sha256_password or caching_sha2_password auth m-CSDN 博客</a></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><h3 id="项目基础环境"><a href="#项目基础环境" class="headerlink" title="项目基础环境"></a>项目基础环境</h3><blockquote>
<p>已安装 Python3, 可使用以下版本查看 python 版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure>

<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213222735318.png"></p>
<blockquote>
<p>已安装 MySql8.0 及以上版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213215913574.png"></p>
<h3 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h3><blockquote>
<p>首先从 GITHUB 拉取项目, GIT 命令行或者下图方式均可<br>项目地址: <a href="https://github.com/lei-ctyh/sqlManger.git">https://github.com/lei-ctyh/sqlManger.git</a></p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213215158278.png"></p>
<h3 id="配置项目解释器"><a href="#配置项目解释器" class="headerlink" title="配置项目解释器"></a>配置项目解释器</h3><blockquote>
<p>按照自己需求配置项目解释器即可<br><code>ctrl</code> + <code>alt</code> + <code>s</code> 进入设置 , 具体操作如下图</p>
</blockquote>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213220223107.png"></p>
<p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213220436985.png"></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><blockquote>
<p>安装依赖,根据 requirements.txt</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231213222023427.png"></p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="/assets/SqlManger%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20231215170946953.png"></p>
]]></content>
      <tags>
        <tag>其他/技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtualbox7安装及使用详细步骤</title>
    <url>/2024/12/10/archive/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><blockquote>
<p>Virtualbox 软件安装包 <a href="https://www.virtualbox.org/wiki/Downloads">Downloads – Oracle VM VirtualBox</a></p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317145609332.png"></p>
<blockquote>
<p>centerOS7 镜像 <a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">centos-7-isos-x86_64 安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317145815189.png"></p>
<h2 id="安装-Virtualbox"><a href="#安装-Virtualbox" class="headerlink" title="安装 Virtualbox"></a>安装 Virtualbox</h2><blockquote>
<p>使用管理员身份运行 VirtualBox-7.0.14-161095-Win.exe</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317150126977.png"></p>
<blockquote>
<p>进入向导界面, 点击下一步</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004204897.png"></p>
<blockquote>
<p>点击 <code>浏览</code> 按钮，自定义安装路径，点击下一步</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004229962.png"></p>
<blockquote>
<p>此时会出现警告，这是由于安装时会增加虚拟网卡，属于正常现象，点击按钮 <code>是</code> 即可</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004306436.png"></p>
<blockquote>
<p>点击安装</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004325481.png"></p>
<blockquote>
<p>稍等片刻即可</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004414548.png"></p>
<blockquote>
<p>点击完成，此时会自动打开</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323004445886.png"></p>
<h2 id="创建虚拟电脑"><a href="#创建虚拟电脑" class="headerlink" title="创建虚拟电脑"></a>创建虚拟电脑</h2><blockquote>
<p>在欢迎页点击新建</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317172127494.png"></p>
<blockquote>
<p>切换为专家模式</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317172308301.png"></p>
<blockquote>
<p>填写虚拟电脑名称和系统类型, 参照下图, 名称和文件夹可以按需填写</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317172429508.png"></p>
<blockquote>
<p>分配硬件信息, 我这分配的运存为 4G, 4 个处理器,可以按照自己的电脑实际情况填写</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317172634529.png"></p>
<blockquote>
<p>分配 50GB 的硬盘, 可以按需分配, 不要勾选 <code>预先分配全部空间</code>, 点击完成即可</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317172830316.png"></p>
<h2 id="配置电脑相关信息"><a href="#配置电脑相关信息" class="headerlink" title="配置电脑相关信息"></a>配置电脑相关信息</h2><blockquote>
<p>右键新建的虚拟机，弹窗选项面板，点击设置</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321102313647.png"></p>
<blockquote>
<p>设置常规选项卡, 开启共享剪切板功能</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317173209083.png"></p>
<blockquote>
<p>显示选项卡, 拉满显存大小</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317173425672.png"></p>
<blockquote>
<p>选择启动映像, 即之前下载的 centos7 的 iso 文件</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317173649026.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317173722706.png"></p>
<blockquote>
<p>网络选项卡，链接方式设置为桥接网卡</p>
</blockquote>
<p>此处不推荐使用 NAT 网络的原因是由于, virtualBox 的 NAT 网络下, 主机无法访问虚拟机, 虽然会占用真实的 IP, 不过个人学习使用的话地址满够分配的</p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317173824260.png"></p>
<blockquote>
<p>关于网卡名称的选择：</p>
</blockquote>
<p>查看当前使用的网卡名称：<code>设置</code> -&gt; <code>网络和Internet</code> -&gt; <code>属性</code> -&gt; <code>描述</code>，或者使用下图中的 gif 方式作为参考</p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/recording%201.gif"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240323002631131.png"></p>
<blockquote>
<p>设置完毕, 点击确定, 启动虚拟机</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317174153258.png"></p>
<h2 id="安装-Centeros7"><a href="#安装-Centeros7" class="headerlink" title="安装 Centeros7"></a>安装 Centeros7</h2><blockquote>
<p>加电启动虚拟机之后, 显示系统安装界面，启动时可能会出现一些问题，解决方法参考文章末尾</p>
</blockquote>
<p>通过键盘的 <code>↑</code> 和 <code>↓</code> 键选择安装选项, <code>Enter</code> 回车键确认, 下方红框内的代表为直接安装和先检测后安装, 选择哪个都可以</p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317174515009.png"></p>
<blockquote>
<p>选择语言</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317174821200.png"></p>
<blockquote>
<p>设置软件选择, 基本环境选择 <code>GHOME桌面</code>, 附加选项勾选 <code>开发环境和安全性工具</code></p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317175037865.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317175107836.png"></p>
<blockquote>
<p>配置分区, 设置为手动分区</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317175257462.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317175318593.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317175359893.png"></p>
<blockquote>
<p>点击下图 <code>＋</code> 号, 开始添加分区, 分区建议参考 <a href="https://blog.csdn.net/weixin_39206909/article/details/120231440">CentOS7 手动磁盘分区详解_centos7 分区-CSDN 博客</a></p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/recording.gif"></p>
<table>
<thead>
<tr>
<th>分区类型</th>
<th>分区大小</th>
<th>设备类型</th>
<th>文件系统</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;boot</td>
<td>1G</td>
<td>标准分区</td>
<td>ext-4</td>
<td>系统启动时的引导分区</td>
</tr>
<tr>
<td>swap</td>
<td>4G</td>
<td>标准分区</td>
<td>swap</td>
<td>和自己的运存大小一致即可</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>45G</td>
<td>标准分区</td>
<td>ext-4</td>
<td>剩余的全部硬盘容量</td>
</tr>
</tbody></table>
<blockquote>
<p>确认进行分区</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317180901204.png"></p>
<blockquote>
<p>设置网络和主机名</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317181007501.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317181709608.png"></p>
<blockquote>
<p>点击开始安装, 安装期间设置 Root 密码和创建用户即可, 参照下图, 如果密码过于简单需要按两次完成按钮</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317181803113.png"></p>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317181911658.png"></p>
<blockquote>
<p>安装完成, 点击重启即可</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317182529974.png"></p>
<h2 id="Centeros-初始化配置"><a href="#Centeros-初始化配置" class="headerlink" title="Centeros 初始化配置"></a>Centeros 初始化配置</h2><blockquote>
<p>接受许可证,完成配置</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317185126489.png"></p>
<blockquote>
<p>输入账号密码, 进入系统</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317185200374.png"></p>
<blockquote>
<p>测试网络状况, 右键桌面, 打开终端</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317185352405.png"></p>
<blockquote>
<p>ping 百度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317185445969.png"></p>
<h2 id="安装增强功能"><a href="#安装增强功能" class="headerlink" title="安装增强功能"></a>安装增强功能</h2><p>Virtualbox 在不安装增强功能扩展的情况下, 无法自适应分辨率和共享剪切板等操作, 下面为如何安装增强功能扩展</p>
<blockquote>
<p>安装 perl</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install perl</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317185930677.png"></p>
<blockquote>
<p>安装 elfutils-libelf-devel</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install elfutils-libelf-devel</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317190021805.png"></p>
<blockquote>
<p>点击安装增强功能</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317190212133.png"></p>
<blockquote>
<p>点击运行增强功能的 iso 文件</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317190250576.png"></p>
<blockquote>
<p>出现下图文字, 代表安装成功</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317190436359.png"></p>
<blockquote>
<p>重启虚拟机, 显存不够的话可能渲染不出来</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240317192159253.png"></p>
<h2 id="配置优化项"><a href="#配置优化项" class="headerlink" title="配置优化项"></a>配置优化项</h2><h3 id="全局设置虚拟机安装路径"><a href="#全局设置虚拟机安装路径" class="headerlink" title="全局设置虚拟机安装路径"></a>全局设置虚拟机安装路径</h3><blockquote>
<p>打开全局设置</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171608418.png"></p>
<blockquote>
<p>选择合适的路径，点击 <code>确定</code> 即可。💡 不建议装在 C 盘，当然电脑未分区的除外</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171714346.png"></p>
<blockquote>
<p>再次新建虚拟机，默认安装路径就变成刚刚设置的了</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171935263.png"></p>
<h3 id="更改主机组合键"><a href="#更改主机组合键" class="headerlink" title="更改主机组合键"></a>更改主机组合键</h3><p>有一些小伙伴应该使用过 VmWare，VM 如果想要将鼠标从虚拟机移除到主集，需要按住 <code>Ctrl + Alt</code> 键，而 Virtualbox 则默认是 <code>右Ctrl</code> 键，不过我们可以做出更改</p>
<blockquote>
<p>打开全局设定</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171608418.png"></p>
<blockquote>
<p>选择左侧热键</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321172453962.png"></p>
<blockquote>
<p>点击虚拟电脑</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321172518434.png"></p>
<blockquote>
<p>更改此处的主机组合键，点击确定即可</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321172549673.png"></p>
<h2 id="常见问题及解决办法"><a href="#常见问题及解决办法" class="headerlink" title="常见问题及解决办法"></a>常见问题及解决办法</h2><h3 id="启动报错：E-FAIL-0X80004005"><a href="#启动报错：E-FAIL-0X80004005" class="headerlink" title="启动报错：E_FAIL (0X80004005)"></a>启动报错：E_FAIL (0X80004005)</h3><blockquote>
<p>Q：启动报错</p>
</blockquote>
<p><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321165234379.png"></p>
<blockquote>
<p>排查过程</p>
</blockquote>
<ul>
<li>根据提示，查看相关日志<img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321165348661.png"></li>
<li>跟踪日志异常，发现加载驱动的路径书写有误<img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321165507853.png"></li>
<li>从官网查阅相关问题的解决方案：<a href="https://forums.virtualbox.org/viewtopic.php?t=108749">VM 无法启动 rc&#x3D;126 强化 VBoxRT.dll enmWhat&#x3D;4 - virtualbox.org</a></li>
</ul>
<blockquote>
<p>解决步骤：</p>
</blockquote>
<ul>
<li>下载方案中涉及的工具：<a href="https://www.wireshark.org/download.html">Wireshark · Download</a><img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171132103.png"></li>
<li>下载完成，右键以管理员运行，一路 <code>next</code> 即可，也可以更换安装路径以安装<img src="/assets/Virtualbox7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/image-20240321171339572.png"></li>
</ul>
]]></content>
      <tags>
        <tag>运维/linux</tag>
        <tag>工具/virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装kafka集群</title>
    <url>/2024/12/09/archive/docker%E5%AE%89%E8%A3%85kafka%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="搭建-Docker-基本环境"><a href="#搭建-Docker-基本环境" class="headerlink" title="搭建 Docker 基本环境"></a>搭建 Docker 基本环境</h2><p>搭建 docker 环境非本处详细讲解, 了解或查阅资料即可</p>
<h2 id="拉取镜像-zookeeper-以及-Kafka-的"><a href="#拉取镜像-zookeeper-以及-Kafka-的" class="headerlink" title="拉取镜像 (zookeeper 以及 Kafka 的)"></a>拉取镜像 (zookeeper 以及 Kafka 的)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister/zookeeper</span><br><span class="line">docker pull wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<h2 id="启动启动-Zookeeper-容器"><a href="#启动启动-Zookeeper-容器" class="headerlink" title="启动启动 Zookeeper 容器"></a>启动启动 Zookeeper 容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker run</code>: 运行一个新的容器。</li>
<li><code>-d</code>: 指定容器在后台以守护进程模式运行。</li>
<li><code>--name zookeeper</code>: 为容器指定一个名称，即 “zookeeper”。</li>
<li><code>-p 2181:2181</code>: 将容器的 2181 端口映射到宿主机的 2181 端口。格式为 <code>&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>。</li>
<li><code>-t</code>: 分配一个伪终端（pseudo-TTY）。</li>
<li><code>wurstmeister/zookeeper</code>: 使用 wurstmeister&#x2F;zookeeper 镜像创建容器。</li>
</ul>
<h2 id="启动启动-Kafka-容器"><a href="#启动启动-Kafka-容器" class="headerlink" title="启动启动 Kafka 容器"></a>启动启动 Kafka 容器</h2><blockquote>
<p>宿主机 ip 需要以实际为准, 不能使用 localhost 的原因为: docker 各个容器的网络是相互通的, 所以需要将 docker 内部的接口映射到宿主机上, 然后实现各个容器之间的相互访问</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run  -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=&lt;宿主机ip&gt;:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://&lt;宿主机ip&gt;:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br><span class="line">docker run  -d --name kafka1 -p 9093:9093 -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=&lt;宿主机ip&gt;:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://&lt;宿主机ip&gt;:9093 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9093 -t wurstmeister/kafka</span><br><span class="line">docker run  -d --name kafka2 -p 9094:9094 -e KAFKA_BROKER_ID=2 -e KAFKA_ZOOKEEPER_CONNECT=&lt;宿主机ip&gt;:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://&lt;宿主机ip&gt;:9094 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9094 -t wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker run</code>: 运行一个新的容器。</li>
<li><code>-d</code>: 指定容器在后台以守护进程模式运行。</li>
<li><code>--name kafka</code>: 为容器指定一个名称，即 “kafka”。</li>
<li><code>-p 9092:9092</code>: 将容器的 9092 端口映射到宿主机的 9092 端口。格式为 <code>&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>。</li>
<li><code>-e KAFKA_BROKER_ID=0</code>: 设置 Kafka Broker 的唯一标识符为 0。</li>
<li><code>-e KAFKA_ZOOKEEPER_CONNECT=&lt;宿主机ip&gt;:2181</code>: 指定与 ZooKeeper 的连接地址，其中 <code>&lt;宿主机ip&gt;</code> 需要替换为实际的宿主机 IP 地址。</li>
<li><code>-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://&lt;宿主机ip&gt;</code>: 设置 Kafka 的广告监听器地址，用于外部访问，其中 <code>&lt;宿主机ip&gt;</code> 需要替换为实际的宿主机 IP 地址。</li>
<li><code>-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092</code>: 设置 Kafka 的监听器地址，允许从任意地址访问 Kafka，监听 9092 端口。</li>
<li><code>-t</code>: 分配一个伪终端（pseudo-TTY）。</li>
<li><code>wurstmeister/kafka</code>: 使用 wurstmeister&#x2F;kafka 镜像创建容器。</li>
</ul>
<h2 id="创建和查看-Topic-，ip-改为宿主机器的-IP-地址"><a href="#创建和查看-Topic-，ip-改为宿主机器的-IP-地址" class="headerlink" title="创建和查看 Topic ，ip 改为宿主机器的 IP 地址"></a>创建和查看 Topic ，ip 改为宿主机器的 IP 地址</h2><blockquote>
<p>创建 Replication 为 2，Partition 为 2 的 topic（容器目录 opt&#x2F;kafka_2.11-2.0.0&#x2F;中执行）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper &lt;宿主机ip&gt;:2181 --replication-factor 2 --partitions 2 --topic &lt;主题名称&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 topic 的状态（容器目录 opt&#x2F;kafka_2.11-2.0.0&#x2F;中执行）Isr 代表存活的备份机器中存活的。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper &lt;宿主机ip&gt;:2181 --topic &lt;主题名称&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有的 topic 名字</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --bootstrap-server &lt;宿主机ip&gt;:9092 --list</span><br></pre></td></tr></table></figure>

<h2 id="发送测试-192-168-0-89-9092-宿主机-Ip-test-topic-主题"><a href="#发送测试-192-168-0-89-9092-宿主机-Ip-test-topic-主题" class="headerlink" title="发送测试 192.168.0.89:9092 宿主机 Ip test_topic 主题"></a>发送测试 192.168.0.89:9092 宿主机 Ip test_topic 主题</h2><blockquote>
<p>启动消息发送方（容器目录 opt&#x2F;kafka_2.11-2.0.0&#x2F;中执行）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list 192.168.0.89:9092 --topic test_topic</span><br></pre></td></tr></table></figure>

<p><img src="/assets/docker%E5%AE%89%E8%A3%85kafka%E9%9B%86%E7%BE%A4/image-20240105102816402.png"></p>
<blockquote>
<p>启动消息接收方（容器目录 opt&#x2F;kafka_2.11-2.0.0&#x2F;中执行）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server 192.168.0.89:9092:9092 --topic test_topic --from-beginning</span><br></pre></td></tr></table></figure>

<p><img src="/assets/docker%E5%AE%89%E8%A3%85kafka%E9%9B%86%E7%BE%A4/image-20240105102843546.png"></p>
]]></content>
      <tags>
        <tag>数据/kafka</tag>
        <tag>运维/docker</tag>
      </tags>
  </entry>
  <entry>
    <title>obsidian-sync-cnblog</title>
    <url>/2024/12/09/archive/obsidian-sync-cnblog/</url>
    <content><![CDATA[<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><blockquote>
<p>由于 Markdown 语法的便捷性, 我们从繁重的排版布局工作中解脱出来, 越来越多的人开始接受这种写作方式, 该插件可以将你的 md 笔记, 方便的同步到博客园中, 即使你是使用的本地图片, 也无须担心, 他都能轻松应对, 并且不会对你的本地文档造成任何影响</p>
</blockquote>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><blockquote>
<p>当你打开这个教程，我想我已经无需再向你介绍 Obsidian 这个笔记软件了，如果你也有博文创作，或者分享自己 md 文章的需求, 那么请看过来，希望本文对你能有所帮助。</p>
</blockquote>
<h3 id="下载依赖插件"><a href="#下载依赖插件" class="headerlink" title="下载依赖插件"></a>下载依赖插件</h3><blockquote>
<p>关闭安全模式，如果已经关闭可跳过此步骤<br>路径: <code>设置</code> -&gt; <code>选项</code> -&gt; <code>第三方插件</code></p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220202744407.png"></p>
<blockquote>
<p>打开社区插件市场，这可能需要你会一点点的魔法<br>路径: <code>设置</code> -&gt; <code>选项</code> -&gt; <code>第三方插件</code></p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220202927750.png"></p>
<blockquote>
<p>社区插件市场内搜索 <code>Custom Attachment Location</code></p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220203349000.png"></p>
<blockquote>
<p>点击搜索出的插件，点击安装</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220203514909.png"></p>
<blockquote>
<p>点击启用该插件</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220203606565.png"></p>
<blockquote>
<p>下载 obsidian-sync-cnblog</p>
</blockquote>
<p>操作步骤如上</p>
<h3 id="Obsidian-配置"><a href="#Obsidian-配置" class="headerlink" title="Obsidian 配置"></a>Obsidian 配置</h3><blockquote>
<p>我们需要进入到 <code>设置</code> -&gt; <code>选项</code> -&gt; <code>文件与链接</code> 选项卡，将下图中红框内的设置项调整成与图片一致</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220201953115.png"></p>
<h3 id="Custom-Attachment-Location-配置"><a href="#Custom-Attachment-Location-配置" class="headerlink" title="Custom Attachment Location 配置"></a>Custom Attachment Location 配置</h3><blockquote>
<p>进入 <code>Custom Attachment Location</code> 选项卡，按照下图配置项依次配置即可<br>路径: <code>设置</code> -&gt; <code>第三方插件</code> -&gt; <code>Custom Attachment Location</code></p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231220204158099.png"></p>
<h3 id="Sync-Cnblog-配置"><a href="#Sync-Cnblog-配置" class="headerlink" title="Sync Cnblog 配置"></a>Sync Cnblog 配置</h3><blockquote>
<p>进入 <code>sync-cnblog</code> 选项卡，即可看到下图中的五个参数, 我们将依次介绍</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20240108111855289.png"></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参考值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>blog_url</code></td>
<td>按实际配置</td>
<td><a href="#%E5%8D%9A%E5%AE%A2%E5%9B%AD%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96">点我教给你</a></td>
</tr>
<tr>
<td><code>username</code></td>
<td>按实际配置</td>
<td><a href="#%E5%8D%9A%E5%AE%A2%E5%9B%AD%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96">点我教给你</a></td>
</tr>
<tr>
<td><code>password</code></td>
<td>按实际配置</td>
<td><a href="#%E5%8D%9A%E5%AE%A2%E5%9B%AD%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96">点我教给你</a></td>
</tr>
<tr>
<td><code>location_posts</code></td>
<td>按需选择同步目录</td>
<td>仅在同步目录下的文章才有上传功能</td>
</tr>
<tr>
<td><code>throttling_mode</code></td>
<td>开启</td>
<td>开启模式下，同一个文章中的图片不会反复上传，建议开启</td>
</tr>
</tbody></table>
<h2 id="博客园相关参数获取"><a href="#博客园相关参数获取" class="headerlink" title="博客园相关参数获取"></a>博客园相关参数获取</h2><p>访问如下链接 <a href="https://i.cnblogs.com/settings">博客后台 - 博客园 (cnblogs.com)</a></p>
<blockquote>
<p>未登录用户会跳转登录页面, 输入自己的账号密码登录即可,登录成功后。会跳转博客园后台, 滑到页面底部即可看到如下页面</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20240108115936582.png"></p>
<ul>
<li>勾选允许 MetaWeblog 博客客户端访问</li>
<li>参考上图配置如下参数 <code>blog_url</code>，<code>username</code>，<code>password</code></li>
</ul>
<h2 id="验证插件是否可用"><a href="#验证插件是否可用" class="headerlink" title="验证插件是否可用"></a>验证插件是否可用</h2><blockquote>
<p>点击左侧按钮, 弹出博客园名称, 即代表参数正常, 插件可用</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/recording%201.gif"></p>
<h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><blockquote>
<p>启用插件后, 右键.md 结尾的文件会出现 <code>同步到博客园</code> 的按钮, 点击该按钮, 文章会自动发布到博客园</p>
</blockquote>
<p><img src="/assets/obsidian-sync-cnblog/image-20231225150705983.png"></p>
<h2 id="修改文章"><a href="#修改文章" class="headerlink" title="修改文章"></a>修改文章</h2><blockquote>
<p>如果已经上传的文章, 再次点击 <code>同步到博客园</code> 的按钮, 会对博客园已发布文章进行更新</p>
</blockquote>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><blockquote>
<p>当前插件会自动检查重命名操作, 如果该文章已经上传博客园, 并且进行了重命名, 博客园文章的名称也会自动进行重命名的操作，不过文章的内容不会进行更新，如果需要更新请手动上传</p>
</blockquote>
]]></content>
      <tags>
        <tag>其他/技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title>利息计算方式</title>
    <url>/2024/12/09/archive/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>😀不会算就上科技 <a href="https://daikuan.bmcx.com/">贷款计算器最新2024 - 贷款利息计算 (bmcx.com)</a></p>
</blockquote>
<h2 id="还款方式的划分"><a href="#还款方式的划分" class="headerlink" title="还款方式的划分"></a>还款方式的划分</h2><ul>
<li><strong>等额本息 (常见)</strong>  等额本息还款是指<span style="background:rgba(240, 107, 5, 0.2)">借款人每月偿还的月供是相等的</span>，每月月供&#x3D;（贷款本金 + 贷款总利息）÷贷款期限（月），由于每月剩余未还本金不同，所以每月月供中的利息不同，还款初期，月供中利息占比多，本金占比少，随着每月还款，月供中的本金占比越来越多，利息占比越来越少，这种还款方式适合收入稳定的群体。</li>
<li><strong>等额本金 (常见)</strong>  等额本金还款是指借款人每月偿还的本金是相同的，每月月供中利息随着本金的减少而逐月减少，因此等额本金还款方式下，月供是呈递减状态的，等额本金与等额本息还款相比，等额本金产生的贷款总利息会少一些，但是等额本金还款方式下，还款初期压力比较到，这种还款方式适合目前高收入人群。</li>
<li><strong>按期还本付息</strong>  按期还本付息是借款人与银行协商制定的不同还款时间单位，例如按月、按季、按年还款，实际上就是借款人根据不同的财务状况将每月要还款的钱分成几个月一起来偿还，这种还款方式适合收入不稳定的人群</li>
<li><strong>一次性还本付息</strong>  一次性还本付息就是借款人在贷款贷款日，一次性将贷款本金和利息全部还清，这种还款方式通常在短期贷款当中会比较常见，但这种还款方式在审批方面会比较严格。</li>
<li><strong>先息后本</strong>  先息后本就是指借款人在还款前期每月只需要偿还利息，到了最后还款期限时，将借款本金及当月的利息一次性还清。</li>
</ul>
<h2 id="等额-本-息-还款法"><a href="#等额-本-息-还款法" class="headerlink" title="等额 (本 + 息) 还款法"></a>等额 (本 + 息) 还款法</h2><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>每月还款额 $M$ 的计算公式为：</p>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215350001.png"></p>
<p> 其中：</p>
<ul>
<li>$P$ 是贷款总额（本金）。</li>
<li>$r$ 是月利率（年利率除以 12）。</li>
<li>$n$ 是总月份数（贷款年数乘以 12）。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p>假设某人贷款总额为 $P &#x3D; 100,000$ 元，年利率为 $5%$（转化为小数形式为 0.05），贷款期限为 2 年。我们需要计算他每月需要还多少钱。</p>
</blockquote>
<ol>
<li><p>首先，将年利率转化为月利率：<br><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215416901.png"></p>
</li>
<li><p>然后，计算总月份数：<br><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215437935.png"></p>
</li>
<li><p>接下来，代入公式计算每月还款额：</p>
</li>
</ol>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215453068.png"></p>
<p>这个公式可以通过计算器或编程来求解。为了简化，这里不直接给出计算结果的小数点后很多位，但通常银行会提供一个精确到小数点后两位的数值。</p>
<p>假设计算结果为 $M \approx 4387.14$ 元（这个数值是近似的，实际计算时可能会有轻微差异，取决于计算精度和使用的工具）。</p>
<p>因此，在这个案例中，借款人每月需要还大约 4387.14 元，这个金额在 2 年的贷款期限内是固定的。</p>
<h3 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h3><table>
<thead>
<tr>
<th>累计支付利息</th>
<th>累计还款总额</th>
</tr>
</thead>
<tbody><tr>
<td>5291.34</td>
<td>105291.34</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>期次</th>
<th>偿还本息 (元)</th>
<th>偿还利息 (元)</th>
<th>偿还本金 (元)</th>
<th>剩余本金 (元)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4387.14</td>
<td>416.67</td>
<td>3970.47</td>
<td>96029.53</td>
</tr>
<tr>
<td>2</td>
<td>4387.14</td>
<td>400.12</td>
<td>3987.02</td>
<td>92042.51</td>
</tr>
<tr>
<td>3</td>
<td>4387.14</td>
<td>383.51</td>
<td>4003.63</td>
<td>88038.88</td>
</tr>
<tr>
<td>4</td>
<td>4387.14</td>
<td>366.83</td>
<td>4020.31</td>
<td>84018.57</td>
</tr>
<tr>
<td>5</td>
<td>4387.14</td>
<td>350.08</td>
<td>4037.06</td>
<td>79981.51</td>
</tr>
<tr>
<td>6</td>
<td>4387.14</td>
<td>333.26</td>
<td>4053.88</td>
<td>75927.63</td>
</tr>
<tr>
<td>7</td>
<td>4387.14</td>
<td>316.37</td>
<td>4070.77</td>
<td>71856.85</td>
</tr>
<tr>
<td>8</td>
<td>4387.14</td>
<td>299.4</td>
<td>4087.74</td>
<td>67769.12</td>
</tr>
<tr>
<td>9</td>
<td>4387.14</td>
<td>282.37</td>
<td>4104.77</td>
<td>63664.35</td>
</tr>
<tr>
<td>10</td>
<td>4387.14</td>
<td>265.27</td>
<td>4121.87</td>
<td>59542.48</td>
</tr>
<tr>
<td>11</td>
<td>4387.14</td>
<td>248.09</td>
<td>4139.05</td>
<td>55403.44</td>
</tr>
<tr>
<td>12</td>
<td>4387.14</td>
<td>230.85</td>
<td>4156.29</td>
<td>51247.14</td>
</tr>
<tr>
<td>13</td>
<td>4387.14</td>
<td>213.53</td>
<td>4173.61</td>
<td>47073.54</td>
</tr>
<tr>
<td>14</td>
<td>4387.14</td>
<td>196.14</td>
<td>4191</td>
<td>42882.54</td>
</tr>
<tr>
<td>15</td>
<td>4387.14</td>
<td>178.68</td>
<td>4208.46</td>
<td>38674.07</td>
</tr>
<tr>
<td>16</td>
<td>4387.14</td>
<td>161.14</td>
<td>4226</td>
<td>34448.08</td>
</tr>
<tr>
<td>17</td>
<td>4387.14</td>
<td>143.53</td>
<td>4243.61</td>
<td>30204.47</td>
</tr>
<tr>
<td>18</td>
<td>4387.14</td>
<td>125.85</td>
<td>4261.29</td>
<td>25943.18</td>
</tr>
<tr>
<td>19</td>
<td>4387.14</td>
<td>108.1</td>
<td>4279.04</td>
<td>21664.14</td>
</tr>
<tr>
<td>20</td>
<td>4387.14</td>
<td>90.27</td>
<td>4296.87</td>
<td>17367.27</td>
</tr>
<tr>
<td>21</td>
<td>4387.14</td>
<td>72.36</td>
<td>4314.78</td>
<td>13052.5</td>
</tr>
<tr>
<td>22</td>
<td>4387.14</td>
<td>54.39</td>
<td>4332.75</td>
<td>8719.74</td>
</tr>
<tr>
<td>23</td>
<td>4387.14</td>
<td>36.33</td>
<td>4350.81</td>
<td>4368.94</td>
</tr>
<tr>
<td>24</td>
<td>4387.14</td>
<td>18.2</td>
<td>4368.94</td>
<td>0</td>
</tr>
</tbody></table>
<h2 id="等额本金还款法"><a href="#等额本金还款法" class="headerlink" title="等额本金还款法"></a>等额本金还款法</h2><h3 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h3><p>每月还款额 $M_t$ 的计算公式为：</p>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215509932.png"></p>
<p>其中：</p>
<ul>
<li>$P$ 是贷款总额（本金）。</li>
<li>$n$ 是总月份数（贷款年数乘以 12）。</li>
<li>$r$ 是月利率（年利率除以 12）。</li>
<li>$t$ 是当前月份数（从 1 开始计数）。</li>
</ul>
<p>注意：这个公式中的 $\frac{P}{n}$ 是每月应还的本金部分，而 $(P - \frac{P \times (t-1)}{n}) \times r$ 是当月应还的利息部分。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>假设某人贷款总额为 $P &#x3D; 100,000$ 元，年利率为 $5%$（转化为小数形式为 0.05），贷款期限为 10 年。我们需要计算他第一个月和最后一个月需要还多少钱。</p>
<p>首先，将年利率转化为月利率，并计算总月份数：</p>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215530644.png"></p>
<h4 id="第一个月还款额"><a href="#第一个月还款额" class="headerlink" title="第一个月还款额"></a>第一个月还款额</h4><p>第一个月 $t &#x3D; 1$，代入公式：</p>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215551021.png"></p>
<p>（注意：这里的计算结果为了简化而进行了四舍五入，实际计算时可能会有轻微差异）</p>
<h4 id="最后一个月还款额"><a href="#最后一个月还款额" class="headerlink" title="最后一个月还款额"></a>最后一个月还款额</h4><p>最后一个月 $t &#x3D; 24$，代入公式：</p>
<p><img src="/assets/%E5%88%A9%E6%81%AF%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/file-20241210215608079.png"></p>
<p>（同样，这里的计算结果为了简化而进行了四舍五入）</p>
<p>因此，在这个案例中，借款人第一个月需要还约 1250 元，而最后一个月需要还约 836.80 元。由于等额本金还款法的特点，每月还款额会逐渐减少。</p>
<h3 id="计算结果-1"><a href="#计算结果-1" class="headerlink" title="计算结果"></a>计算结果</h3><table>
<thead>
<tr>
<th>累计支付利息</th>
<th>累计还款总额</th>
</tr>
</thead>
<tbody><tr>
<td>5208.33</td>
<td>105208.33</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>期次</th>
<th>偿还本息 (元)</th>
<th>偿还利息 (元)</th>
<th>偿还本金 (元)</th>
<th>剩余本金 (元)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4583.34</td>
<td>416.67</td>
<td>4166.67</td>
<td>95833.33</td>
</tr>
<tr>
<td>2</td>
<td>4565.98</td>
<td>399.31</td>
<td>4166.67</td>
<td>91666.67</td>
</tr>
<tr>
<td>3</td>
<td>4548.61</td>
<td>381.94</td>
<td>4166.67</td>
<td>87500</td>
</tr>
<tr>
<td>4</td>
<td>4531.25</td>
<td>364.58</td>
<td>4166.67</td>
<td>83333.33</td>
</tr>
<tr>
<td>5</td>
<td>4513.89</td>
<td>347.22</td>
<td>4166.67</td>
<td>79166.67</td>
</tr>
<tr>
<td>6</td>
<td>4496.53</td>
<td>329.86</td>
<td>4166.67</td>
<td>75000</td>
</tr>
<tr>
<td>7</td>
<td>4479.17</td>
<td>312.5</td>
<td>4166.67</td>
<td>70833.33</td>
</tr>
<tr>
<td>8</td>
<td>4461.81</td>
<td>295.14</td>
<td>4166.67</td>
<td>66666.67</td>
</tr>
<tr>
<td>9</td>
<td>4444.45</td>
<td>277.78</td>
<td>4166.67</td>
<td>62500</td>
</tr>
<tr>
<td>10</td>
<td>4427.09</td>
<td>260.42</td>
<td>4166.67</td>
<td>58333.33</td>
</tr>
<tr>
<td>11</td>
<td>4409.73</td>
<td>243.06</td>
<td>4166.67</td>
<td>54166.67</td>
</tr>
<tr>
<td>12</td>
<td>4392.36</td>
<td>225.69</td>
<td>4166.67</td>
<td>50000</td>
</tr>
<tr>
<td>13</td>
<td>4375</td>
<td>208.33</td>
<td>4166.67</td>
<td>45833.33</td>
</tr>
<tr>
<td>14</td>
<td>4357.64</td>
<td>190.97</td>
<td>4166.67</td>
<td>41666.67</td>
</tr>
<tr>
<td>15</td>
<td>4340.28</td>
<td>173.61</td>
<td>4166.67</td>
<td>37500</td>
</tr>
<tr>
<td>16</td>
<td>4322.92</td>
<td>156.25</td>
<td>4166.67</td>
<td>33333.33</td>
</tr>
<tr>
<td>17</td>
<td>4305.56</td>
<td>138.89</td>
<td>4166.67</td>
<td>29166.67</td>
</tr>
<tr>
<td>18</td>
<td>4288.2</td>
<td>121.53</td>
<td>4166.67</td>
<td>25000</td>
</tr>
<tr>
<td>19</td>
<td>4270.84</td>
<td>104.17</td>
<td>4166.67</td>
<td>20833.33</td>
</tr>
<tr>
<td>20</td>
<td>4253.48</td>
<td>86.81</td>
<td>4166.67</td>
<td>16666.67</td>
</tr>
<tr>
<td>21</td>
<td>4236.11</td>
<td>69.44</td>
<td>4166.67</td>
<td>12500</td>
</tr>
<tr>
<td>22</td>
<td>4218.75</td>
<td>52.08</td>
<td>4166.67</td>
<td>8333.33</td>
</tr>
<tr>
<td>23</td>
<td>4201.39</td>
<td>34.72</td>
<td>4166.67</td>
<td>4166.67</td>
</tr>
<tr>
<td>24</td>
<td>4184.03</td>
<td>17.36</td>
<td>4166.67</td>
<td>0</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>如何避免代码的深层嵌套</title>
    <url>/2024/12/09/archive/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B7%B1%E5%B1%82%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<blockquote>
<p>在编写代码，尤其是在处理复杂的逻辑或数据结构时，深层嵌套（例如，深层的条件判断或循环）可能导致代码变得难以阅读和维护。以下是一些解决深层嵌套的方法和最佳实践：</p>
</blockquote>
<h2 id="1-使用早期返回（Early-Return）"><a href="#1-使用早期返回（Early-Return）" class="headerlink" title="1. 使用早期返回（Early Return）"></a>1. <strong>使用早期返回（Early Return）</strong></h2><p>在函数或方法中，使用早期返回可以减少嵌套层级。提前处理特殊情况，尽早返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 早期返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主逻辑</span></span><br><span class="line">    process(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-避免嵌套循环"><a href="#2-避免嵌套循环" class="headerlink" title="2. 避免嵌套循环"></a>2. <strong>避免嵌套循环</strong></h2><p>如果可能，尝试将嵌套循环的逻辑分解到单独的方法中。这样可以保持主要逻辑的清晰性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">    processItem(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独处理每个项</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Detail detail : item.getDetails()) &#123;</span><br><span class="line">        <span class="comment">// 处理中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用数据结构"><a href="#3-使用数据结构" class="headerlink" title="3. 使用数据结构"></a>3. <strong>使用数据结构</strong></h2><p>通过适当的数据结构（如数组、列表或图）管理复杂的逻辑，避免多重嵌套。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Detail&gt;&gt; detailMap = groupDetailsByType(items);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Detail&gt;&gt; entry : detailMap.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    List&lt;Detail&gt; details = entry.getValue();</span><br><span class="line">    <span class="comment">// 对每种类型的详细信息进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-引入设计模式"><a href="#4-引入设计模式" class="headerlink" title="4. 引入设计模式"></a>4. <strong>引入设计模式</strong></h2><p>某些设计模式（如策略模式、状态模式）可以帮助组织代码，减少嵌套。例如，如果有复杂的条件逻辑，可以将其提取为策略类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Item item)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">ProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑 A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">ProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-前置条件退出-Guard-Clauses"><a href="#5-使用-前置条件退出-Guard-Clauses" class="headerlink" title="5. 使用 前置条件退出 (Guard Clauses)"></a>5. <strong>使用 前置条件退出 (Guard Clauses)</strong></h2><p>使用 guard clauses（前置条件）来提前退出，不需要一直进行嵌套。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Data cannot be null&quot;</span>); <span class="comment">// 前置条件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主逻辑</span></span><br><span class="line">    process(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-分解函数"><a href="#6-分解函数" class="headerlink" title="6. 分解函数"></a>6. <strong>分解函数</strong></h2><p>将复杂的函数分解为多个小函数，每个小函数做一件事情。这样不仅减少嵌套，还提高了可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValid(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">// 验证逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 例如</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述方法，你可以有效地减少代码中的深层嵌套，提高可读性和维护性。尽量保持函数的单一责任，将复杂的逻辑分解到多个层次中，以便进行清晰的组织与呈现。</p>
]]></content>
      <tags>
        <tag>代码/优化</tag>
      </tags>
  </entry>
  <entry>
    <title>相对路径的使用</title>
    <url>/2024/12/10/archive/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>./</code> 和 <code>../</code> 都是用于表示文件路径的相对路径标记。</p>
<ol>
<li><p><strong><code>./</code>：</strong> 表示当前目录。使用 <code>./</code> 可以明确指示路径从当前目录开始。</p>
<p>例如，如果当前路径是 <code>/home/user/</code>，那么 <code>./file.txt</code> 就表示 <code>/home/user/file.txt</code>。</p>
</li>
<li><p><strong><code>../</code>：</strong> 表示上一级目录。使用 <code>../</code> 可以向上移动一级目录。</p>
<p>例如，如果当前路径是 <code>/home/user/</code>，那么 <code>../folder/file.txt</code> 就表示 <code>/home/folder/file.txt</code>。</p>
</li>
</ol>
<p>示例：</p>
<p>假设有如下的文件结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/</span><br><span class="line">|-- current-folder/</span><br><span class="line">|   |-- script.js</span><br><span class="line">|   |-- image.jpg</span><br><span class="line">|</span><br><span class="line">|-- parent-folder/</span><br><span class="line">    |-- document.txt</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果 <code>script.js</code> 中包含 <code>./image.jpg</code>，那么这个路径指向的是 <code>/home/user/current-folder/image.jpg</code>。</p>
</li>
<li><p>如果 <code>script.js</code> 中包含 <code>../parent-folder/document.txt</code>，那么这个路径指向的是 <code>/home/user/parent-folder/document.txt</code>。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>运维/linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文章推荐</title>
    <url>/2024/12/09/archive/%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="VMware-虚拟机网络配置"><a href="#VMware-虚拟机网络配置" class="headerlink" title="VMware 虚拟机网络配置"></a>VMware 虚拟机网络配置</h2><p><a href="https://www.bilibili.com/read/cv7463717/">最详细的讲解，如何使用 VMnet8 模式给虚拟网络配置静态 IP，集群分布式都用它 - 哔哩哔哩 (bilibili.com)</a></p>
<h2 id="什么是分布式，分布式和集群的区别又是什么"><a href="#什么是分布式，分布式和集群的区别又是什么" class="headerlink" title="什么是分布式，分布式和集群的区别又是什么"></a>什么是分布式，分布式和集群的区别又是什么</h2><p><a href="https://blog.csdn.net/weixin_42046751/article/details/109510811">什么是分布式，分布式和集群的区别又是什么？这一篇让你彻底明白！_什么叫分布式-CSDN 博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/144491375">什么是集群？什么又是负载均衡？你说得清楚吗？ - 知乎 (zhihu.com)</a></p>
<h2 id="理解-IntellijIDEA-的项目配置和-Web-部署"><a href="#理解-IntellijIDEA-的项目配置和-Web-部署" class="headerlink" title="理解 IntellijIDEA 的项目配置和 Web 部署"></a>理解 IntellijIDEA 的项目配置和 Web 部署</h2><p><a href="https://www.cnblogs.com/deng-cc/p/6416332.html">理解 IntelliJ IDEA 的项目配置和 Web 部署 - Dulk - 博客园 (cnblogs.com)</a></p>
<h2 id="Github-配置-Ssh-Key-的步骤"><a href="#Github-配置-Ssh-Key-的步骤" class="headerlink" title="Github 配置 Ssh Key 的步骤"></a>Github 配置 Ssh Key 的步骤</h2><p><a href="https://blog.csdn.net/weixin_42310154/article/details/118340458">Github 配置 ssh key 的步骤（大白话+包含原理解释）_github 生成 ssh key-CSDN 博客</a></p>
<h2 id="使用-VirtualBox-搭建-Linux-系统——史上最详细图解教程"><a href="#使用-VirtualBox-搭建-Linux-系统——史上最详细图解教程" class="headerlink" title="使用 VirtualBox 搭建 Linux 系统——史上最详细图解教程"></a>使用 VirtualBox 搭建 Linux 系统——史上最详细图解教程</h2><p><a href="https://blog.csdn.net/AloneCoding/article/details/106809384">使用 VirtualBox 搭建 Linux 系统——史上最详细图解教程_virtualbox 屏幕监视器数量-CSDN 博客</a></p>
<h2 id="怎么画业务流程图"><a href="#怎么画业务流程图" class="headerlink" title="怎么画业务流程图"></a>怎么画业务流程图</h2><p><a href="https://www.woshipm.com/pmd/4170517.html">大话业务流程图(一)——什么是业务流程图 | 人人都是产品经理 (woshipm.com)</a></p>
<h2 id="如何使用-IDM-下载百度网盘的内容"><a href="#如何使用-IDM-下载百度网盘的内容" class="headerlink" title="如何使用 IDM 下载百度网盘的内容"></a>如何使用 IDM 下载百度网盘的内容</h2><blockquote>
<p>前提是已经安装了多线程下载工具 (也不是很好用)</p>
</blockquote>
<p><a href="https://www.youxiaohou.com/zh-cn/windows.html#_1-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8">Windows 平台使用教程 | 油小猴 (youxiaohou.com)</a></p>
<h2 id="如何画-UML"><a href="#如何画-UML" class="headerlink" title="如何画 UML"></a>如何画 UML</h2><p><a href="https://blog.csdn.net/hejnhong/article/details/130190454">UML 简易使用教程_静态建模与动态建模-CSDN 博客</a></p>
<h2 id="三层架构和-MVC-的区别"><a href="#三层架构和-MVC-的区别" class="headerlink" title="三层架构和 MVC 的区别"></a>三层架构和 MVC 的区别</h2><p><a href="https://cloud.tencent.com/developer/article/1779910">JavaWeb-MVC 与三层架构(看完这一篇就够了 最全)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="如何在-Windows-下留存-Tomcat-的-Catalina-日志"><a href="#如何在-Windows-下留存-Tomcat-的-Catalina-日志" class="headerlink" title="如何在 Windows 下留存 Tomcat 的 Catalina 日志"></a>如何在 Windows 下留存 Tomcat 的 Catalina 日志</h2><p><a href="https://blog.csdn.net/peter_qyq/article/details/82886811#:~:text=%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%9C%89%E5%9C%A8linux%E4%B8%8B%E4%BD%BF%E7%94%A8tail%20-f%20catalina.out%E6%9F%A5%E7%9C%8Btomcat%E6%97%A5%E5%BF%97%E7%9A%84%E4%B9%A0%E6%83%AF%EF%BC%8C%E5%9C%A8window%E4%B8%8B%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%20%E5%BD%93%E7%84%B6%E5%8F%AF%E4%BB%A5%E4%B8%8B%E9%9D%A2%E5%B0%B1%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E3%80%82%201%E3%80%81%E6%89%93%E5%BC%80bin%E4%B8%8B%E9%9D%A2%E7%9A%84startup.bat%E6%96%87%E4%BB%B6%EF%BC%8C%20%E6%8A%8Acall,%22%25EXECUTABLE%25%22%20start%20%25CMD_LINE_ARGS%25%20%E6%94%B9%E4%B8%BAcall%20%22%25EXECUTABLE%25%22%20run%20%25CMD_LINE_ARGS%252..._windows%E6%9F%A5%E7%9C%8Bcatalina.out%E6%96%87%E4%BB%B6">windows 下 查看 catalina.out 实时日志_windows 查看 catalina.out 文件-CSDN 博客</a></p>
<h2 id="GitHub-代码推送-kex-exchange-identification-报错"><a href="#GitHub-代码推送-kex-exchange-identification-报错" class="headerlink" title="GitHub 代码推送 kex_exchange_identification 报错"></a>GitHub 代码推送 kex_exchange_identification 报错</h2><p><a href="https://docs.github.com/zh/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">在 HTTPS 端口使用 SSH - GitHub 文档</a></p>
<p><a href="https://blog.csdn.net/CoolBoySilverBullet/article/details/135736862">【日常踩坑】解决 kex_exchange_identification 报错_kex_exchange_identification: connection closed by -CSDN 博客</a></p>
<h2 id="关于-HTMl-的行内元素"><a href="#关于-HTMl-的行内元素" class="headerlink" title="关于 HTMl 的行内元素"></a>关于 HTMl 的行内元素</h2><p><a href="https://blog.csdn.net/weixin_44706267/article/details/121022104">HTML 基础知识（一）：行内元素，块级元素，行内块元素-CSDN 博客</a></p>
<h2 id="如何查看-Mysql-执行历史-SQL"><a href="#如何查看-Mysql-执行历史-SQL" class="headerlink" title="如何查看 Mysql 执行历史 SQL"></a>如何查看 Mysql 执行历史 SQL</h2><p><a href="https://blog.csdn.net/csd_nuser/article/details/121236625">mysql 查询历史执行 sql 记录_mysql 查看执行的历史 sql 语句-CSDN 博客</a></p>
<h2 id="Git-提醒仓库所有权异常的问题"><a href="#Git-提醒仓库所有权异常的问题" class="headerlink" title="Git 提醒仓库所有权异常的问题"></a>Git 提醒仓库所有权异常的问题</h2><p><a href="https://www.cnblogs.com/live41/p/17290417.html">git bash 报错 fatal: detected dubious ownership in repository at 的解决方法 - Clotho_Lee - 博客园 (cnblogs.com)</a></p>
<h2 id="只取重复数据的第一条-Sql-实现"><a href="#只取重复数据的第一条-Sql-实现" class="headerlink" title="只取重复数据的第一条 Sql 实现"></a>只取重复数据的第一条 Sql 实现</h2><p><a href="https://blog.csdn.net/hanshanyunhai/article/details/104926731">sql 语句：根据某一个字段重复，只取 list 中第一条数据_sql 字段重复的第一条数据设置-CSDN 博客</a></p>
<h2 id="计算机单位"><a href="#计算机单位" class="headerlink" title="计算机单位"></a>计算机单位</h2><p><a href="https://blog.csdn.net/qq_41675254/article/details/86481615">bit、byte、KB、B、字节、位、字符之间关系详解_kb b bit-CSDN 博客</a></p>
<p><a href="https://tech.sina.com.cn/roll/2020-07-09/doc-iirczymm1498194.shtml#:~:text=%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%20%E6%9D%A5%E6%BA%90%EF%BC%9AIT168%20%E4%BD%8D%EF%BC%88%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%89%EF%BC%9Abit%EF%BC%88binary%20digit%EF%BC%89%EF%BC%88%E7%AE%80%E5%86%99%EF%BC%9Ab%EF%BC%89%EF%BC%8C%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D%EF%BC%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%EF%BC%8C0%E6%88%96%E8%80%851%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BD%8D%EF%BC%88%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%89bit%E3%80%82%20%E5%AD%97%E8%8A%82%EF%BC%9A%20Byte%EF%BC%88%E7%AE%80%E5%86%99%EF%BC%9AB%EF%BC%89%EF%BC%8C%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%E7%94%A8%E4%BA%8E%E8%AE%A1%E9%87%8F%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%EF%BC%8C%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E5%AD%97%E8%8A%82%E7%AD%89%E4%BA%8E%E5%85%AB%E4%BD%8D%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%20%E2%86%92,1Byte%20%3D%208bit%20%3D%201B%20%3D%208b">位(bit)、字节(Byte)、KB、MB、GB … 之间的关系|计算机<em>新浪科技</em>新浪网 (sina.com.cn)</a></p>
<h2 id="编码字符集的关系"><a href="#编码字符集的关系" class="headerlink" title="编码字符集的关系"></a>编码字符集的关系</h2><p><a href="https://www.51cto.com/article/789503.html">ASCII、Unicode、UTF-8、utf8mb4，有啥区别？-51CTO.COM</a></p>
<p><a href="https://symbl.cc/cn/unicode-table/">Unicode 符号表 - 所有 Unicode 字符及其代码都在一页上 (◕‿◕) SYMBL</a></p>
<p><a href="https://www.hello-algo.com/chapter_data_structure/character_encoding/">3.4   字符编码 * - Hello 算法 (hello-algo.com)</a></p>
<h3 id="如何理解从代码到程序到网络的字符编码流程"><a href="#如何理解从代码到程序到网络的字符编码流程" class="headerlink" title="如何理解从代码到程序到网络的字符编码流程"></a>如何理解从代码到程序到网络的字符编码流程</h3><ol>
<li><p>代码编写阶段</p>
<ul>
<li><strong>文本编辑器</strong>：程序员使用文本编辑器（如 VS Code、Notepad++、IntelliJ IDEA 等）编写源代码。</li>
<li><strong>文本编码</strong>：文本编辑器通常会以某种字符编码（如 UTF-8、GBK、ISO-8859-1 等）保存文件。这个编码是程序员在保存文件时选择的，或者是文本编辑器的默认设置。</li>
</ul>
</li>
<li><p>编译&#x2F;解释阶段</p>
<ul>
<li><strong>读取源代码</strong>：编译器或解释器（如 Java 编译器 <code>javac</code>）读取源代码文件。此时，编译器会根据文件的实际编码来解析字符。</li>
<li><strong>转换为内部表示</strong>：编译器将读取的字符转换为内部使用的字符集（通常是 UTF-16，因为 Java 内部使用 UTF-16 编码字符）。这个转换过程确保了编译器能够正确理解源代码中的字符。</li>
<li><strong>编译&#x2F;解释</strong>：编译器将源代码转换为字节码（对于 Java），或者解释器直接执行代码（对于 Python 等解释型语言）。</li>
</ul>
</li>
<li><p>运行时阶段</p>
<ul>
<li><strong>加载字节码</strong>：Java 虚拟机（JVM）加载字节码并将其转换为机器码执行。在这个过程中，字符串和字符在内存中以 UTF-16 编码存储。</li>
<li><strong>内存中的字符串</strong>：在运行时，Java 程序中的字符串以 UTF-16 编码存储在内存中。这意味着每个字符占用 2 个字节（对于 BMP 字符）或 4 个字节（对于辅助平面字符）。</li>
</ul>
</li>
<li><p>网络传输阶段</p>
<ul>
<li><strong>字符串转换</strong>：当需要将字符串通过网络传输时，通常需要将其转换为特定的字节序列（如 UTF-8）。Java 提供了 <code>String.getBytes(Charset charset)</code> 方法，可以将字符串转换为指定编码的字节数组。<code>getBytes</code> 默认不传值的时候，采用的是虚拟机的默认字符编码，如果虚拟机未设置字符编码，则是按照 UTF-8</li>
<li><strong>网络传输</strong>：转换后的字节数组通过网络传输。接收方在接收到字节数组后，需要使用相同的编码将其转换回字符串。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><strong>代码编写</strong>：程序员使用特定编码保存源代码文件。</li>
<li><strong>编译&#x2F;解释</strong>：编译器或解释器读取源代码文件并将其转换为内部字符集表示。</li>
<li><strong>运行时</strong>：字符串和字符在内存中以 UTF-16 编码存储。</li>
<li><strong>网络传输</strong>：字符串在传输前需要转换为特定编码的字节数组，接收方再将其转换回字符串。</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过这个流程，确保了从代码编写到程序执行再到网络传输的字符编码的一致性和正确性。</p>
</blockquote>
<p>控制台乱码的本质，也相当于写入到文本中的字符乱码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;这段话打印到控制台&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在GBK编码的控制台下能够显示正确</span></span><br><span class="line"></span><br><span class="line">outputStream.write(str.getBytes(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在UTF-8编码的控制台下能够显示正确</span></span><br><span class="line"></span><br><span class="line">outputStream.write(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/file-20240824150807221.png"></p>
<h2 id="如何安装-JRebel-插件"><a href="#如何安装-JRebel-插件" class="headerlink" title="如何安装 JRebel 插件"></a>如何安装 JRebel 插件</h2><p><a href="https://blog.csdn.net/weixin_41791276/article/details/129185606">JRebel and XRebel 插件在IDEA中的安装、激活和使用_jrebel and xrebel激活-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_46344165/article/details/117751425">基于JRebel实现Idea热部署和XRebel的性能监控，听叔的，别再手动重启项目了_idea xrebel-CSDN博客</a></p>
<h2 id="如何理解-Python-中的模块，包的概念"><a href="#如何理解-Python-中的模块，包的概念" class="headerlink" title="如何理解 Python 中的模块，包的概念"></a>如何理解 Python 中的模块，包的概念</h2><p><a href="https://blog.csdn.net/Bit_Coders/article/details/119318000">详解Python模块化——模块（Modules）和包（Packages）_python包与模块-CSDN博客</a></p>
<h2 id="Mysql-远程登录报错问题"><a href="#Mysql-远程登录报错问题" class="headerlink" title="Mysql 远程登录报错问题"></a>Mysql 远程登录报错问题</h2><p><a href="https://blog.csdn.net/mazaiting/article/details/106661158">MySQL 异常: “Host ‘xxx’ is not allowed to connect to this MySQL server”-CSDN博客</a></p>
<h2 id="Element-Ui-流体表格报错"><a href="#Element-Ui-流体表格报错" class="headerlink" title="Element-Ui 流体表格报错"></a>Element-Ui 流体表格报错</h2><p><a href="https://blog.csdn.net/g2526/article/details/137841367">vue3: 报错ResizeObserver loop completed with undelivered notifications.解决方法_vue3 uncaught runtime errors: 脳 error resizeobserv-CSDN博客</a></p>
<h2 id="Java-实现单例的几种方式"><a href="#Java-实现单例的几种方式" class="headerlink" title="Java 实现单例的几种方式"></a>Java 实现单例的几种方式</h2><p><a href="https://blog.csdn.net/u014672511/article/details/79774847">Java实现单例的5种方式_java单例模式创建方式-CSDN博客</a></p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p><a href="https://blog.csdn.net/chushoufengli/article/details/104535873">RSA加密 和 SHA256签名函数_rsa sha256-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的几种状态</title>
    <url>/2025/05/26/archive/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">mindmap
	(线程的几种状态)
		(就绪态-已经生成创建完成了线程对象，但是未调用start方法)
		(运行态-是就绪态和运行中的统称)
			(就绪态-未抢占到cpu时间片)
			(运行中-抢占到了时间片) 
		(阻塞态)
		(等待态-进入该线程需要其他线程做出特定动作 通知/中断)
		(超时等待-指定时间后，可以自行返回)
		(终止态度-线程执行完毕)
		
    

</code></pre>

<p><img src="/assets/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/file-20250526135653833.png"></p>
<p><img src="/assets/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/file-20250526170925112.png"></p>
]]></content>
      <tags>
        <tag>后端/Java/八股</tag>
      </tags>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
